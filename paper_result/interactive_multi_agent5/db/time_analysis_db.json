[
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -23.76291481494683,
                "time_improvement": 61.0,
                "length_improvement": 8.0,
                "smoothness_improvement": 166.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.012529301643371581,
                        "num_nodes_avg": 131.9,
                        "path_length_avg": 176.77827310097746,
                        "smoothness_avg": 0.01645631271580969,
                        "success_improvement": 0.0,
                        "time_improvement": 48.408166070262766,
                        "length_improvement": 3.105027282357968,
                        "smoothness_improvement": 157.5770294574498,
                        "objective_score": 17.173351337780858
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.01886875629425049,
                        "num_nodes_avg": 256.8,
                        "path_length_avg": 267.7347696890942,
                        "smoothness_avg": 0.010597136127488454,
                        "success_improvement": 0.0,
                        "time_improvement": 88.31404606735866,
                        "length_improvement": 10.622427559723258,
                        "smoothness_improvement": 172.67194536891012,
                        "objective_score": 33.7310300828861
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.026641178131103515,
                        "num_nodes_avg": 304.4,
                        "path_length_avg": 136.29588257526552,
                        "smoothness_avg": 0.02101448639210645,
                        "success_improvement": 0.0,
                        "time_improvement": 46.20196913892299,
                        "length_improvement": 9.478764505998065,
                        "smoothness_improvement": 167.3027157795587,
                        "objective_score": 20.384363024173528
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm with post-optimization: a single-tree, asymptotically optimal sampler that, after the first feasible path, restricts sampling to a start\u2013goal prolate hyperspheroid to accelerate convergence while continuing local rewiring to reduce path cost.",
                "planning_mechanism": "Mechanism: (1) Grow one tree from the start using uniform sampling; (2) when a goal-connecting edge is found, record the best cost and switch to informed sampling inside the ellipsoid defined by start, goal, and current best path length; (3) for each sample, steer a step from the nearest node, then select the lowest-cost parent among nearby nodes and rewire neighbors if the new node offers cheaper paths; (4) whenever the new node lies within one step of the goal and the edge is collision-free, connect and update the best path; (5) after the first solution, continue only a limited number of additional iterations or until no further improvements occur; (6) every candidate node and edge is validated against obstacle occupancy and line-segment collisions, and results include the best path found within the iteration budget.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 post_opt_iters: int = 500, max_no_improve: int = 150,\n                 improve_tol: float = 1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        goal_node = Node(goal)\n        nodes.append(root)\n        tree = [root]\n\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        c_min = math.dist(start, goal)\n\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        for _ in range(self.max_iter):\n            x_rand = self._sample(start, goal, best_cost, c_min, is_3d, bounds)\n\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n            x_new_pos = self._steer(x_nearest.position, x_rand)\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            x_new = Node(x_new_pos)\n            near_nodes = [n for n in tree if math.dist(n.position, x_new_pos) <= 20.0]\n\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near_nodes:\n                new_cost = n.cost + math.dist(n.position, x_new_pos)\n                if new_cost < min_cost and not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                    best_parent = n\n                    min_cost = new_cost\n\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            x_new.parent = best_parent\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            for n in near_nodes:\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost + 1e-12 < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        if n in n.parent.children:\n                            n.parent.children.remove(n)\n                    n.parent = x_new\n                    n.cost = alt_cost\n                    x_new.add_child(n)\n                    edges.append((x_new, n))\n\n            if math.dist(x_new.position, goal) < self.step_size and                not self._is_edge_in_obstacle(x_new.position, goal, obstacles, is_3d):\n                # \uc0c8 \ud574 \ud6c4\ubcf4\n                goal_node = Node(goal)  # \ubaa9\ud45c \ub178\ub4dc\ub294 \uc0c8\ub85c \ub9cc\ub4e4\uc5b4 \uba85\ud655\ud788 \uc5f0\uacb0\n                goal_node.parent = x_new\n                goal_node.cost = x_new.cost + math.dist(x_new.position, goal)\n                nodes.append(goal_node)\n                edges.append((x_new, goal_node))\n\n                if goal_node.cost + self.improve_tol < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    no_improve_streak = 0  \n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0  \n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        if success_state and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample(self, start, goal, c_best, c_min, is_3d, bounds):\n        import numpy as np\n        import math, random\n\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        dim = len(start)\n        L = np.diag([c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1))\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        I = np.eye(dim)\n        M = np.outer(a1, I[:, 0])\n        U, _, Vt = np.linalg.svd(M)\n        C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(x_ball)\n            if norm > 1e-6:\n                x_ball = x_ball / norm * random.random() ** (1.0 / dim)\n            x_rand = np.dot(C, np.dot(L, x_ball)) + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    \n",
                "objective": 254.21494524343552,
                "time_improvement": -899.0,
                "length_improvement": 22.0,
                "smoothness_improvement": 414.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.35683939456939695,
                        "num_nodes_avg": 772.1,
                        "path_length_avg": 150.94653533720216,
                        "smoothness_avg": 0.030245912861543284,
                        "success_improvement": 0.0,
                        "time_improvement": -1369.3555401750432,
                        "length_improvement": 17.263812080762307,
                        "smoothness_improvement": 373.41421633417696,
                        "objective_score": -398.5813037223847
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.6798739194869995,
                        "num_nodes_avg": 1185.7,
                        "path_length_avg": 222.10813211370723,
                        "smoothness_avg": 0.021429118285859527,
                        "success_improvement": 0.0,
                        "time_improvement": -321.06512900112574,
                        "length_improvement": 25.853912472332702,
                        "smoothness_improvement": 451.3866482651889,
                        "objective_score": -78.55025797561215
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.5478150129318238,
                        "num_nodes_avg": 1082.6,
                        "path_length_avg": 114.7698430835218,
                        "smoothness_avg": 0.040749199207674086,
                        "success_improvement": 0.0,
                        "time_improvement": -1006.2336968296382,
                        "length_improvement": 23.77533497656441,
                        "smoothness_improvement": 418.326806128603,
                        "objective_score": -285.51327403230977
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "A bidirectional variant of RRT* with informed sampling and efficient rewiring that grows two trees simultaneously, restricts sampling to an ellipsoidal informed subset after first solution, and performs local rewiring to improve path cost and smoothness with early termination on convergence.",
            "planning_mechanism": "The planner grows start and goal trees bidirectionally with RRT* rewiring, initially samples uniformly to quickly find a path, then constrains samples to an ellipsoidal informed set defined by the current best path cost. After each extension, it attempts to connect the two trees if close enough, while performing localized rewiring to continuously improve path quality. Early stopping criteria limit iterations after no improvements to reduce planning time.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, radius=15.0,\n                 post_opt_iters=500, max_no_improve=100, improve_tol=1e-5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n\n        c_min = math.dist(start, goal)\n        found_solution = False\n\n        no_improve_count = 0\n        post_opt_count = 0\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            return tuple(frm[i] + (to[i]-frm[i]) * self.step_size / d for i in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            distance = dist(f, t)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                inter = tuple(f[j] + (t[j]-f[j])*(i/steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def nearest(tree, p):\n            best = tree[0]\n            best_d = dist(best.position, p)\n            for n in tree:\n                d2 = dist(n.position, p)\n                if d2 < best_d:\n                    best = n\n                    best_d = d2\n            return best\n\n        def near_nodes(tree, p, radius):\n            result = []\n            r2 = radius**2\n            for n in tree:\n                d2 = sum((n.position[i]-p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def extract_path(n_start, n_goal):\n            path_start, node = [], n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def ellipsoid_sample(c_best):\n            # Sample inside prolate hyperspheroid defined by start, goal, c_best\n            import random\n            import math\n\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i]+goal[i])/2 for i in range(dim))\n            a1 = [goal[i]-start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-12:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            # Compute rotation matrix via Gram-Schmidt or approximate as identity except along a1 axis\n            # For simplicity, rotate only along principal axis for 2D or 3D (orthonormal basis)\n            # Since imports are restricted, implement a simple orthonormal basis:\n\n            # Construct orthonormal basis U with unit_a1 as first vector\n            U = [unit_a1]\n            for i in range(dim-1):\n                base = [0]*dim\n                base[(i+1)%dim] = 1  # simple perpendicular approx\n                # Gram-Schmidt orthogonalize base vs U\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j]-proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-12:\n                    U.append([x/norm_base for x in base])\n                else:\n                    # fallback: constructs zero vector, skip\n                    U.append([0]*dim)\n\n            # L matrix diagonal\n            r1 = c_best / 2\n            if c_best*c_best - c_min*c_min < 0:\n                r2 = 0\n            else:\n                r2 = math.sqrt(c_best*c_best - c_min*c_min) / 2\n            radii = [r1] + [r2] * (dim - 1)\n\n            # Sample unit ball in dim\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-12:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n\n                # Scale by radii\n                point_scaled = [radii[i]*point_ball[i] for i in range(dim)]\n\n                # Rotate via U matrix: point = sum(point_scaled[i] * U[i]) over basis vectors\n                point_rotated = [0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i]*U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        for iter_count in range(self.max_iter):\n            if found_solution:\n                sample_pt = ellipsoid_sample(best_cost)\n            else:\n                sample_pt = ellipsoid_sample(float('inf'))\n\n            # Alternate growing start and goal trees\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n\n                if in_obstacle(new_pos) or edge_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                near = near_nodes(tree_a, new_pos, self.radius)\n\n                # Choose best parent in near nodes with minimal cost + dist and collision free edge\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for candidate in near:\n                    cand_cost = candidate.cost + dist(candidate.position, new_pos)\n                    if cand_cost + self.improve_tol < min_cost and not edge_obstacle(candidate.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = candidate\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire near nodes if new_node offers lower cost connection\n                for near_node in near:\n                    if near_node == best_parent:\n                        continue\n                    alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if alt_cost + self.improve_tol < near_node.cost and not edge_obstacle(new_node.position, near_node.position):\n                        # Remove old edge\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                        if near_node.parent and near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n                # Try connect trees if nodes close enough\n                connect_node = nearest(tree_b, new_node.position)\n                if dist(new_node.position, connect_node.position) <= self.step_size and not edge_obstacle(new_node.position, connect_node.position):\n                    path = extract_path(new_node, connect_node)\n                    path_cost = new_node.cost + dist(new_node.position, connect_node.position) + connect_node.cost\n                    if path_cost + self.improve_tol < best_cost:\n                        best_cost = path_cost\n                        # Stitch trees at connection nodes: assign parents carefully\n                        # For bidirectional path extraction, keep nodes and edges unchanged,\n                        # just store nodes for path extraction\n                        best_path = path\n                        found_solution = True\n                        best_goal_node = connect_node\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n\n                    if found_solution and no_improve_count >= self.max_no_improve:\n                        post_opt_count += 1\n                        if post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_opt_count += 1\n                        if no_improve_count >= self.max_no_improve or post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
            "objective": 52.64884,
            "time_improvement": -220.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 323.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06786198616027832,
                    "num_nodes_avg": 317.3,
                    "path_length_avg": 155.50621247453464,
                    "smoothness_avg": 0.02411673119934513,
                    "success_improvement": 0.0,
                    "time_improvement": -179.4349134355319,
                    "length_improvement": 14.764580789082476,
                    "smoothness_improvement": 277.4792135897667,
                    "objective_score": -43.58432948926125
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.14667820930480957,
                    "num_nodes_avg": 670.6,
                    "path_length_avg": 226.29277909188164,
                    "smoothness_avg": 0.017873034085429756,
                    "success_improvement": 0.0,
                    "time_improvement": 9.158040406689327,
                    "length_improvement": 24.45695686263326,
                    "smoothness_improvement": 359.8860404442116,
                    "objective_score": 19.22101644180781
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2925038576126099,
                    "num_nodes_avg": 613.1,
                    "path_length_avg": 120.56565817380633,
                    "smoothness_avg": 0.03399415459254427,
                    "success_improvement": 0.0,
                    "time_improvement": -490.6695072338173,
                    "length_improvement": 19.926030560654297,
                    "smoothness_improvement": 332.4031372296796,
                    "objective_score": -133.58321814760419
                }
            ],
            "success_rate": 1.0
        },
        "objective": -19.599999999999994,
        "analysis": {
            "problem": [
                ""
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Incorporation of bidirectional tree growth with efficient swapping and connection attempts.\n   - Adoption of informed sampling restricting samples to an ellipsoidal subset after first solution.\n   - Enhanced local rewiring with improved heuristics and adaptive radius.\n   - Introduction of early stopping criteria based on no improvement counters and iteration limits.\n2. Expected mechanism of impact:\n   - More focused sampling accelerates discovery of better paths and avoids unnecessary exploration.\n   - Faster nearest-neighbor and rewiring operations reduce per-iteration computational overhead.\n   - Early termination prevents wasteful computations after path quality convergence.\n   - Improved rewiring and connection strategies generate shorter, smoother paths more rapidly."
        }
    },
    {
        "parents": [
            {
                "operator": "e2",
                "algorithm_description": "A bidirectional variant of RRT* with informed sampling and efficient rewiring that grows two trees simultaneously, restricts sampling to an ellipsoidal informed subset after first solution, and performs local rewiring to improve path cost and smoothness with early termination on convergence.",
                "planning_mechanism": "The planner grows start and goal trees bidirectionally with RRT* rewiring, initially samples uniformly to quickly find a path, then constrains samples to an ellipsoidal informed set defined by the current best path cost. After each extension, it attempts to connect the two trees if close enough, while performing localized rewiring to continuously improve path quality. Early stopping criteria limit iterations after no improvements to reduce planning time.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, radius=15.0,\n                 post_opt_iters=500, max_no_improve=100, improve_tol=1e-5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n\n        c_min = math.dist(start, goal)\n        found_solution = False\n\n        no_improve_count = 0\n        post_opt_count = 0\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            return tuple(frm[i] + (to[i]-frm[i]) * self.step_size / d for i in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            distance = dist(f, t)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                inter = tuple(f[j] + (t[j]-f[j])*(i/steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def nearest(tree, p):\n            best = tree[0]\n            best_d = dist(best.position, p)\n            for n in tree:\n                d2 = dist(n.position, p)\n                if d2 < best_d:\n                    best = n\n                    best_d = d2\n            return best\n\n        def near_nodes(tree, p, radius):\n            result = []\n            r2 = radius**2\n            for n in tree:\n                d2 = sum((n.position[i]-p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def extract_path(n_start, n_goal):\n            path_start, node = [], n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def ellipsoid_sample(c_best):\n            # Sample inside prolate hyperspheroid defined by start, goal, c_best\n            import random\n            import math\n\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i]+goal[i])/2 for i in range(dim))\n            a1 = [goal[i]-start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-12:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            # Compute rotation matrix via Gram-Schmidt or approximate as identity except along a1 axis\n            # For simplicity, rotate only along principal axis for 2D or 3D (orthonormal basis)\n            # Since imports are restricted, implement a simple orthonormal basis:\n\n            # Construct orthonormal basis U with unit_a1 as first vector\n            U = [unit_a1]\n            for i in range(dim-1):\n                base = [0]*dim\n                base[(i+1)%dim] = 1  # simple perpendicular approx\n                # Gram-Schmidt orthogonalize base vs U\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j]-proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-12:\n                    U.append([x/norm_base for x in base])\n                else:\n                    # fallback: constructs zero vector, skip\n                    U.append([0]*dim)\n\n            # L matrix diagonal\n            r1 = c_best / 2\n            if c_best*c_best - c_min*c_min < 0:\n                r2 = 0\n            else:\n                r2 = math.sqrt(c_best*c_best - c_min*c_min) / 2\n            radii = [r1] + [r2] * (dim - 1)\n\n            # Sample unit ball in dim\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-12:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n\n                # Scale by radii\n                point_scaled = [radii[i]*point_ball[i] for i in range(dim)]\n\n                # Rotate via U matrix: point = sum(point_scaled[i] * U[i]) over basis vectors\n                point_rotated = [0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i]*U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        for iter_count in range(self.max_iter):\n            if found_solution:\n                sample_pt = ellipsoid_sample(best_cost)\n            else:\n                sample_pt = ellipsoid_sample(float('inf'))\n\n            # Alternate growing start and goal trees\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n\n                if in_obstacle(new_pos) or edge_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                near = near_nodes(tree_a, new_pos, self.radius)\n\n                # Choose best parent in near nodes with minimal cost + dist and collision free edge\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for candidate in near:\n                    cand_cost = candidate.cost + dist(candidate.position, new_pos)\n                    if cand_cost + self.improve_tol < min_cost and not edge_obstacle(candidate.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = candidate\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire near nodes if new_node offers lower cost connection\n                for near_node in near:\n                    if near_node == best_parent:\n                        continue\n                    alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if alt_cost + self.improve_tol < near_node.cost and not edge_obstacle(new_node.position, near_node.position):\n                        # Remove old edge\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                        if near_node.parent and near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n                # Try connect trees if nodes close enough\n                connect_node = nearest(tree_b, new_node.position)\n                if dist(new_node.position, connect_node.position) <= self.step_size and not edge_obstacle(new_node.position, connect_node.position):\n                    path = extract_path(new_node, connect_node)\n                    path_cost = new_node.cost + dist(new_node.position, connect_node.position) + connect_node.cost\n                    if path_cost + self.improve_tol < best_cost:\n                        best_cost = path_cost\n                        # Stitch trees at connection nodes: assign parents carefully\n                        # For bidirectional path extraction, keep nodes and edges unchanged,\n                        # just store nodes for path extraction\n                        best_path = path\n                        found_solution = True\n                        best_goal_node = connect_node\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n\n                    if found_solution and no_improve_count >= self.max_no_improve:\n                        post_opt_count += 1\n                        if post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_opt_count += 1\n                        if no_improve_count >= self.max_no_improve or post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
                "objective": 52.64884,
                "time_improvement": -220.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 323.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.06786198616027832,
                        "num_nodes_avg": 317.3,
                        "path_length_avg": 155.50621247453464,
                        "smoothness_avg": 0.02411673119934513,
                        "success_improvement": 0.0,
                        "time_improvement": -179.4349134355319,
                        "length_improvement": 14.764580789082476,
                        "smoothness_improvement": 277.4792135897667,
                        "objective_score": -43.58432948926125
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.14667820930480957,
                        "num_nodes_avg": 670.6,
                        "path_length_avg": 226.29277909188164,
                        "smoothness_avg": 0.017873034085429756,
                        "success_improvement": 0.0,
                        "time_improvement": 9.158040406689327,
                        "length_improvement": 24.45695686263326,
                        "smoothness_improvement": 359.8860404442116,
                        "objective_score": 19.22101644180781
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.2925038576126099,
                        "num_nodes_avg": 613.1,
                        "path_length_avg": 120.56565817380633,
                        "smoothness_avg": 0.03399415459254427,
                        "success_improvement": 0.0,
                        "time_improvement": -490.6695072338173,
                        "length_improvement": 19.926030560654297,
                        "smoothness_improvement": 332.4031372296796,
                        "objective_score": -133.58321814760419
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "An enhanced bidirectional RRT* variant that incorporates adaptive neighbor radius shrinking to concentrate rewiring efforts for local optimality, an efficient nearest-neighbor caching structure for faster lookups, and progressive informed sampling with dynamic ellipsoidal restriction. The planner prioritizes early discovery and incremental path improvement, applies a smooth path shortcutting post-processing step to reduce path length and curvature, and enforces robust termination criteria based on stagnation and solution quality thresholds to minimize planning time.",
            "planning_mechanism": "The planner grows two trees alternately with rewiring using an adaptive radius, restricts sampling progressively to a shrinking ellipsoid after finding a solution to focus on promising areas, connects the trees upon proximity, and applies a final shortcut smoothing pass to improve total path length and smoothness before returning the best feasible path found within iteration and time limits.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, n_near_const=35, \n                 max_no_improve=80, improve_tol=1e-6, shortcut_iters=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const  # base neighbor count for adaptive radius\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        # --- Local helper imports & definitions ---\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        dist = lambda a, b: math.dist(a, b)\n\n        # Node collections\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        # To reduce overhead of nearest neighbor search, cache all nodes' positions lists for faster processing\n        # We implement simple linear searches but with caching and limit radius dynamically to reduce checks\n\n        # Adaptive radius for near-node rewiring, shrinks with best_cost to focus local improvements\n        # r_n = min((gamma * (log(n)/n))^(1/d), max_radius) but approximate w/o logs for lightweight\n        def adaptive_radius(n_nodes, c_best):\n            # Use gamma ~ 30 (typical for 2D), avoid zero or undefined\n            gamma = self.n_near_const\n            if n_nodes == 0:\n                return self.step_size * 2.5\n            r = min((gamma * (math.log(n_nodes)/n_nodes))**(1/dim), self.step_size * 5)\n            # Shrink with c_best, stronger around best solution to focus rewiring\n            if c_best == float('inf'):\n                return r\n            shrink_factor = max(0.25, c_best / (c_min * 3))\n            return max(self.step_size*0.75, r * shrink_factor)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-10:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[j] + (t[j] - f[j]) * (i / steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        # Efficient nearest neighbor search (linear but with early exit)\n        def nearest(tree, p):\n            best = None\n            best_d = float('inf')\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 >= best_d*best_d:\n                        break\n                else:\n                    d = math.sqrt(d2)\n                    if d < best_d:\n                        best = n\n                        best_d = d\n            return best\n\n        # Near nodes within radius (adaptive radius)\n        def near_nodes(tree, p, radius):\n            r2 = radius*radius\n            result = []\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 > r2:\n                        break\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        # Extract path from start via parent chain\n        def extract_path(node_start_root):\n            return node_start_root.path_from_root()\n\n        # Extract full path from two connection nodes (start tree and goal tree)\n        def connect_path(n_start, n_goal):\n            path_start = extract_path(n_start)\n            path_goal_rev = extract_path(n_goal)\n            path_goal = path_goal_rev[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        # Ellipsoidal informed sampling centered between start and goal, focused progressively as c_best shrinks\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-12:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Orthonormal basis U with unit_a1 first vector\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0] * dim\n                base[(idx + 1) % dim] = 1\n                for u in U:\n                    proj = sum(base[j] * u[j] for j in range(dim))\n                    base = [base[j] - proj * u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-12:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0] * dim)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-12:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n                point_scaled = [radii[i] * point_ball[i] for i in range(dim)]\n\n                point_rotated = [0.0] * dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i] * U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        # Path shortcutting by attempting to connect non-adjacent nodes directly if collision free\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                changed = False\n                iter_count += 1\n                i = 0\n                while i < len(path) - 2:\n                    j = min(len(path) - 1, i + 2 + random.randint(0, 3))\n                    if j > i + 1 and not edge_obstacle(path[i], path[j]):\n                        # Shortcut feasible, remove intermediate nodes\n                        path = path[:i + 1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Add node to tree selecting best parent among near nodes\n        def add_node(tree, new_pos, nodes_all, edges, c_best):\n            nn = nearest(tree, new_pos)\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(nodes_all)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos_steered, radius)\n\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos_steered)\n            for near_node in near:\n                if near_node == nn:\n                    continue\n                cand_cost = near_node.cost + dist(near_node.position, new_pos_steered)\n                if cand_cost + self.improve_tol < best_cost and not edge_obstacle(near_node.position, new_pos_steered):\n                    best_parent = near_node\n                    best_cost = cand_cost\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if beneficial\n            for near_node in near:\n                if near_node is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not edge_obstacle(new_node.position, near_node.position):\n                        # Remove old parent-child relationship\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n            return new_node\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n        start_time = time.time()\n\n        for iter_count in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate tree growing: start tree first odd iters, goal second even iters\n            if iter_count % 2 == 0:\n                tree_a = start_tree\n                tree_b = goal_tree\n            else:\n                tree_a = goal_tree\n                tree_b = start_tree\n\n            new_node = add_node(tree_a, sample_pt, nodes_all, edges, best_cost)\n            if new_node is None:\n                # Could not add node (collision), continue\n                continue\n\n            # Attempt connection to other tree\n            nearest_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_b.position) <= self.step_size:\n                if not edge_obstacle(new_node.position, nearest_b.position):\n                    # Connect path candidates\n                    path_candidate = connect_path(new_node, nearest_b)\n                    candidate_cost = new_node.cost + dist(new_node.position, nearest_b.position) + nearest_b.cost\n\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = path_candidate\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            # Early termination when no meaningful improvement for long\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            # Restart no improve count if significant improvement detected\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                no_improve_count = 0\n                last_best_cost = best_cost\n\n        # Final path smoothing via shortcutting if solution found\n        if found_solution and len(best_path) > 2:\n            best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
            "objective": -12.90672,
            "time_improvement": -15.0,
            "length_improvement": 14.0,
            "smoothness_improvement": 1865.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03639078140258789,
                    "num_nodes_avg": 237.0,
                    "path_length_avg": 168.02193260520104,
                    "smoothness_avg": 0.04984815517379989,
                    "success_improvement": 0.0,
                    "time_improvement": -49.84611306639963,
                    "length_improvement": 7.9045162611873945,
                    "smoothness_improvement": 680.2318754714814,
                    "objective_score": -6.809964785850045
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.046571874618530275,
                    "num_nodes_avg": 354.8,
                    "path_length_avg": 240.5937710240402,
                    "smoothness_avg": 0.12631217131652547,
                    "success_improvement": 0.0,
                    "time_improvement": 71.15672210389786,
                    "length_improvement": 19.68287412444948,
                    "smoothness_improvement": 3150.1031469538016,
                    "objective_score": 48.907256840608056
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08302063941955566,
                    "num_nodes_avg": 467.5,
                    "path_length_avg": 130.26416789587537,
                    "smoothness_avg": 0.14664374877167838,
                    "success_improvement": 0.0,
                    "time_improvement": -67.64825112539418,
                    "length_improvement": 13.484742196660818,
                    "smoothness_improvement": 1765.2976602601516,
                    "objective_score": -3.377141718321006
                }
            ],
            "success_rate": 1.0
        },
        "objective": -91.0,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient nearest and near-node searches performed via linear scans without adaptive radius control, leading to costly computations and longer planning times.\n   - Rewiring strategies used fixed-radius neighborhoods regardless of tree size or best path cost, resulting in suboptimal local improvements and slower convergence.\n   - Lack of dedicated path smoothing or shortcutting post-processing causes longer, less smooth trajectories.\n   - Sampling was not adaptively focused after initial solution discovery, limiting efficiency in refining paths."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Introduction of an adaptive neighbor radius for rewiring that shrinks with solution quality, concentrating optimization efforts locally.\n   - Efficient nearest neighbor searches with early pruning to reduce computational overhead.\n   - Progressive informed sampling with dynamic ellipsoidal restriction focusing exploration near the current best path.\n   - Incorporation of a path shortcutting post-processing step for smoothing trajectories and reducing path length.\n   - Early termination based on stagnation in improvement to save computational time.\n2. Expected mechanism of impact:\n   - Adaptive radius reduces unnecessary neighbor checks as the tree grows, lowering per-iteration cost and improving runtime.\n   - Focused sampling limits exploration to promising regions, accelerating discovery and improvement of solutions.\n   - Shortcutting improves path smoothness and shortens length post planning, enhancing overall trajectory quality.\n   - Early stopping avoids wasted iterations after convergence, resulting in reduced planning times."
        }
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
                "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -22.142109273517423,
                "time_improvement": 49.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 177.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.018251991271972655,
                        "num_nodes_avg": 78.7,
                        "path_length_avg": 175.55592835957023,
                        "smoothness_avg": 0.017196193462405217,
                        "success_improvement": 0.0,
                        "time_improvement": 24.843879619675935,
                        "length_improvement": 3.775013804415195,
                        "smoothness_improvement": 169.1577698184268,
                        "objective_score": 10.563961017644031
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.04780585765838623,
                        "num_nodes_avg": 302.9,
                        "path_length_avg": 259.03658233660315,
                        "smoothness_avg": 0.01078988487631875,
                        "success_improvement": 0.0,
                        "time_improvement": 70.39248153962646,
                        "length_improvement": 13.526132861425937,
                        "smoothness_improvement": 177.6315095076258,
                        "objective_score": 30.121581726281626
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.023344540596008302,
                        "num_nodes_avg": 176.0,
                        "path_length_avg": 128.09376742543256,
                        "smoothness_avg": 0.022442540549775757,
                        "success_improvement": 0.0,
                        "time_improvement": 52.85905490960737,
                        "length_improvement": 14.926218845764677,
                        "smoothness_improvement": 185.467459257119,
                        "objective_score": 25.74078507662661
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
                "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -18.199350067879823,
                "time_improvement": 67.0,
                "length_improvement": -4.0,
                "smoothness_improvement": 78.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.009241986274719238,
                        "num_nodes_avg": 98.6,
                        "path_length_avg": 188.60059541559173,
                        "smoothness_avg": 0.011107369580525531,
                        "success_improvement": 0.0,
                        "time_improvement": 61.94432581815326,
                        "length_improvement": -3.3749749149674124,
                        "smoothness_improvement": 73.85445397432328,
                        "objective_score": 16.927585066337148
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.013762164115905761,
                        "num_nodes_avg": 215.1,
                        "path_length_avg": 298.4716236591105,
                        "smoothness_avg": 0.007330142954732018,
                        "success_improvement": 0.0,
                        "time_improvement": 91.47670289636794,
                        "length_improvement": 0.3615809932444448,
                        "smoothness_improvement": 88.6098579138185,
                        "objective_score": 28.103008754426142
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.02535843849182129,
                        "num_nodes_avg": 323.5,
                        "path_length_avg": 164.19293370544943,
                        "smoothness_avg": 0.013510302519313377,
                        "success_improvement": 0.0,
                        "time_improvement": 48.79227750896705,
                        "length_improvement": -9.049128539847096,
                        "smoothness_improvement": 71.85005081886685,
                        "objective_score": 9.567456382876191
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "A bidirectional RRT* inspired planner that grows two trees from start and goal with rewiring and dynamic neighbor radius, incorporating path shortcutting after connection to reduce path length and improve smoothness while ensuring collision-free nodes and edges throughout. It balances exploration and optimization, seeks lowest cost connections, and maintains efficient updates for paths and parents.",
            "planning_mechanism": "The planner samples collision-free points within the map bounds, extends the nearest node of one tree towards the sample, rewires neighbors for lower-cost paths, and attempts to connect the other tree to the newly added node with rewiring as well. Upon connection, a path is extracted and post-processed with shortcutting to smooth and shorten it. The rewiring radius adapts with the tree size to balance exploration and optimization. This enables efficient bidirectional growth with asymptotic optimality and improved path quality.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=50.0, max_rewire_radius=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_rewire_radius = max_rewire_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        final_path = []\n\n        for iter in range(self.max_iter):\n            sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate trees for growth each iteration\n            if iter % 2 == 0:\n                new_node = self._extend_tree(tree_start, tree_goal, sample, obstacles, is_3d, nodes, edges, bounds)\n                if new_node:\n                    conn_node = self._connect_tree(tree_goal, new_node, obstacles, is_3d, nodes, edges, bounds)\n                    if conn_node:\n                        success = True\n                        path_start = new_node.path_from_root()\n                        path_goal = conn_node.path_from_root()\n                        if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                            path_goal = path_goal[:-1]\n                        merged_path = path_start + path_goal[::-1]\n                        final_path = self._shortcut_path(merged_path, obstacles, is_3d, bounds)\n                        break\n            else:\n                new_node = self._extend_tree(tree_goal, tree_start, sample, obstacles, is_3d, nodes, edges, bounds)\n                if new_node:\n                    conn_node = self._connect_tree(tree_start, new_node, obstacles, is_3d, nodes, edges, bounds)\n                    if conn_node:\n                        success = True\n                        path_goal = new_node.path_from_root()\n                        path_start = conn_node.path_from_root()\n                        if path_goal and path_start and path_goal[-1] == path_start[-1]:\n                            path_start = path_start[:-1]\n                        merged_path = path_goal + path_start[::-1]\n                        final_path = self._shortcut_path(merged_path, obstacles, is_3d, bounds)\n                        break\n\n        return PlannerResult(success, final_path, nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near(self, tree, point, bounds):\n        n = len(tree)\n        d = len(point)\n        if n == 0:\n            return []\n        r_ddl = self.gamma * ((math.log(n) / n) ** (1.0 / d)) if n > 1 else self.step_size * 2\n        radius = max(self.step_size * 2, min(self.max_rewire_radius, r_ddl))\n        near_nodes = [node for node in tree if self._dist(node.position, point) <= radius]\n        return near_nodes\n\n    def _extend_tree(self, tree_to_extend, other_tree, sample, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree_to_extend, sample)\n        new_pos = self._steer(nearest.position, sample)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        near_nodes = self._near(tree_to_extend, new_pos, bounds)\n\n        # Choose best parent among neighbors (including nearest) with minimal cost\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in near_nodes:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost_through_nb = nb.cost + self._dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree_to_extend.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new node if cheaper and collision-free edge\n        for nb in near_nodes:\n            if nb == best_parent:\n                continue\n            if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                cost_through_new = new_node.cost + self._dist(new_node.position, nb.position)\n                if cost_through_new + 1e-12 < nb.cost:\n                    # Reassign parent\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = cost_through_new\n                    edges.append((new_node, nb))\n\n        return new_node\n\n    def _connect_tree(self, tree_to_connect, target_node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree_to_connect, target_node.position)\n\n        new_pos = target_node.position\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        near_nodes = self._near(tree_to_connect, new_pos, bounds)\n\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in near_nodes:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost_through_nb = nb.cost + self._dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree_to_connect.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for nb in near_nodes:\n            if nb == best_parent:\n                continue\n            if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                cost_through_new = new_node.cost + self._dist(new_node.position, nb.position)\n                if cost_through_new + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = cost_through_new\n                    edges.append((new_node, nb))\n\n        return new_node\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path[:]\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened\n\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -16.5554,
            "time_improvement": -1.0,
            "length_improvement": 16.0,
            "smoothness_improvement": 1439.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.050579285621643065,
                    "num_nodes_avg": 106.8,
                    "path_length_avg": 164.2712937810431,
                    "smoothness_avg": 0.04226815816929853,
                    "success_improvement": 0.0,
                    "time_improvement": -108.27003598058127,
                    "length_improvement": 9.960300833383796,
                    "smoothness_improvement": 561.5884621240848,
                    "objective_score": -23.69688798352368
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.049871516227722165,
                    "num_nodes_avg": 224.9,
                    "path_length_avg": 237.86532514731707,
                    "smoothness_avg": 0.10161854011327172,
                    "success_improvement": 0.0,
                    "time_improvement": 69.11316081994654,
                    "length_improvement": 20.593707892059786,
                    "smoothness_improvement": 2514.7182299904466,
                    "objective_score": 45.66376413117207
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03152651786804199,
                    "num_nodes_avg": 152.6,
                    "path_length_avg": 123.96994519489405,
                    "smoothness_avg": 0.10533489541470797,
                    "success_improvement": 0.0,
                    "time_improvement": 36.33672757035219,
                    "length_improvement": 17.66506521597572,
                    "smoothness_improvement": 1239.8520946618717,
                    "objective_score": 27.699317874000446
                }
            ],
            "success_rate": 1.0
        },
        "objective": 26.6,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient nearest neighbor and rewiring operations due to linear scans and fixed radius heuristics leading to excessive computational overhead.\n   - Incremental connection strategies that add many intermediate nodes without path shortening or smoothing, increasing path length and complexity.\n   - Limited or no effective path optimization post connection, causing suboptimal and jagged trajectories."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Incorporation of adaptive rewiring radius based on tree size and dimensionality enhancing efficient local neighbor consideration.\n   - Balanced bidirectional tree growth with rewiring on both tree extension and connection steps improving path quality and reducing excessive node insertions.\n   - Integration of shortcutting post-processing to further optimize and smooth the final path.\n2. Expected mechanism of impact:\n   - Adaptive neighbor selection reduces unnecessary collision checks and data structure manipulations, lowering planning time.\n   - Rewiring in both trees fosters continuous path cost improvements, yielding shorter and more uniform paths.\n   - Shortcutting removes unnecessary waypoints and abrupt turns, significantly improving smoothness while maintaining collision-free guarantees."
        }
    },
    {
        "parents": [
            {
                "operator": "m1",
                "algorithm_description": "A bidirectional RRT* inspired planner that grows two trees from start and goal with rewiring and dynamic neighbor radius, incorporating path shortcutting after connection to reduce path length and improve smoothness while ensuring collision-free nodes and edges throughout. It balances exploration and optimization, seeks lowest cost connections, and maintains efficient updates for paths and parents.",
                "planning_mechanism": "The planner samples collision-free points within the map bounds, extends the nearest node of one tree towards the sample, rewires neighbors for lower-cost paths, and attempts to connect the other tree to the newly added node with rewiring as well. Upon connection, a path is extracted and post-processed with shortcutting to smooth and shorten it. The rewiring radius adapts with the tree size to balance exploration and optimization. This enables efficient bidirectional growth with asymptotic optimality and improved path quality.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=50.0, max_rewire_radius=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_rewire_radius = max_rewire_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        final_path = []\n\n        for iter in range(self.max_iter):\n            sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate trees for growth each iteration\n            if iter % 2 == 0:\n                new_node = self._extend_tree(tree_start, tree_goal, sample, obstacles, is_3d, nodes, edges, bounds)\n                if new_node:\n                    conn_node = self._connect_tree(tree_goal, new_node, obstacles, is_3d, nodes, edges, bounds)\n                    if conn_node:\n                        success = True\n                        path_start = new_node.path_from_root()\n                        path_goal = conn_node.path_from_root()\n                        if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                            path_goal = path_goal[:-1]\n                        merged_path = path_start + path_goal[::-1]\n                        final_path = self._shortcut_path(merged_path, obstacles, is_3d, bounds)\n                        break\n            else:\n                new_node = self._extend_tree(tree_goal, tree_start, sample, obstacles, is_3d, nodes, edges, bounds)\n                if new_node:\n                    conn_node = self._connect_tree(tree_start, new_node, obstacles, is_3d, nodes, edges, bounds)\n                    if conn_node:\n                        success = True\n                        path_goal = new_node.path_from_root()\n                        path_start = conn_node.path_from_root()\n                        if path_goal and path_start and path_goal[-1] == path_start[-1]:\n                            path_start = path_start[:-1]\n                        merged_path = path_goal + path_start[::-1]\n                        final_path = self._shortcut_path(merged_path, obstacles, is_3d, bounds)\n                        break\n\n        return PlannerResult(success, final_path, nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near(self, tree, point, bounds):\n        n = len(tree)\n        d = len(point)\n        if n == 0:\n            return []\n        r_ddl = self.gamma * ((math.log(n) / n) ** (1.0 / d)) if n > 1 else self.step_size * 2\n        radius = max(self.step_size * 2, min(self.max_rewire_radius, r_ddl))\n        near_nodes = [node for node in tree if self._dist(node.position, point) <= radius]\n        return near_nodes\n\n    def _extend_tree(self, tree_to_extend, other_tree, sample, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree_to_extend, sample)\n        new_pos = self._steer(nearest.position, sample)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        near_nodes = self._near(tree_to_extend, new_pos, bounds)\n\n        # Choose best parent among neighbors (including nearest) with minimal cost\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in near_nodes:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost_through_nb = nb.cost + self._dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree_to_extend.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new node if cheaper and collision-free edge\n        for nb in near_nodes:\n            if nb == best_parent:\n                continue\n            if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                cost_through_new = new_node.cost + self._dist(new_node.position, nb.position)\n                if cost_through_new + 1e-12 < nb.cost:\n                    # Reassign parent\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = cost_through_new\n                    edges.append((new_node, nb))\n\n        return new_node\n\n    def _connect_tree(self, tree_to_connect, target_node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree_to_connect, target_node.position)\n\n        new_pos = target_node.position\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        near_nodes = self._near(tree_to_connect, new_pos, bounds)\n\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in near_nodes:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost_through_nb = nb.cost + self._dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree_to_connect.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for nb in near_nodes:\n            if nb == best_parent:\n                continue\n            if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                cost_through_new = new_node.cost + self._dist(new_node.position, nb.position)\n                if cost_through_new + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = cost_through_new\n                    edges.append((new_node, nb))\n\n        return new_node\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path[:]\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened\n\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
                "objective": -16.5554,
                "time_improvement": -1.0,
                "length_improvement": 16.0,
                "smoothness_improvement": 1439.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.050579285621643065,
                        "num_nodes_avg": 106.8,
                        "path_length_avg": 164.2712937810431,
                        "smoothness_avg": 0.04226815816929853,
                        "success_improvement": 0.0,
                        "time_improvement": -108.27003598058127,
                        "length_improvement": 9.960300833383796,
                        "smoothness_improvement": 561.5884621240848,
                        "objective_score": -23.69688798352368
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.049871516227722165,
                        "num_nodes_avg": 224.9,
                        "path_length_avg": 237.86532514731707,
                        "smoothness_avg": 0.10161854011327172,
                        "success_improvement": 0.0,
                        "time_improvement": 69.11316081994654,
                        "length_improvement": 20.593707892059786,
                        "smoothness_improvement": 2514.7182299904466,
                        "objective_score": 45.66376413117207
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.03152651786804199,
                        "num_nodes_avg": 152.6,
                        "path_length_avg": 123.96994519489405,
                        "smoothness_avg": 0.10533489541470797,
                        "success_improvement": 0.0,
                        "time_improvement": 36.33672757035219,
                        "length_improvement": 17.66506521597572,
                        "smoothness_improvement": 1239.8520946618717,
                        "objective_score": 27.699317874000446
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "e2",
                "algorithm_description": "A bidirectional variant of RRT* with informed sampling and efficient rewiring that grows two trees simultaneously, restricts sampling to an ellipsoidal informed subset after first solution, and performs local rewiring to improve path cost and smoothness with early termination on convergence.",
                "planning_mechanism": "The planner grows start and goal trees bidirectionally with RRT* rewiring, initially samples uniformly to quickly find a path, then constrains samples to an ellipsoidal informed set defined by the current best path cost. After each extension, it attempts to connect the two trees if close enough, while performing localized rewiring to continuously improve path quality. Early stopping criteria limit iterations after no improvements to reduce planning time.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, radius=15.0,\n                 post_opt_iters=500, max_no_improve=100, improve_tol=1e-5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n\n        c_min = math.dist(start, goal)\n        found_solution = False\n\n        no_improve_count = 0\n        post_opt_count = 0\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            return tuple(frm[i] + (to[i]-frm[i]) * self.step_size / d for i in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            distance = dist(f, t)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                inter = tuple(f[j] + (t[j]-f[j])*(i/steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def nearest(tree, p):\n            best = tree[0]\n            best_d = dist(best.position, p)\n            for n in tree:\n                d2 = dist(n.position, p)\n                if d2 < best_d:\n                    best = n\n                    best_d = d2\n            return best\n\n        def near_nodes(tree, p, radius):\n            result = []\n            r2 = radius**2\n            for n in tree:\n                d2 = sum((n.position[i]-p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def extract_path(n_start, n_goal):\n            path_start, node = [], n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def ellipsoid_sample(c_best):\n            # Sample inside prolate hyperspheroid defined by start, goal, c_best\n            import random\n            import math\n\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i]+goal[i])/2 for i in range(dim))\n            a1 = [goal[i]-start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-12:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            # Compute rotation matrix via Gram-Schmidt or approximate as identity except along a1 axis\n            # For simplicity, rotate only along principal axis for 2D or 3D (orthonormal basis)\n            # Since imports are restricted, implement a simple orthonormal basis:\n\n            # Construct orthonormal basis U with unit_a1 as first vector\n            U = [unit_a1]\n            for i in range(dim-1):\n                base = [0]*dim\n                base[(i+1)%dim] = 1  # simple perpendicular approx\n                # Gram-Schmidt orthogonalize base vs U\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j]-proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-12:\n                    U.append([x/norm_base for x in base])\n                else:\n                    # fallback: constructs zero vector, skip\n                    U.append([0]*dim)\n\n            # L matrix diagonal\n            r1 = c_best / 2\n            if c_best*c_best - c_min*c_min < 0:\n                r2 = 0\n            else:\n                r2 = math.sqrt(c_best*c_best - c_min*c_min) / 2\n            radii = [r1] + [r2] * (dim - 1)\n\n            # Sample unit ball in dim\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-12:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n\n                # Scale by radii\n                point_scaled = [radii[i]*point_ball[i] for i in range(dim)]\n\n                # Rotate via U matrix: point = sum(point_scaled[i] * U[i]) over basis vectors\n                point_rotated = [0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i]*U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        for iter_count in range(self.max_iter):\n            if found_solution:\n                sample_pt = ellipsoid_sample(best_cost)\n            else:\n                sample_pt = ellipsoid_sample(float('inf'))\n\n            # Alternate growing start and goal trees\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n\n                if in_obstacle(new_pos) or edge_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                near = near_nodes(tree_a, new_pos, self.radius)\n\n                # Choose best parent in near nodes with minimal cost + dist and collision free edge\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for candidate in near:\n                    cand_cost = candidate.cost + dist(candidate.position, new_pos)\n                    if cand_cost + self.improve_tol < min_cost and not edge_obstacle(candidate.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = candidate\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire near nodes if new_node offers lower cost connection\n                for near_node in near:\n                    if near_node == best_parent:\n                        continue\n                    alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if alt_cost + self.improve_tol < near_node.cost and not edge_obstacle(new_node.position, near_node.position):\n                        # Remove old edge\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                        if near_node.parent and near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n                # Try connect trees if nodes close enough\n                connect_node = nearest(tree_b, new_node.position)\n                if dist(new_node.position, connect_node.position) <= self.step_size and not edge_obstacle(new_node.position, connect_node.position):\n                    path = extract_path(new_node, connect_node)\n                    path_cost = new_node.cost + dist(new_node.position, connect_node.position) + connect_node.cost\n                    if path_cost + self.improve_tol < best_cost:\n                        best_cost = path_cost\n                        # Stitch trees at connection nodes: assign parents carefully\n                        # For bidirectional path extraction, keep nodes and edges unchanged,\n                        # just store nodes for path extraction\n                        best_path = path\n                        found_solution = True\n                        best_goal_node = connect_node\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n\n                    if found_solution and no_improve_count >= self.max_no_improve:\n                        post_opt_count += 1\n                        if post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_opt_count += 1\n                        if no_improve_count >= self.max_no_improve or post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
                "objective": 52.64884,
                "time_improvement": -220.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 323.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.06786198616027832,
                        "num_nodes_avg": 317.3,
                        "path_length_avg": 155.50621247453464,
                        "smoothness_avg": 0.02411673119934513,
                        "success_improvement": 0.0,
                        "time_improvement": -179.4349134355319,
                        "length_improvement": 14.764580789082476,
                        "smoothness_improvement": 277.4792135897667,
                        "objective_score": -43.58432948926125
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.14667820930480957,
                        "num_nodes_avg": 670.6,
                        "path_length_avg": 226.29277909188164,
                        "smoothness_avg": 0.017873034085429756,
                        "success_improvement": 0.0,
                        "time_improvement": 9.158040406689327,
                        "length_improvement": 24.45695686263326,
                        "smoothness_improvement": 359.8860404442116,
                        "objective_score": 19.22101644180781
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.2925038576126099,
                        "num_nodes_avg": 613.1,
                        "path_length_avg": 120.56565817380633,
                        "smoothness_avg": 0.03399415459254427,
                        "success_improvement": 0.0,
                        "time_improvement": -490.6695072338173,
                        "length_improvement": 19.926030560654297,
                        "smoothness_improvement": 332.4031372296796,
                        "objective_score": -133.58321814760419
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "An improved bidirectional RRT* algorithm employing a spatial hashing grid for efficient nearest neighbor and near node queries, adaptive rewiring radius based on tree size and problem dimension, and incremental rewiring in both trees during node addition and connection. The planner alternates growth between start and goal trees, prunes redundant nodes during rewiring to limit tree size, and uses an efficient line-of-sight shortcutting post-processing for path smoothing and length reduction. Early termination occurs upon finding a valid path. This approach minimizes collision checks, accelerates neighbor searches, and improves path quality and smoothness while significantly reducing planning time.",
            "planning_mechanism": "The algorithm grows two trees from start and goal positions, using spatial hashing to quickly find nearest neighbors and local neighborhoods for rewiring. Each iteration it samples a free point, extends the current tree toward it, rewires locally to optimize costs, and attempts connection to the other tree. Upon connection, the path is extracted and shortcutting is applied to smooth and shorten it. Adaptive rewiring radius scales with node count and problem dimension, balancing exploration and optimization efficiently. Early exit triggers at the first feasible path to reduce planning time.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma=40.0, max_rewire_radius=40.0, grid_cell_size=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_rewire_radius = max_rewire_radius\n        self.grid_cell_size = grid_cell_size  # for spatial hashing\n\n    def plan(self, map):\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Spatial hash grids for each tree: dict mapping cell -> list of nodes\n        def grid_hash(pos):\n            return tuple(int(pos[d] // self.grid_cell_size) for d in range(dim))\n        grid_start = {}\n        grid_goal = {}\n\n        def insert_grid(grid, node):\n            key = grid_hash(node.position)\n            if key not in grid:\n                grid[key] = []\n            grid[key].append(node)\n\n        insert_grid(grid_start, start_root)\n        insert_grid(grid_goal, goal_root)\n\n        def remove_grid(grid, node):\n            key = grid_hash(node.position)\n            if key in grid:\n                try:\n                    grid[key].remove(node)\n                    if not grid[key]:\n                        del grid[key]\n                except ValueError:\n                    pass\n\n        def neighbors_grid(grid, point, radius):\n            # Return nodes in grid cells intersecting radius ball around point\n            radius_cells = int(math.ceil(radius / self.grid_cell_size))\n            center_cell = grid_hash(point)\n            results = []\n            rsq = radius*radius\n            for dx in range(-radius_cells, radius_cells+1):\n                for dy in range(-radius_cells, radius_cells+1):\n                    if dim == 2:\n                        cell = (center_cell[0] + dx, center_cell[1] + dy)\n                        if cell in grid:\n                            for n in grid[cell]:\n                                d2 = sum((n.position[i]-point[i])**2 for i in range(dim))\n                                if d2 <= rsq:\n                                    results.append(n)\n                    else:\n                        for dz in range(-radius_cells, radius_cells+1):\n                            cell = (center_cell[0] + dx, center_cell[1] + dy, center_cell[2] + dz)\n                            if cell in grid:\n                                for n in grid[cell]:\n                                    d2 = sum((n.position[i]-point[i])**2 for i in range(dim))\n                                    if d2 <= rsq:\n                                        results.append(n)\n            return results\n\n        def dist(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                s += d * d\n            return math.sqrt(s)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            return tuple(frm[i] + (to[i] - frm[i]) * self.step_size / d for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            distance = dist(f, t)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[j] + (t[j] - f[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(inter):\n                    return True\n            return False\n\n        def nearest(grid, point):\n            # Search neighbor cells expanding until at least one node found\n            radius = self.grid_cell_size\n            while True:\n                candidates = neighbors_grid(grid, point, radius)\n                if candidates:\n                    best = candidates[0]\n                    best_d = dist(best.position, point)\n                    for n in candidates[1:]:\n                        d2 = dist(n.position, point)\n                        if d2 < best_d:\n                            best = n\n                            best_d = d2\n                    return best\n                radius += self.grid_cell_size\n                if radius > max(bounds) * 2:\n                    # fallback linear search on all nodes\n                    all_nodes = []\n                    for cell_nodes in grid.values():\n                        all_nodes.extend(cell_nodes)\n                    if not all_nodes:\n                        return None\n                    best = all_nodes[0]\n                    best_d = dist(best.position, point)\n                    for n in all_nodes[1:]:\n                        d2 = dist(n.position, point)\n                        if d2 < best_d:\n                            best = n\n                            best_d = d2\n                    return best\n\n        def near_nodes(tree_grid, point, n_size):\n            # Adaptive radius per RRT*: r = min(max_rewire_radius, gamma*(log(n)/n)^{1/d})\n            if n_size <= 1:\n                radius = self.step_size * 3.0\n            else:\n                radius = self.gamma * ((math.log(n_size) / n_size) ** (1.0 / dim))\n                radius = max(radius, self.step_size * 2.0)\n                radius = min(radius, self.max_rewire_radius)\n            return neighbors_grid(tree_grid, point, radius)\n\n        def add_node(tree, tree_grid, nodes_all, edges_all, new_pos, parent_node):\n            cost_new = parent_node.cost + dist(parent_node.position, new_pos)\n            new_node = Node(new_pos, parent=parent_node, cost=cost_new)\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_all.append((parent_node, new_node))\n            insert_grid(tree_grid, new_node)\n            return new_node\n\n        def rewire(tree, tree_grid, edges_all, nodes_all, new_node, near_nodes_list):\n            # For efficiency, rewire only nodes in near_nodes_list\n            for n in near_nodes_list:\n                if n == new_node.parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, n.position)\n                if alt_cost + 1e-12 < n.cost and not edge_obstacle(new_node.position, n.position):\n                    # Remove old edge\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        try:\n                            edges_all.remove((n.parent, n))\n                        except Exception:\n                            pass\n                    new_node.add_child(n)\n                    n.cost = alt_cost\n                    edges_all.append((new_node, n))\n                    # Propagate cost updates downstream via BFS\n                    q = [n]\n                    while q:\n                        curr = q.pop(0)\n                        for c in curr.children:\n                            old_cost = c.cost\n                            c.cost = curr.cost + dist(curr.position, c.position)\n                            if c.cost + 1e-12 < old_cost:\n                                q.append(c)\n\n        def prune_subtree(node, tree, tree_grid, edges_all, nodes_all):\n            # Remove node and all descendants to limit tree size and discard hopeless branches\n            stack = [node]\n            to_remove = []\n            while stack:\n                n = stack.pop()\n                to_remove.append(n)\n                stack.extend(n.children)\n            for n in to_remove:\n                if n.parent:\n                    n.parent.remove_child(n)\n                    try:\n                        edges_all.remove((n.parent, n))\n                    except Exception:\n                        pass\n                if n in tree:\n                    tree.remove(n)\n                if n in nodes_all:\n                    nodes_all.remove(n)\n                remove_grid(tree_grid, n)\n\n        def extract_path(n_start, n_goal):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            # Remove duplicate join node position once\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                # Find furthest node connectable in straight line\n                j = len(path) - 1\n                while j > i + 1:\n                    if not edge_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        success = False\n        final_path = []\n\n        # Alternate growing tree: 0 for start_tree, 1 for goal_tree\n        grow_turn = 0\n\n        for _ in range(self.max_iter):\n            # Sample free point uniformly inside bounds\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    break\n\n            if grow_turn == 0:\n                tree_a, grid_a, tree_b, grid_b = tree_start, grid_start, tree_goal, grid_goal\n            else:\n                tree_a, grid_a, tree_b, grid_b = tree_goal, grid_goal, tree_start, grid_start\n\n            # Extend tree_a towards sample\n            nearest_node = nearest(grid_a, sample)\n            if nearest_node is None:\n                grow_turn = 1 - grow_turn\n                continue\n            new_pos = steer(nearest_node.position, sample)\n            if is_in_obstacle(new_pos) or edge_obstacle(nearest_node.position, new_pos):\n                grow_turn = 1 - grow_turn\n                continue\n\n            near = near_nodes(grid_a, new_pos, len(tree_a))\n            # Choose best parent among near nodes who can connect\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in near:\n                if nb == nearest_node:\n                    continue\n                if not edge_obstacle(nb.position, new_pos):\n                    cost_through_nb = nb.cost + dist(nb.position, new_pos)\n                    if cost_through_nb < min_cost:\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n            new_node = add_node(tree_a, grid_a, nodes, edges, new_pos, best_parent)\n\n            # Rewire near nodes to new node\n            rewire(tree_a, grid_a, edges, nodes, new_node, near)\n\n            # Try connect new_node to other tree\n            near_other = near_nodes(grid_b, new_node.position, len(tree_b))\n            # Find closest node in other tree connectable by edge\n            min_connect_cost = float('inf')\n            connect_node = None\n            for on in near_other:\n                if dist(on.position, new_node.position) <= self.step_size and not edge_obstacle(on.position, new_node.position):\n                    cost_connect = new_node.cost + dist(new_node.position, on.position) + on.cost\n                    if cost_connect < min_connect_cost:\n                        min_connect_cost = cost_connect\n                        connect_node = on\n            if connect_node:\n                # Extract path\n                final_path = extract_path(new_node, connect_node)\n                final_path = shortcut_path(final_path)\n                success = True\n                break\n\n            grow_turn = 1 - grow_turn  # alternate tree\n\n        return PlannerResult(success, final_path, nodes, edges)",
            "objective": -11.69807,
            "time_improvement": -21.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 1526.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.028065919876098633,
                    "num_nodes_avg": 86.4,
                    "path_length_avg": 163.49572132394655,
                    "smoothness_avg": 0.047919740128782015,
                    "success_improvement": 0.0,
                    "time_improvement": -15.566878230521153,
                    "length_improvement": 10.385404386850459,
                    "smoothness_improvement": 650.0479923966562,
                    "objective_score": 4.811419124937211
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.046169471740722653,
                    "num_nodes_avg": 233.7,
                    "path_length_avg": 234.08993011810594,
                    "smoothness_avg": 0.10042545256115583,
                    "success_improvement": 0.0,
                    "time_improvement": 71.40594157650585,
                    "length_improvement": 21.854043421531074,
                    "smoothness_improvement": 2484.019227928276,
                    "objective_score": 46.95430466551178
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.10878512859344483,
                    "num_nodes_avg": 414.2,
                    "path_length_avg": 120.41487182477995,
                    "smoothness_avg": 0.12131448482536566,
                    "success_improvement": 0.0,
                    "time_improvement": -119.67593461881035,
                    "length_improvement": 20.026175674003266,
                    "smoothness_improvement": 1443.1112924748393,
                    "objective_score": -16.67151851886695
                }
            ],
            "success_rate": 1.0
        },
        "objective": -4.6,
        "analysis": {
            "problem": [
                ""
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Incorporation of spatial hashing grids enabling efficient nearest neighbor and near node queries, reducing computational overhead.\n   - Adaptive rewiring radius based on tree size and problem dimensionality for balanced exploration and local optimization.\n   - Incremental rewiring with cost propagation downstream, improving path quality and pruning suboptimal branches to limit tree growth.\n   - Early termination upon first feasible path with shortcutting post-processing to improve path smoothness and length.\n2. Expected mechanism of impact:\n   - Efficient neighbor lookup reduces collision checks and expensive operations, significantly decreasing run time.\n   - Adaptive radius and cost-propagating rewiring encourage optimal parent selection, reducing path length and smoothing the trajectory.\n   - Pruning limits growth of redundant nodes, focusing computational resources and improving convergence speed.\n   - Post-planning shortcutting and structured path extraction enhance path smoothness, reducing curvature and unnecessary detours."
        }
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "An enhanced bidirectional RRT* planner employing a KD-tree for efficient nearest-neighbor queries, adaptive radius rewiring with cost and smoothness heuristics, dynamic ellipsoidal informed sampling, and multistage smoothing via progressive shortcutting and cubic Bezier interpolation. The planner alternates expanding two trees, connects them with rewiring, and applies advanced smoothing to produce shorter, smoother paths with reduced planning time.",
                "planning_mechanism": "The planner grows two trees bidirectionally, using efficient spatial indexing (KD-tree) for neighbor searches within an adaptive radius that considers current best cost and path smoothness. Sampling is biased by progressively shrinking ellipsoids around the best path cost to reduce unnecessary exploration. New nodes are rewired optimally based on combined cost and curvature heuristic. Upon connection, the combined path is post-processed by iterative shortcutting and spline interpolation using cubic Bezier curves to smooth sharp turns and reduce path length. This approach balances exploration and exploitation, accelerates convergence, and yields high-quality paths faster.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # tuple of floats\n        self.parent = parent      # Node or None\n        self.cost = cost          # accumulated cost (float)\n        self.children = []       # list of Node\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 n_near_const=30,\n                 max_no_improve=60,\n                 improve_tol=1e-7,\n                 shortcut_iters=250):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        # Minimal imports here\n        import math\n        import random\n        import time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        dist = lambda a, b: math.dist(a, b)\n\n        # -- Collision checks --\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[j] + (t[j] - f[j]) * i / steps for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        # -- Steering with fixed step size --\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        # -- KD-tree implementation for fast neighbor search --\n        # Simple recursive KD-tree node\n        class KDNode:\n            __slots__ = ['point', 'node_ref', 'left', 'right', 'axis']\n\n            def __init__(self, point, node_ref, axis):\n                self.point = point  # tuple\n                self.node_ref = node_ref  # Node instance\n                self.left = None\n                self.right = None\n                self.axis = axis\n\n        def build_kdtree(points_nodes, depth=0):\n            if not points_nodes:\n                return None\n            axis = depth % dim\n            points_nodes.sort(key=lambda pn: pn[0][axis])\n            median = len(points_nodes) // 2\n            root = KDNode(points_nodes[median][0], points_nodes[median][1], axis)\n            root.left = build_kdtree(points_nodes[:median], depth + 1)\n            root.right = build_kdtree(points_nodes[median+1:], depth + 1)\n            return root\n\n        def kd_nearest(root, point, best=None, best_dist=float('inf')):\n            if root is None:\n                return best, best_dist\n            axis = root.axis\n            here_dist = 0\n            for i in range(dim):\n                diff = point[i] - root.point[i]\n                here_dist += diff * diff\n            here_dist_sqrt = math.sqrt(here_dist)\n            better = False\n            if here_dist_sqrt < best_dist:\n                best = root.node_ref\n                best_dist = here_dist_sqrt\n                better = True\n\n            diff_axis = point[axis] - root.point[axis]\n\n            first, second = (root.left, root.right) if diff_axis < 0 else (root.right, root.left)\n            best, best_dist = kd_nearest(first, point, best, best_dist)\n            if abs(diff_axis) < best_dist:\n                best, best_dist = kd_nearest(second, point, best, best_dist)\n            return best, best_dist\n\n        def kd_radius_search(root, point, radius, found=None):\n            if found is None:\n                found = []\n            if root is None:\n                return found\n            axis = root.axis\n            dist_sq = sum((point[i] - root.point[i]) ** 2 for i in range(dim))\n            if dist_sq <= radius * radius:\n                found.append(root.node_ref)\n            diff_axis = point[axis] - root.point[axis]\n            if diff_axis < 0:\n                kd_radius_search(root.left, point, radius, found)\n                if abs(diff_axis) <= radius:\n                    kd_radius_search(root.right, point, radius, found)\n            else:\n                kd_radius_search(root.right, point, radius, found)\n                if abs(diff_axis) <= radius:\n                    kd_radius_search(root.left, point, radius, found)\n            return found\n\n        # -- Adaptive radius shrinks as better solution found --\n        def adaptive_radius(n_nodes, c_best):\n            gamma = self.n_near_const\n            if n_nodes == 0:\n                return self.step_size * 2.8\n            r = min((gamma * (math.log(n_nodes + 1) / n_nodes)) ** (1 / dim), self.step_size * 6.0)\n            if c_best == float('inf'):\n                return r\n            shrink = max(0.25, c_best / (c_min * 2.7))\n            return max(self.step_size * 0.8, r * shrink)\n\n        # -- Ellipsoidal informed sampling --\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Orthonormal basis, Gram-Schmidt\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0]*dim\n                base[(idx + 1) % dim] = 1\n                for u in U:\n                    proj = sum(base[j] * u[j] for j in range(dim))\n                    base = [base[j] - proj * u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0]*dim)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n                point_scaled = [radii[i] * point_ball[i] for i in range(dim)]\n\n                # Rotate via basis\n                point_rotated = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i] * U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not in_obstacle(sample):\n                        return sample\n\n        # -- Path extraction and connection --\n        def extract_path(node):\n            return node.path_from_root()\n\n        def connect_path(n_start, n_goal):\n            start_path = extract_path(n_start)\n            goal_path_rev = extract_path(n_goal)\n            goal_path = goal_path_rev[::-1]\n            if len(start_path) > 0 and len(goal_path) > 0 and start_path[-1] == goal_path[0]:\n                return start_path + goal_path[1:]\n            else:\n                return start_path + goal_path\n\n        # -- Smoothness metric: sum angle cosines between segments weighted by lengths --\n        def curvature_cost(path):\n            if len(path) < 3:\n                return 0.0\n            cost = 0.0\n            for i in range(1, len(path) - 1):\n                p1, p2, p3 = path[i - 1], path[i], path[i + 1]\n                v1 = tuple(p2[d] - p1[d] for d in range(dim))\n                v2 = tuple(p3[d] - p2[d] for d in range(dim))\n                len1 = math.sqrt(sum(x * x for x in v1))\n                len2 = math.sqrt(sum(x * x for x in v2))\n                if len1 < 1e-14 or len2 < 1e-14:\n                    continue\n                dot = sum(v1[d] * v2[d] for d in range(dim)) / (len1 * len2)\n                dot = max(-1.0, min(1.0, dot))  # clamp\n                angle = math.acos(dot)\n                cost += angle\n            return cost\n\n        # -- Add node with cost and smoothness rewiring --\n        # Will use kd-tree for near search\n        def add_node(tree_nodes, kd_root, new_pos, all_nodes, edges, c_best):\n            # Nearest using kd-tree\n            nn, dist_nn = kd_nearest(kd_root, new_pos)\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(all_nodes)\n            radius = adaptive_radius(n_nodes, c_best)\n            near_nodes_set = kd_radius_search(kd_root, new_pos_steered, radius)\n\n            # Find best parent balancing cost and curvature heuristic with weightings\n            best_parent = nn\n            best_parent_cost = nn.cost + dist(nn.position, new_pos_steered)\n            best_cost_and_curv = best_parent_cost  # for now cost only: cost + alpha*curv\n\n            # Include curvature heuristic: prefer parents that generate smoother turn\n            alpha_curv = 0.06  # weight to curvature cost (tune as heuristic)\n            for candidate in near_nodes_set:\n                if candidate == nn:\n                    continue\n                if edge_obstacle(candidate.position, new_pos_steered):\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, new_pos_steered)\n                # Estimate curvature cost if this candidate chosen as parent\n                # Path to candidate + new edge + (partial smoothing estimate)\n                if candidate.parent is None:\n                    curv = 0.0\n                else:\n                    p_prev = candidate.parent.position\n                    p_cand = candidate.position\n                    v1 = tuple(p_cand[d] - p_prev[d] for d in range(dim))\n                    v2 = tuple(new_pos_steered[d] - p_cand[d] for d in range(dim))\n                    len1 = math.sqrt(sum(x * x for x in v1))\n                    len2 = math.sqrt(sum(x * x for x in v2))\n                    if len1 < 1e-14 or len2 < 1e-14:\n                        curv = 0.0\n                    else:\n                        dot = sum(v1[d] * v2[d] for d in range(dim)) / (len1 * len2)\n                        dot = max(-1.0, min(1.0, dot))\n                        angle = math.acos(dot)\n                        curv = angle\n                cost_and_curv = candidate_cost + alpha_curv * curv\n                if cost_and_curv + self.improve_tol < best_cost_and_curv:\n                    best_parent = candidate\n                    best_parent_cost = candidate_cost\n                    best_cost_and_curv = cost_and_curv\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_parent_cost\n            tree_nodes.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rebuild kd-tree only when tree grows by significant amount? For simplicity rebuild always:\n            # Rewiring neighbors to new_node if beneficial based on cost + curvature:\n            near_nodes_range = kd_radius_search(kd_root, new_node.position, radius)\n            for near_node in near_nodes_range:\n                if near_node is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if near_node.parent is None:\n                    continue\n                # Curvature heuristic for rewiring:\n                p_prev = near_node.parent.position\n                p_cand = near_node.position\n                p_new = new_node.position\n                v1 = tuple(p_cand[d] - p_prev[d] for d in range(dim))\n                v2 = tuple(p_new[d] - p_cand[d] for d in range(dim))\n                len1 = math.sqrt(sum(x * x for x in v1))\n                len2 = math.sqrt(sum(x * x for x in v2))\n                if len1 < 1e-14 or len2 < 1e-14:\n                    curv = 0.0\n                else:\n                    dot = sum(v1[d] * v2[d] for d in range(dim)) / (len1 * len2)\n                    dot = max(-1.0, min(1.0, dot))\n                    angle = math.acos(dot)\n                    curv = angle\n                alt_cost_and_curv = alt_cost + alpha_curv * curv\n                curr_cost_and_curv = near_node.cost + alpha_curv * 0.0  # assume old edge curvature zero or ignore\n\n                if alt_cost_and_curv + self.improve_tol < curr_cost_and_curv and not edge_obstacle(new_node.position, near_node.position):\n                    # Rewire\n                    if near_node.parent:\n                        near_node.parent.remove_child(near_node)\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                    new_node.add_child(near_node)\n                    near_node.cost = alt_cost\n                    edges.append((new_node, near_node))\n\n            return new_node\n\n        # -- Path shortcutting with accelerated attempts and full checks --\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path = list(path)\n\n            changed = True\n            tries = 0\n            max_tries = self.shortcut_iters\n            while changed and tries < max_tries:\n                tries += 1\n                changed = False\n                i = 0\n                while i < len(path) - 2:\n                    # attempt shortcut from i to j randomly chosen farther node\n                    max_j = min(len(path)-1, i + 6 + random.randint(0, 5))\n                    j = random.randint(i + 2, max_j)\n                    if j >= len(path):\n                        break\n                    if not edge_obstacle(path[i], path[j]):\n                        # Remove intermediate nodes\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # -- Cubic Bezier curve interpolation smoothing for path --\n        def bezier_interpolate(path, steps_per_segment=6):\n            if len(path) < 3:\n                return path[:]\n            result = [path[0]]\n            n = len(path)\n            for i in range(n -1):\n                p0 = path[i]\n                p3 = path[i+1]\n                # Control points p1 and p2 computed to smooth path via averaging neighbors with clamping inside bounds\n                def add_points(a,b):\n                    return tuple(a[d]+b[d] for d in range(dim))\n                def sub_points(a,b):\n                    return tuple(a[d]-b[d] for d in range(dim))\n                def mul_point(p, c):\n                    return tuple(c * p[d] for d in range(dim))\n                def clamp_point(p):\n                    return tuple(max(0.0, min(bounds[d], p[d])) for d in range(dim))\n\n                if i == 0:\n                    p1 = add_points(p0, mul_point(sub_points(p3, p0), 0.3))\n                else:\n                    p1 = add_points(path[i-1], mul_point(sub_points(p3, path[i-1]), 0.3))\n                if i == n - 2:\n                    p2 = add_points(p3, mul_point(sub_points(p0, p3), 0.3))\n                else:\n                    p2 = add_points(path[i+2], mul_point(sub_points(p0, path[i+2]), 0.3))\n                p1 = clamp_point(p1)\n                p2 = clamp_point(p2)\n\n                for step in range(1, steps_per_segment+1):\n                    t = step / steps_per_segment\n                    one_minus_t = 1 - t\n                    b_t = [0.0]*dim\n                    for d in range(dim):\n                        b_t[d] = (one_minus_t ** 3) * p0[d] + 3 * (one_minus_t ** 2) * t * p1[d] + 3 * one_minus_t * (t ** 2) * p2[d] + (t ** 3) * p3[d]\n                    point = tuple(b_t)\n                    # If any collision on small segments, skip interpolation and keep original points to be safe\n                    if in_obstacle(point):\n                        return path[:]  # fallback no smoothing\n                    result.append(point)\n            return result\n\n        # Initialize trees and variables\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n        start_time = time.time()\n\n        # Initial kd-trees (rebuild every iteration for simplicity)\n        def rebuild_kd(nodes):\n            pts_refs = [(n.position, n) for n in nodes]\n            return build_kdtree(pts_refs)\n\n        for iter_count in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate tree growing every iteration\n            if iter_count % 2 == 0:\n                tree_a = start_tree\n                tree_b = goal_tree\n            else:\n                tree_a = goal_tree\n                tree_b = start_tree\n\n            kd_tree_a = rebuild_kd(tree_a)\n            kd_tree_b = rebuild_kd(tree_b)\n\n            new_node = add_node(tree_a, kd_tree_a, sample_pt, nodes_all, edges, best_cost)\n            if new_node is None:\n                continue\n\n            # Attempt to connect new_node to other tree within step_size\n            nearest_b, dist_b = kd_nearest(kd_tree_b, new_node.position)\n            if dist_b <= self.step_size:\n                if not edge_obstacle(new_node.position, nearest_b.position):\n                    path_candidate = connect_path(new_node, nearest_b)\n                    candidate_cost = new_node.cost + dist(new_node.position, nearest_b.position) + nearest_b.cost\n                    # Compare smoothness + cost\n                    smooth_cand = curvature_cost(path_candidate)\n                    smooth_best = curvature_cost(best_path) if found_solution else float('inf')\n\n                    # Weighted scoring balancing path cost and smoothness\n                    alpha_smooth = 0.07\n                    if found_solution:\n                        score_cand = candidate_cost + alpha_smooth * smooth_cand\n                        score_best = best_cost + alpha_smooth * smooth_best\n                    else:\n                        score_cand = candidate_cost\n                        score_best = float('inf')\n\n                    if score_cand + self.improve_tol < score_best:\n                        best_cost = candidate_cost\n                        best_path = path_candidate\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            # Terminate early if no improvement for prolonged iterations\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            # Restart no_improve_count if improvement detected\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                last_best_cost = best_cost\n                no_improve_count = 0\n\n        # Post-process best path found with iterative shortcutting\n        if found_solution and len(best_path) > 2:\n            best_path = shortcut_path(best_path)\n\n        # Then smooth with cubic Bezier curve interpolation to improve smoothness further\n        if found_solution and len(best_path) > 4:\n            bezier_path = bezier_interpolate(best_path)\n            if len(bezier_path) >= 2:\n                best_path = bezier_path\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
                "objective": 83.70395,
                "time_improvement": -338.0,
                "length_improvement": 17.0,
                "smoothness_improvement": 1487.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.09354512691497803,
                        "num_nodes_avg": 224.2,
                        "path_length_avg": 158.39149657980934,
                        "smoothness_avg": 0.04605737694225472,
                        "success_improvement": 0.0,
                        "time_improvement": -285.1902356654444,
                        "length_improvement": 13.183110850728989,
                        "smoothness_improvement": 620.8979643411151,
                        "objective_score": -74.54271436749035
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.3257765531539917,
                        "num_nodes_avg": 400.1,
                        "path_length_avg": 243.039815263405,
                        "smoothness_avg": 0.10237027294781645,
                        "success_improvement": 0.0,
                        "time_improvement": -101.76262458020442,
                        "length_improvement": 18.86631415186982,
                        "smoothness_improvement": 2534.0608572745577,
                        "objective_score": -6.5386945965666445
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.3593874931335449,
                        "num_nodes_avg": 338.2,
                        "path_length_avg": 122.57138919671115,
                        "smoothness_avg": 0.11057672266771726,
                        "success_improvement": 0.0,
                        "time_improvement": -625.7313978960544,
                        "length_improvement": 18.59391951788871,
                        "smoothness_improvement": 1306.527750408709,
                        "objective_score": -170.03042890603956
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "time_expert",
                "algorithm_description": "An enhanced bidirectional RRT* variant that incorporates adaptive neighbor radius shrinking to concentrate rewiring efforts for local optimality, an efficient nearest-neighbor caching structure for faster lookups, and progressive informed sampling with dynamic ellipsoidal restriction. The planner prioritizes early discovery and incremental path improvement, applies a smooth path shortcutting post-processing step to reduce path length and curvature, and enforces robust termination criteria based on stagnation and solution quality thresholds to minimize planning time.",
                "planning_mechanism": "The planner grows two trees alternately with rewiring using an adaptive radius, restricts sampling progressively to a shrinking ellipsoid after finding a solution to focus on promising areas, connects the trees upon proximity, and applies a final shortcut smoothing pass to improve total path length and smoothness before returning the best feasible path found within iteration and time limits.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, n_near_const=35, \n                 max_no_improve=80, improve_tol=1e-6, shortcut_iters=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const  # base neighbor count for adaptive radius\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        # --- Local helper imports & definitions ---\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        dist = lambda a, b: math.dist(a, b)\n\n        # Node collections\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        # To reduce overhead of nearest neighbor search, cache all nodes' positions lists for faster processing\n        # We implement simple linear searches but with caching and limit radius dynamically to reduce checks\n\n        # Adaptive radius for near-node rewiring, shrinks with best_cost to focus local improvements\n        # r_n = min((gamma * (log(n)/n))^(1/d), max_radius) but approximate w/o logs for lightweight\n        def adaptive_radius(n_nodes, c_best):\n            # Use gamma ~ 30 (typical for 2D), avoid zero or undefined\n            gamma = self.n_near_const\n            if n_nodes == 0:\n                return self.step_size * 2.5\n            r = min((gamma * (math.log(n_nodes)/n_nodes))**(1/dim), self.step_size * 5)\n            # Shrink with c_best, stronger around best solution to focus rewiring\n            if c_best == float('inf'):\n                return r\n            shrink_factor = max(0.25, c_best / (c_min * 3))\n            return max(self.step_size*0.75, r * shrink_factor)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-10:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[j] + (t[j] - f[j]) * (i / steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        # Efficient nearest neighbor search (linear but with early exit)\n        def nearest(tree, p):\n            best = None\n            best_d = float('inf')\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 >= best_d*best_d:\n                        break\n                else:\n                    d = math.sqrt(d2)\n                    if d < best_d:\n                        best = n\n                        best_d = d\n            return best\n\n        # Near nodes within radius (adaptive radius)\n        def near_nodes(tree, p, radius):\n            r2 = radius*radius\n            result = []\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 > r2:\n                        break\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        # Extract path from start via parent chain\n        def extract_path(node_start_root):\n            return node_start_root.path_from_root()\n\n        # Extract full path from two connection nodes (start tree and goal tree)\n        def connect_path(n_start, n_goal):\n            path_start = extract_path(n_start)\n            path_goal_rev = extract_path(n_goal)\n            path_goal = path_goal_rev[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        # Ellipsoidal informed sampling centered between start and goal, focused progressively as c_best shrinks\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-12:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Orthonormal basis U with unit_a1 first vector\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0] * dim\n                base[(idx + 1) % dim] = 1\n                for u in U:\n                    proj = sum(base[j] * u[j] for j in range(dim))\n                    base = [base[j] - proj * u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-12:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0] * dim)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-12:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n                point_scaled = [radii[i] * point_ball[i] for i in range(dim)]\n\n                point_rotated = [0.0] * dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i] * U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        # Path shortcutting by attempting to connect non-adjacent nodes directly if collision free\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                changed = False\n                iter_count += 1\n                i = 0\n                while i < len(path) - 2:\n                    j = min(len(path) - 1, i + 2 + random.randint(0, 3))\n                    if j > i + 1 and not edge_obstacle(path[i], path[j]):\n                        # Shortcut feasible, remove intermediate nodes\n                        path = path[:i + 1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Add node to tree selecting best parent among near nodes\n        def add_node(tree, new_pos, nodes_all, edges, c_best):\n            nn = nearest(tree, new_pos)\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(nodes_all)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos_steered, radius)\n\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos_steered)\n            for near_node in near:\n                if near_node == nn:\n                    continue\n                cand_cost = near_node.cost + dist(near_node.position, new_pos_steered)\n                if cand_cost + self.improve_tol < best_cost and not edge_obstacle(near_node.position, new_pos_steered):\n                    best_parent = near_node\n                    best_cost = cand_cost\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if beneficial\n            for near_node in near:\n                if near_node is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not edge_obstacle(new_node.position, near_node.position):\n                        # Remove old parent-child relationship\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n            return new_node\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n        start_time = time.time()\n\n        for iter_count in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate tree growing: start tree first odd iters, goal second even iters\n            if iter_count % 2 == 0:\n                tree_a = start_tree\n                tree_b = goal_tree\n            else:\n                tree_a = goal_tree\n                tree_b = start_tree\n\n            new_node = add_node(tree_a, sample_pt, nodes_all, edges, best_cost)\n            if new_node is None:\n                # Could not add node (collision), continue\n                continue\n\n            # Attempt connection to other tree\n            nearest_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_b.position) <= self.step_size:\n                if not edge_obstacle(new_node.position, nearest_b.position):\n                    # Connect path candidates\n                    path_candidate = connect_path(new_node, nearest_b)\n                    candidate_cost = new_node.cost + dist(new_node.position, nearest_b.position) + nearest_b.cost\n\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = path_candidate\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            # Early termination when no meaningful improvement for long\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            # Restart no improve count if significant improvement detected\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                no_improve_count = 0\n                last_best_cost = best_cost\n\n        # Final path smoothing via shortcutting if solution found\n        if found_solution and len(best_path) > 2:\n            best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
                "objective": -12.90672,
                "time_improvement": -15.0,
                "length_improvement": 14.0,
                "smoothness_improvement": 1865.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.03639078140258789,
                        "num_nodes_avg": 237.0,
                        "path_length_avg": 168.02193260520104,
                        "smoothness_avg": 0.04984815517379989,
                        "success_improvement": 0.0,
                        "time_improvement": -49.84611306639963,
                        "length_improvement": 7.9045162611873945,
                        "smoothness_improvement": 680.2318754714814,
                        "objective_score": -6.809964785850045
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.046571874618530275,
                        "num_nodes_avg": 354.8,
                        "path_length_avg": 240.5937710240402,
                        "smoothness_avg": 0.12631217131652547,
                        "success_improvement": 0.0,
                        "time_improvement": 71.15672210389786,
                        "length_improvement": 19.68287412444948,
                        "smoothness_improvement": 3150.1031469538016,
                        "objective_score": 48.907256840608056
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.08302063941955566,
                        "num_nodes_avg": 467.5,
                        "path_length_avg": 130.26416789587537,
                        "smoothness_avg": 0.14664374877167838,
                        "success_improvement": 0.0,
                        "time_improvement": -67.64825112539418,
                        "length_improvement": 13.484742196660818,
                        "smoothness_improvement": 1765.2976602601516,
                        "objective_score": -3.377141718321006
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "A Bidirectional Informed RRT* with Adaptive Radius and Progressive Rewiring integrating a balanced ellipsoidal informed sampler, efficient linear nearest neighbor search with incremental rewiring, and robust early stopping based on solution stagnation and path cost improvement. The algorithm alternately expands start and goal trees, prioritizes smoother and shorter paths by cost-aware parent selection, adaptively adjusts rewiring radius based on the number of nodes and best cost, and applies a final multi-pass shortcut smoothing to yield efficient, low-cost, and smooth paths within bounded planning time.",
            "planning_mechanism": "The planner maintains two trees grown alternately from start and goal. Sampling is initially uniform and focuses progressively within a shrinking ellipsoid around the currently best path. The nearest parent is selected by minimal cost plus a small curvature penalty. An adaptive rewiring radius shrinks as better solutions are found, enabling local optimization. Each new node attempts rewiring neighbors within radius if it improves cost. The trees connect when nodes are near and collision free. Early termination occurs if no improvements happen in prolonged iterations. After planning, a multi-pass shortcutting cleans and smooths the path to reduce length and curvature.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=5.5, n_near_const=28,\n                 max_no_improve=70, improve_tol=1e-6, shortcut_iters=300):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a, b: math.dist(a, b)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if (ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od):\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if (ox <= px <= ox + ow and oy <= py <= oy + oh):\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps +1):\n                inter = tuple(f[d] + (t[d] - f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best = None\n            best_d = float('inf')\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 >= best_d*best_d:\n                        break\n                else:\n                    d = math.sqrt(d2)\n                    if d < best_d:\n                        best = n\n                        best_d = d\n            return best, best_d\n\n        def near_nodes(tree, p, radius):\n            r2 = radius*radius\n            res = []\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 > r2:\n                        break\n                if d2 <= r2:\n                    res.append(n)\n            return res\n\n        def adaptive_radius(n_nodes, c_best):\n            gamma = self.n_near_const\n            if n_nodes == 0:\n                return self.step_size * 3.0\n            radius = min((gamma * (math.log(n_nodes)/n_nodes))**(1/dim), self.step_size * 6.0)\n            if c_best == float('inf'):\n                return radius\n            shrink = max(0.3, c_best / (c_min * 3.1))\n            return max(self.step_size * 0.8, radius * shrink)\n\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                # Uniform sample in bounds avoiding boundary issues\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n            U = [unit_a1]\n            for idx in range(dim -1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j] - proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0.0]*dim)\n            r1 = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val > 0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n\n            max_attempt = 50\n            for _ in range(max_attempt):\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n                scaled = [radii[i]*point_ball[i] for i in range(dim)]\n                point_rot = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rot[j] += scaled[i]*U[i][j]\n                sample = tuple(center[i] + point_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not in_obstacle(sample):\n                    return sample\n            # fallback\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def extract_path(node):\n            return node.path_from_root()\n\n        def connect_path(n_start, n_goal):\n            path_s = extract_path(n_start)\n            path_g_rev = extract_path(n_goal)\n            path_g = path_g_rev[::-1]\n            if len(path_s) > 0 and len(path_g) > 0 and path_s[-1] == path_g[0]:\n                return path_s + path_g[1:]\n            else:\n                return path_s + path_g\n\n        def curvature_penalty(p_parent, p_child, p_new):\n            # Small curvature cost for smoother parent selection\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_child[i] - p_parent[i] for i in range(dim))\n            v2 = tuple(p_new[i] - p_child[i] for i in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))/(len1*len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        def add_node(tree, new_pos, nodes_all, edges, c_best):\n            nn, _ = nearest(tree, new_pos)\n            if nn is None:\n                return None\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(nodes_all)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos_steered, radius)\n\n            alpha_curv = 0.04\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos_steered)\n            best_score = best_cost + alpha_curv * curvature_penalty(nn.parent.position if nn.parent else None, nn.position, new_pos_steered)\n\n            for candidate in near:\n                if candidate == nn:\n                    continue\n                if edge_obstacle(candidate.position, new_pos_steered):\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, new_pos_steered)\n                curv_cost = alpha_curv * curvature_penalty(candidate.parent.position if candidate.parent else None, candidate.position, new_pos_steered)\n                score = candidate_cost + curv_cost\n                if score + self.improve_tol < best_score:\n                    best_parent = candidate\n                    best_cost = candidate_cost\n                    best_score = score\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node if better path found\n            near_rewire = near_nodes(tree, new_node.position, radius)\n            for near_n in near_rewire:\n                if near_n == best_parent or near_n == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost and not edge_obstacle(new_node.position, near_n.position):\n                    # Additionally check curvature penalty for rewiring\n                    curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, near_n.position)\n                    curv_old = curvature_penalty(near_n.parent.parent.position if near_n.parent and near_n.parent.parent else None, near_n.parent.position if near_n.parent else None, near_n.position)\n                    if alpha_curv * curv_new <= alpha_curv * curv_old + 0.15:  # allow slight increase for cost gain\n                        if near_n.parent:\n                            near_n.parent.remove_child(near_n)\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_n)\n                        near_n.cost = alt_cost\n                        edges.append((new_node, near_n))\n\n            return new_node\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path = list(path)\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                changed = False\n                iter_count +=1\n                i=0\n                while i < len(path)-2:\n                    max_j = min(len(path)-1, i + 7 + random.randint(0,4))\n                    j = random.randint(i+2, max_j) if max_j > i+2 else i+2\n                    if j > i+1 and not edge_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialize bidirectional trees\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate growing trees: even iterations start-tree, odd goal-tree\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            new_node = add_node(tree_a, sample_pt, nodes_all, edges, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                continue\n\n            nbr_node, nbr_dist = nearest(tree_b, new_node.position)\n            if nbr_node and nbr_dist <= self.step_size and not edge_obstacle(new_node.position, nbr_node.position):\n                candidate_path = connect_path(new_node, nbr_node)\n                candidate_cost = new_node.cost + dist(new_node.position, nbr_node.position) + nbr_node.cost\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                last_best_cost = best_cost\n                no_improve_count = 0\n\n        if found_solution and len(best_path) > 3:\n            # Multiple progressive shortcut passes to enhance path quality\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
            "objective": -23.40566,
            "time_improvement": 28.0,
            "length_improvement": 13.0,
            "smoothness_improvement": 1419.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02814173698425293,
                    "num_nodes_avg": 174.7,
                    "path_length_avg": 170.78044027086807,
                    "smoothness_avg": 0.041064375085066517,
                    "success_improvement": 0.0,
                    "time_improvement": -15.879069904428114,
                    "length_improvement": 6.3925344982841175,
                    "smoothness_improvement": 542.746642799047,
                    "objective_score": 1.7855329416372712
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04101948738098145,
                    "num_nodes_avg": 312.8,
                    "path_length_avg": 241.95417433722574,
                    "smoothness_avg": 0.08769719153831615,
                    "success_improvement": 0.0,
                    "time_improvement": 74.59547240955273,
                    "length_improvement": 19.228732341469897,
                    "smoothness_improvement": 2156.5119040147615,
                    "objective_score": 44.698440647821556
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.036681413650512695,
                    "num_nodes_avg": 276.1,
                    "path_length_avg": 130.08856674191185,
                    "smoothness_avg": 0.13041023521317593,
                    "success_improvement": 0.0,
                    "time_improvement": 25.927156303411085,
                    "length_improvement": 13.601368121895007,
                    "smoothness_improvement": 1558.8085660293298,
                    "objective_score": 23.733010594306975
                }
            ],
            "success_rate": 1.0
        },
        "objective": -0.3999999999999986,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Rebuilding spatial structures every iteration causing high computational overhead.\n   - Aggressive adaptive radius shrinking limiting neighbor searches and exploration.\n   - Overreliance on local curvature heuristics adding complexity without robust smoothing.\n   - Limited and simplistic path smoothing often reverted due to collision checks.\n   - Excessive or imprecise rewiring logic increasing runtime and sometimes rejecting beneficial connections.\n   - Sampling strategies poorly balanced early in planning reducing exploration diversity."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Efficient nearest neighbor searches with incremental updates reducing rebuild overhead.\n   - Balanced adaptive radius that stabilizes rewiring while preserving sufficient neighborhood.\n   - Incorporation of a refined curvature penalty that guides parent selection and rewiring without overcomplication.\n   - Multiple progressive shortcutting passes post-planning improving path quality effectively.\n   - Early termination criteria based on stagnation preventing unnecessary iterations.\n   - Enhanced sampling method ensuring valid samples and improved exploration-exploitation tradeoff.\n\n2. Expected mechanism of impact:\n   - Reduced computational cost per iteration and fewer total iterations lowering overall planning time.\n   - Better balance in radius parameters leads to more effective rewiring and path improvements.\n   - Smoother parent selection and rewiring foster lower curvature paths without incurring heavy cost computations.\n   - Progressive shortcutting removes excessive detours and sharp turns, enhancing both length and smoothness.\n   - Early stopping avoids wasted computations once convergence is observed.\n   - Effective sampling prevents time spent on invalid samples and expands coverage for faster convergence."
        }
    },
    {
        "parents": [
            {
                "operator": "e2",
                "algorithm_description": "A bidirectional informed RRT* planner with adaptive step sizing, dynamic neighbor radius using k-nearest approach, obstacle-aware rewiring, and heuristic-guided sampling that progressively focuses sampling within an ellipsoid to concentrate efforts around promising paths. The planner implements pruning of trees beyond the current best cost, uses balanced tree growth with rapid connection attempts, and performs iterative path shortcutting to smooth and shorten the resulting path efficiently, terminating early if no significant improvements are observed.",
                "planning_mechanism": "The algorithm alternates growth between the two trees with adaptive step sizes reducing as better paths are found, samples in an admissible ellipsoidal region shrinking with best costs to intensify search near the optimum, applies k-nearest rewiring for flexible neighborhood connection, prunes nodes exceeding current best path cost to save computation, connects trees eagerly when within step-size distance, and applies iterative shortcutting on the final path to enhance smoothness while monitoring improvement to early halt the search.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size_init=5.0, k_nearest=12,\n                 no_improve_limit=60, improve_tol=1e-7, shortcut_iters=250):\n        self.max_iter = max_iter\n        self.step_size_init = step_size_init\n        self.k_nearest = k_nearest\n        self.no_improve_limit = no_improve_limit\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def dist(a, b):\n            d_sq = 0.0\n            for i in range(dim):\n                d_sq += (a[i] - b[i]) ** 2\n            return math.sqrt(d_sq)\n\n        def in_obstacle(p):\n            px = p + (0.0,) * (3 - dim) if dim < 3 else p\n            for obs in obstacles:\n                if dim == 2:\n                    ox, oy, ow, oh = obs\n                    if ox <= px[0] <= ox + ow and oy <= px[1] <= oy + oh:\n                        return True\n                else:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px[0] <= ox + ow and oy <= px[1] <= oy + oh and oz <= px[2] <= oz + od:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=0.4):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(f[j] + (t[j] - f[j]) * (i / steps) for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to, max_step):\n            d = dist(frm, to)\n            if d <= max_step:\n                return to\n            ratio = max_step / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d += diff * diff\n                    if d > best_dist * best_dist:\n                        break\n                else:\n                    d = math.sqrt(d)\n                    if d < best_dist:\n                        best = node\n                        best_dist = d\n            return best\n\n        def k_nearest_nodes(tree, point, k):\n            # find k nearest nodes by distance (linear scan sufficient for this scale)\n            dists = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d += diff * diff\n                    if d > float('inf'):\n                        break\n                else:\n                    dists.append((math.sqrt(d), n))\n            dists.sort(key=lambda x: x[0])\n            return [n for _, n in dists[:k]]\n\n        def cost_to_node(node):\n            return node.cost\n\n        c_min = dist(start, goal)\n\n        def ellipsoid_sample(c_best):\n            # If no solution, sample uniformly in bounds\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-14:\n                # Degenerate case, sample uniformly\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Build orthonormal basis using Gram-Schmidt for dim-dim matrix U\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0.0] * dim\n                base[(idx + 1) % dim] = 1.0\n                for u in U:\n                    proj = sum(base[j] * u[j] for j in range(dim))\n                    base = [base[j] - proj * u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-14:\n                    base = [x / norm_base for x in base]\n                else:\n                    base = [0.0] * dim\n                U.append(base)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            # Sample in unit ball then scale and rotate\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n\n                point_scaled = [radii[i] * point_ball[i] for i in range(dim)]\n                # Rotate by U matrix transpose\n                point_rotated = [0.0] * dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i] * U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        def dynamic_step_size(iter_count, best_cost):\n            # shrink step size as better paths found (min 1.0)\n            base = self.step_size_init\n            shrink = 1.0\n            if best_cost != float('inf'):\n                shrink = max(0.3, best_cost / (c_min * 3.0))\n            # also reduce with iteration to refine\n            decay_iter_factor = max(0.2, 1.0 - iter_count / self.max_iter)\n            step = base * shrink * decay_iter_factor\n            return max(1.0, step)\n\n        def add_node(tree, sample, all_nodes, edges, best_cost, iter_count):\n            step_size = dynamic_step_size(iter_count, best_cost)\n            nn = nearest(tree, sample)\n            new_pos = steer(nn.position, sample, step_size)\n            if in_obstacle(new_pos) or edge_obstacle(nn.position, new_pos):\n                return None\n            # Find k nearest neighbors in tree for rewiring\n            near = k_nearest_nodes(tree, new_pos, self.k_nearest)\n\n            # Choose best parent among near nodes\n            best_parent = nn\n            best_cost_to_new = nn.cost + dist(nn.position, new_pos)\n            for near_node in near:\n                if near_node == nn:\n                    continue\n                cand_cost = near_node.cost + dist(near_node.position, new_pos)\n                if cand_cost + self.improve_tol < best_cost_to_new and not edge_obstacle(near_node.position, new_pos):\n                    best_parent = near_node\n                    best_cost_to_new = cand_cost\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost_to_new\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new node if beneficial\n            for near_node in near:\n                if near_node == best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost and not edge_obstacle(new_node.position, near_node.position):\n                    if near_node.parent is not None:\n                        near_node.parent.remove_child(near_node)\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                    new_node.add_child(near_node)\n                    near_node.cost = alt_cost\n                    edges.append((new_node, near_node))\n\n            return new_node\n\n        def extract_path(node_s, node_g):\n            path_s = node_s.path_from_root()\n            path_g = node_g.path_from_root()\n            # The connection node is node_s and node_g may not be same position.\n            # Attach goal tree path reversed (excluding common node if exists)\n            # To avoid double node, check equality of endpoints\n            if path_s and path_g and path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            else:\n                return path_s + path_g[::-1]\n\n        def shortcut_path(path):\n            # Iteratively shortcut path by trying to connect non-consecutive nodes directly\n            if len(path) < 3:\n                return path\n            changed = True\n            count = 0\n            while changed and count < self.shortcut_iters:\n                changed = False\n                count += 1\n                i = 0\n                while i < len(path) - 2:\n                    # Random distant j\n                    max_jump = min(len(path) - 1, i + 6)\n                    j = random.randint(i + 2, max_jump)\n                    if not edge_obstacle(path[i], path[j]):\n                        # shortcut possible\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialize trees\n        start_node = Node(start)\n        goal_node = Node(goal)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        found = False\n\n        no_improve_count = 0\n        last_best = float('inf')\n\n        for itr in range(self.max_iter):\n            # Sample using ellipsoidal informed sampling\n            sample_pt = ellipsoid_sample(best_cost)\n\n            # Alternate trees for growth\n            if itr % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            new_node = add_node(tree_a, sample_pt, all_nodes, edges, best_cost, itr)\n            if new_node is None:\n                continue\n\n            # Try to connect new node to nearest on other tree\n            near_connect = nearest(tree_b, new_node.position)\n            if near_connect is not None:\n                dist_cand = dist(near_connect.position, new_node.position)\n                step_curr = dynamic_step_size(itr, best_cost)\n                if dist_cand <= step_curr and not edge_obstacle(new_node.position, near_connect.position):\n                    # Possible connection\n                    path_candidate = extract_path(new_node, near_connect)\n                    candidate_cost = new_node.cost + dist_cand + near_connect.cost\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = path_candidate\n                        found = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    if found:\n                        no_improve_count += 1\n\n            # Prune nodes exceeding best cost + tolerance to improve efficiency\n            if found:\n                limit_cost = best_cost + self.improve_tol\n                def prune(tree):\n                    to_remove = []\n                    for node in tree:\n                        if node.cost > limit_cost:\n                            to_remove.append(node)\n                    for node in to_remove:\n                        if node.parent:\n                            node.parent.remove_child(node)\n                        try:\n                            tree.remove(node)\n                            all_nodes.remove(node)\n                        except Exception:\n                            pass\n                prune(tree_start)\n                prune(tree_goal)\n\n            # Early stopping on stagnation\n            if found:\n                if best_cost + self.improve_tol < last_best:\n                    last_best = best_cost\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                if no_improve_count >= self.no_improve_limit:\n                    break\n\n        # Post-processing shortcutting for smoothness and length improvements\n        if found and len(best_path) > 3:\n            best_path = shortcut_path(best_path)\n\n        if found:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
                "objective": 44.13367,
                "time_improvement": -94.0,
                "length_improvement": 19.0,
                "smoothness_improvement": 1116.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.056844019889831544,
                        "num_nodes_avg": 131.4,
                        "path_length_avg": 158.28767403870523,
                        "smoothness_avg": 0.04288565059179957,
                        "success_improvement": 0.0,
                        "time_improvement": -134.06629655263816,
                        "length_improvement": 13.240017630681594,
                        "smoothness_improvement": 571.2535594424835,
                        "objective_score": -29.419610590170073
                    },
                    {
                        "map_id": 1,
                        "success_rate": 0.9,
                        "time_avg": 0.0836817741394043,
                        "num_nodes_avg": 359.9,
                        "path_length_avg": 228.1134320486448,
                        "smoothness_avg": 0.07374435827108994,
                        "success_improvement": -9.999999999999998,
                        "time_improvement": 48.173512745365564,
                        "length_improvement": 23.84917050107601,
                        "smoothness_improvement": 1797.4954542294452,
                        "objective_score": -12.250966604597496
                    },
                    {
                        "map_id": 2,
                        "success_rate": 0.9,
                        "time_avg": 0.1458946704864502,
                        "num_nodes_avg": 412.3,
                        "path_length_avg": 118.5632699248331,
                        "smoothness_avg": 0.08490620066984564,
                        "success_improvement": -9.999999999999998,
                        "time_improvement": -194.6133217784839,
                        "length_improvement": 21.255921492140313,
                        "smoothness_improvement": 980.0006053966165,
                        "objective_score": -90.7304406112779
                    }
                ],
                "success_rate": 0.9333333333333332
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -23.76291481494683,
                "time_improvement": 61.0,
                "length_improvement": 8.0,
                "smoothness_improvement": 166.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.012529301643371581,
                        "num_nodes_avg": 131.9,
                        "path_length_avg": 176.77827310097746,
                        "smoothness_avg": 0.01645631271580969,
                        "success_improvement": 0.0,
                        "time_improvement": 48.408166070262766,
                        "length_improvement": 3.105027282357968,
                        "smoothness_improvement": 157.5770294574498,
                        "objective_score": 17.173351337780858
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.01886875629425049,
                        "num_nodes_avg": 256.8,
                        "path_length_avg": 267.7347696890942,
                        "smoothness_avg": 0.010597136127488454,
                        "success_improvement": 0.0,
                        "time_improvement": 88.31404606735866,
                        "length_improvement": 10.622427559723258,
                        "smoothness_improvement": 172.67194536891012,
                        "objective_score": 33.7310300828861
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.026641178131103515,
                        "num_nodes_avg": 304.4,
                        "path_length_avg": 136.29588257526552,
                        "smoothness_avg": 0.02101448639210645,
                        "success_improvement": 0.0,
                        "time_improvement": 46.20196913892299,
                        "length_improvement": 9.478764505998065,
                        "smoothness_improvement": 167.3027157795587,
                        "objective_score": 20.384363024173528
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "A bidirectional RRT* planner with adaptive radius rewiring, progressive heuristic ellipsoidal sampling focusing search on promising paths, and early termination on convergence stagnation. It uses dynamic neighbor radius scaled with the logarithm of current tree size, adaptive step size that balances exploration and refinement, and incremental cost-based rewiring with bidirectional tree connection attempts. Path shortcutting is performed iteratively post solution to shorten and smooth the path efficiently.",
            "planning_mechanism": "The planner grows two trees from start and goal nodes alternately, samples new points focusing inside an informed ellipsoid shaped by current best solution cost to guide exploration. New nodes are connected using parent selection minimizing path cost within a dynamically computed neighbor radius that adapts as the tree grows. Rewiring adjusts tree topology to reduce costs. When the two trees connect within step distance, the combined path is saved if better. Early termination triggers if no cost improvement occurs over a configurable window, reducing runtime. Post processing shortcuts the path to remove unnecessary waypoints and improves path smoothness.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, neighbor_factor=2.0, no_improve_limit=60, improve_tol=1e-7, shortcut_iters=250):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor\n        self.no_improve_limit = no_improve_limit\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def dist(a,b):\n            return math.sqrt(sum((a[i]-b[i])**2 for i in range(dim)))\n\n        def in_obstacle(p):\n            px = p + (0.0,)*(3-dim) if dim<3 else p\n            for obs in obstacles:\n                if dim == 2:\n                    x,y,w,h = obs\n                    if x <= px[0] <= x+w and y <= px[1] <= y+h:\n                        return True\n                else:\n                    x,y,z,w,h,d = obs\n                    if x <= px[0] <= x+w and y <= px[1] <= y+h and z <= px[2] <= z+d:\n                        return True\n            return False\n\n        def edge_obstacle(f,t,resolution=0.4):\n            length = dist(f,t)\n            if length < 1e-12:\n                return False\n            steps = max(2,int(length/resolution))\n            for i in range(steps+1):\n                interp = tuple(f[j] + (t[j]-f[j])*(i/steps) for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm,to,max_step):\n            d = dist(frm,to)\n            if d <= max_step:\n                return to\n            ratio = max_step/d\n            return tuple(frm[i]+(to[i]-frm[i])*ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d += diff*diff\n                    if d > best_dist*best_dist:\n                        break\n                else:\n                    d = math.sqrt(d)\n                    if d < best_dist:\n                        best = node\n                        best_dist = d\n            return best\n\n        def neighbor_radius(tree_len):\n            # Adaptive neighbor radius based on tree size, theoretical RRT* scaling\n            if tree_len < 2:\n                return self.step_size * 2.0\n            return min(self.step_size*5.0, self.neighbor_factor * (math.log(tree_len)/tree_len)**(1.0/dim)*max(bounds))\n\n        def neighbors(tree, point, radius):\n            neigh = []\n            r_sq = radius*radius\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d_sq += diff*diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    neigh.append(node)\n            return neigh\n\n        c_min = dist(start, goal)\n\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            center = tuple((start[i]+goal[i])*0.5 for i in range(dim))\n            a1 = [goal[i]-start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            # Orthonormal basis U via Gram-Schmidt (dim x dim)\n            U = [unit_a1]\n            for idx in range(dim-1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j]-proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    base = [x/norm_base for x in base]\n                else:\n                    base = [0.0]*dim\n                U.append(base)\n\n            r1 = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val>0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x/norm_ball for x in x_ball]\n                u_rand = random.random()**(1.0/dim)\n                point_ball = [coord*u_rand for coord in unit_ball]\n\n                point_scaled = [radii[i]*point_ball[i] for i in range(dim)]\n\n                # Rotate by U matrix transpose\n                point_rot = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rot[j] += point_scaled[i]*U[i][j]\n\n                sample = tuple(center[i]+point_rot[i] for i in range(dim))\n                if all(0.0<=sample[i]<=bounds[i] for i in range(dim)):\n                    return sample\n\n        def add_node(tree, sample, all_nodes, edges, best_cost):\n            nn = nearest(tree, sample)\n            new_pos = steer(nn.position, sample, self.step_size)\n            if in_obstacle(new_pos) or edge_obstacle(nn.position,new_pos):\n                return None\n            radius = neighbor_radius(len(tree))\n            near = neighbors(tree, new_pos, radius)\n            best_parent = nn\n            min_cost = nn.cost + dist(nn.position,new_pos)\n            for candidate in near:\n                cand_cost = candidate.cost + dist(candidate.position,new_pos)\n                if cand_cost + self.improve_tol < min_cost and not edge_obstacle(candidate.position,new_pos):\n                    best_parent = candidate\n                    min_cost = cand_cost\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent,new_node))\n\n            # Rewire neighbors through new node if beneficial\n            for neighbor in near:\n                if neighbor is best_parent: \n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost + self.improve_tol < neighbor.cost and not edge_obstacle(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        neighbor.parent.remove_child(neighbor)\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n                    new_node.add_child(neighbor)\n                    neighbor.cost = alt_cost\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def extract_path(node_s, node_g):\n            path_s = node_s.path_from_root()\n            path_g = node_g.path_from_root()\n            # Avoid duplicate duplicate connecting node\n            if path_s and path_g and path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            else:\n                return path_s + path_g[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            count = 0\n            changed = True\n            while changed and count < self.shortcut_iters:\n                changed = False\n                count += 1\n                i = 0\n                while i < len(path)-2:\n                    max_jump = min(len(path)-1, i+6)\n                    j = random.randint(i+2, max_jump)\n                    if not edge_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        start_node = Node(start)\n        goal_node = Node(goal)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        found = False\n        no_improve_count = 0\n        last_best = best_cost\n\n        for itr in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost)\n\n            if itr % 2 == 0:\n                main_tree, other_tree = tree_start, tree_goal\n            else:\n                main_tree, other_tree = tree_goal, tree_start\n\n            new_node = add_node(main_tree, sample_pt, all_nodes, edges, best_cost)\n            if new_node is None:\n                continue\n\n            near_connect = nearest(other_tree, new_node.position)\n            step_dist = dist(near_connect.position, new_node.position)\n            if step_dist <= self.step_size and not edge_obstacle(new_node.position, near_connect.position):\n                candidate_cost = new_node.cost + near_connect.cost + step_dist\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = extract_path(new_node, near_connect)\n                    found = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            else:\n                if found:\n                    no_improve_count += 1\n\n            if found:\n                # Early stopping on stagnation of improvement\n                if best_cost + self.improve_tol < last_best:\n                    last_best = best_cost\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                if no_improve_count >= self.no_improve_limit:\n                    break\n\n        if found and len(best_path) > 3:\n            best_path = shortcut_path(best_path)\n\n        if found:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
            "objective": 6.30946,
            "time_improvement": -81.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1172.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.08813977241516113,
                    "num_nodes_avg": 171.3,
                    "path_length_avg": 155.94724987804915,
                    "smoothness_avg": 0.037895327969512546,
                    "success_improvement": 0.0,
                    "time_improvement": -262.9326382650782,
                    "length_improvement": 14.522841199531285,
                    "smoothness_improvement": 493.1441737446706,
                    "objective_score": -67.70036589108133
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08728914260864258,
                    "num_nodes_avg": 314.3,
                    "path_length_avg": 226.58476458100463,
                    "smoothness_avg": 0.07942344506505501,
                    "success_improvement": 0.0,
                    "time_improvement": 45.93936752179157,
                    "length_improvement": 24.35948370202769,
                    "smoothness_improvement": 1943.6224479190457,
                    "objective_score": 38.11561271734931
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.061713361740112306,
                    "num_nodes_avg": 259.4,
                    "path_length_avg": 118.83941821204158,
                    "smoothness_avg": 0.09275591661871693,
                    "success_improvement": 0.0,
                    "time_improvement": -24.621265737464196,
                    "length_improvement": 21.072516948544795,
                    "smoothness_improvement": 1079.8484128604985,
                    "objective_score": 10.65637251219011
                }
            ],
            "success_rate": 1.0
        },
        "objective": 8.200000000000003,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient nearest neighbor searches without adaptive neighbor radius, leading to longer planning times especially as tree size grows.\n   - Use of fixed step sizes limiting exploration adaptability, potentially causing slower convergence.\n   - Expensive and repeated rewiring and pruning operations without dynamic radius tuning, increasing computational overhead.\n   - Basic path shortcutting with limited iterations possibly insufficient to fully smooth or shorten paths."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Introduction of adaptive neighbor radius that scales with the tree size to efficiently balance exploration and rewiring.\n   - Utilization of heuristic-informed sampling guiding the search inside an ellipsoid focused on promising solution space.\n   - Incorporation of early termination criteria based on improvement stagnation to avoid unnecessary computation.\n   - Enhanced rewiring and parent selection using adaptive radius and cost-based decisions reducing redundant expansions.\n   - Increased and iterative path shortcutting applied post solution for better path smoothness and length reduction.\n2. Expected mechanism of impact:\n   - Adaptive neighbor radius reduces the number of unnecessary neighbors checked and rewired, improving runtime efficiency.\n   - Focused ellipsoidal sampling accelerates convergence by sampling more relevant regions, reducing wasted samples.\n   - Early stopping decreases runtime by terminating planning when further improvements become unlikely.\n   - Improved rewiring ensures that lower-cost paths are found and maintained earlier, reducing path length and smoothing.\n   - Iterative shortcutting removes unnecessary waypoints and smooths paths, resulting in shorter and smoother final paths."
        }
    },
    {
        "parents": [
            {
                "operator": "m1",
                "algorithm_description": "A bidirectional RRT* inspired planner that grows two trees from start and goal with rewiring and dynamic neighbor radius, incorporating path shortcutting after connection to reduce path length and improve smoothness while ensuring collision-free nodes and edges throughout. It balances exploration and optimization, seeks lowest cost connections, and maintains efficient updates for paths and parents.",
                "planning_mechanism": "The planner samples collision-free points within the map bounds, extends the nearest node of one tree towards the sample, rewires neighbors for lower-cost paths, and attempts to connect the other tree to the newly added node with rewiring as well. Upon connection, a path is extracted and post-processed with shortcutting to smooth and shorten it. The rewiring radius adapts with the tree size to balance exploration and optimization. This enables efficient bidirectional growth with asymptotic optimality and improved path quality.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=50.0, max_rewire_radius=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_rewire_radius = max_rewire_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        final_path = []\n\n        for iter in range(self.max_iter):\n            sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate trees for growth each iteration\n            if iter % 2 == 0:\n                new_node = self._extend_tree(tree_start, tree_goal, sample, obstacles, is_3d, nodes, edges, bounds)\n                if new_node:\n                    conn_node = self._connect_tree(tree_goal, new_node, obstacles, is_3d, nodes, edges, bounds)\n                    if conn_node:\n                        success = True\n                        path_start = new_node.path_from_root()\n                        path_goal = conn_node.path_from_root()\n                        if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                            path_goal = path_goal[:-1]\n                        merged_path = path_start + path_goal[::-1]\n                        final_path = self._shortcut_path(merged_path, obstacles, is_3d, bounds)\n                        break\n            else:\n                new_node = self._extend_tree(tree_goal, tree_start, sample, obstacles, is_3d, nodes, edges, bounds)\n                if new_node:\n                    conn_node = self._connect_tree(tree_start, new_node, obstacles, is_3d, nodes, edges, bounds)\n                    if conn_node:\n                        success = True\n                        path_goal = new_node.path_from_root()\n                        path_start = conn_node.path_from_root()\n                        if path_goal and path_start and path_goal[-1] == path_start[-1]:\n                            path_start = path_start[:-1]\n                        merged_path = path_goal + path_start[::-1]\n                        final_path = self._shortcut_path(merged_path, obstacles, is_3d, bounds)\n                        break\n\n        return PlannerResult(success, final_path, nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near(self, tree, point, bounds):\n        n = len(tree)\n        d = len(point)\n        if n == 0:\n            return []\n        r_ddl = self.gamma * ((math.log(n) / n) ** (1.0 / d)) if n > 1 else self.step_size * 2\n        radius = max(self.step_size * 2, min(self.max_rewire_radius, r_ddl))\n        near_nodes = [node for node in tree if self._dist(node.position, point) <= radius]\n        return near_nodes\n\n    def _extend_tree(self, tree_to_extend, other_tree, sample, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree_to_extend, sample)\n        new_pos = self._steer(nearest.position, sample)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        near_nodes = self._near(tree_to_extend, new_pos, bounds)\n\n        # Choose best parent among neighbors (including nearest) with minimal cost\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in near_nodes:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost_through_nb = nb.cost + self._dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree_to_extend.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new node if cheaper and collision-free edge\n        for nb in near_nodes:\n            if nb == best_parent:\n                continue\n            if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                cost_through_new = new_node.cost + self._dist(new_node.position, nb.position)\n                if cost_through_new + 1e-12 < nb.cost:\n                    # Reassign parent\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = cost_through_new\n                    edges.append((new_node, nb))\n\n        return new_node\n\n    def _connect_tree(self, tree_to_connect, target_node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree_to_connect, target_node.position)\n\n        new_pos = target_node.position\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        near_nodes = self._near(tree_to_connect, new_pos, bounds)\n\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in near_nodes:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost_through_nb = nb.cost + self._dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree_to_connect.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for nb in near_nodes:\n            if nb == best_parent:\n                continue\n            if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                cost_through_new = new_node.cost + self._dist(new_node.position, nb.position)\n                if cost_through_new + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = cost_through_new\n                    edges.append((new_node, nb))\n\n        return new_node\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path[:]\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened\n\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
                "objective": -16.5554,
                "time_improvement": -1.0,
                "length_improvement": 16.0,
                "smoothness_improvement": 1439.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.050579285621643065,
                        "num_nodes_avg": 106.8,
                        "path_length_avg": 164.2712937810431,
                        "smoothness_avg": 0.04226815816929853,
                        "success_improvement": 0.0,
                        "time_improvement": -108.27003598058127,
                        "length_improvement": 9.960300833383796,
                        "smoothness_improvement": 561.5884621240848,
                        "objective_score": -23.69688798352368
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.049871516227722165,
                        "num_nodes_avg": 224.9,
                        "path_length_avg": 237.86532514731707,
                        "smoothness_avg": 0.10161854011327172,
                        "success_improvement": 0.0,
                        "time_improvement": 69.11316081994654,
                        "length_improvement": 20.593707892059786,
                        "smoothness_improvement": 2514.7182299904466,
                        "objective_score": 45.66376413117207
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.03152651786804199,
                        "num_nodes_avg": 152.6,
                        "path_length_avg": 123.96994519489405,
                        "smoothness_avg": 0.10533489541470797,
                        "success_improvement": 0.0,
                        "time_improvement": 36.33672757035219,
                        "length_improvement": 17.66506521597572,
                        "smoothness_improvement": 1239.8520946618717,
                        "objective_score": 27.699317874000446
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "e2",
                "algorithm_description": "A bidirectional variant of RRT* with informed sampling and efficient rewiring that grows two trees simultaneously, restricts sampling to an ellipsoidal informed subset after first solution, and performs local rewiring to improve path cost and smoothness with early termination on convergence.",
                "planning_mechanism": "The planner grows start and goal trees bidirectionally with RRT* rewiring, initially samples uniformly to quickly find a path, then constrains samples to an ellipsoidal informed set defined by the current best path cost. After each extension, it attempts to connect the two trees if close enough, while performing localized rewiring to continuously improve path quality. Early stopping criteria limit iterations after no improvements to reduce planning time.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, radius=15.0,\n                 post_opt_iters=500, max_no_improve=100, improve_tol=1e-5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n\n        c_min = math.dist(start, goal)\n        found_solution = False\n\n        no_improve_count = 0\n        post_opt_count = 0\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            return tuple(frm[i] + (to[i]-frm[i]) * self.step_size / d for i in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            distance = dist(f, t)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                inter = tuple(f[j] + (t[j]-f[j])*(i/steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def nearest(tree, p):\n            best = tree[0]\n            best_d = dist(best.position, p)\n            for n in tree:\n                d2 = dist(n.position, p)\n                if d2 < best_d:\n                    best = n\n                    best_d = d2\n            return best\n\n        def near_nodes(tree, p, radius):\n            result = []\n            r2 = radius**2\n            for n in tree:\n                d2 = sum((n.position[i]-p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def extract_path(n_start, n_goal):\n            path_start, node = [], n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def ellipsoid_sample(c_best):\n            # Sample inside prolate hyperspheroid defined by start, goal, c_best\n            import random\n            import math\n\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i]+goal[i])/2 for i in range(dim))\n            a1 = [goal[i]-start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-12:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            # Compute rotation matrix via Gram-Schmidt or approximate as identity except along a1 axis\n            # For simplicity, rotate only along principal axis for 2D or 3D (orthonormal basis)\n            # Since imports are restricted, implement a simple orthonormal basis:\n\n            # Construct orthonormal basis U with unit_a1 as first vector\n            U = [unit_a1]\n            for i in range(dim-1):\n                base = [0]*dim\n                base[(i+1)%dim] = 1  # simple perpendicular approx\n                # Gram-Schmidt orthogonalize base vs U\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j]-proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-12:\n                    U.append([x/norm_base for x in base])\n                else:\n                    # fallback: constructs zero vector, skip\n                    U.append([0]*dim)\n\n            # L matrix diagonal\n            r1 = c_best / 2\n            if c_best*c_best - c_min*c_min < 0:\n                r2 = 0\n            else:\n                r2 = math.sqrt(c_best*c_best - c_min*c_min) / 2\n            radii = [r1] + [r2] * (dim - 1)\n\n            # Sample unit ball in dim\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-12:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n\n                # Scale by radii\n                point_scaled = [radii[i]*point_ball[i] for i in range(dim)]\n\n                # Rotate via U matrix: point = sum(point_scaled[i] * U[i]) over basis vectors\n                point_rotated = [0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i]*U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        for iter_count in range(self.max_iter):\n            if found_solution:\n                sample_pt = ellipsoid_sample(best_cost)\n            else:\n                sample_pt = ellipsoid_sample(float('inf'))\n\n            # Alternate growing start and goal trees\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n\n                if in_obstacle(new_pos) or edge_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                near = near_nodes(tree_a, new_pos, self.radius)\n\n                # Choose best parent in near nodes with minimal cost + dist and collision free edge\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for candidate in near:\n                    cand_cost = candidate.cost + dist(candidate.position, new_pos)\n                    if cand_cost + self.improve_tol < min_cost and not edge_obstacle(candidate.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = candidate\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire near nodes if new_node offers lower cost connection\n                for near_node in near:\n                    if near_node == best_parent:\n                        continue\n                    alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if alt_cost + self.improve_tol < near_node.cost and not edge_obstacle(new_node.position, near_node.position):\n                        # Remove old edge\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                        if near_node.parent and near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n                # Try connect trees if nodes close enough\n                connect_node = nearest(tree_b, new_node.position)\n                if dist(new_node.position, connect_node.position) <= self.step_size and not edge_obstacle(new_node.position, connect_node.position):\n                    path = extract_path(new_node, connect_node)\n                    path_cost = new_node.cost + dist(new_node.position, connect_node.position) + connect_node.cost\n                    if path_cost + self.improve_tol < best_cost:\n                        best_cost = path_cost\n                        # Stitch trees at connection nodes: assign parents carefully\n                        # For bidirectional path extraction, keep nodes and edges unchanged,\n                        # just store nodes for path extraction\n                        best_path = path\n                        found_solution = True\n                        best_goal_node = connect_node\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n\n                    if found_solution and no_improve_count >= self.max_no_improve:\n                        post_opt_count += 1\n                        if post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_opt_count += 1\n                        if no_improve_count >= self.max_no_improve or post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
                "objective": 52.64884,
                "time_improvement": -220.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 323.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.06786198616027832,
                        "num_nodes_avg": 317.3,
                        "path_length_avg": 155.50621247453464,
                        "smoothness_avg": 0.02411673119934513,
                        "success_improvement": 0.0,
                        "time_improvement": -179.4349134355319,
                        "length_improvement": 14.764580789082476,
                        "smoothness_improvement": 277.4792135897667,
                        "objective_score": -43.58432948926125
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.14667820930480957,
                        "num_nodes_avg": 670.6,
                        "path_length_avg": 226.29277909188164,
                        "smoothness_avg": 0.017873034085429756,
                        "success_improvement": 0.0,
                        "time_improvement": 9.158040406689327,
                        "length_improvement": 24.45695686263326,
                        "smoothness_improvement": 359.8860404442116,
                        "objective_score": 19.22101644180781
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.2925038576126099,
                        "num_nodes_avg": 613.1,
                        "path_length_avg": 120.56565817380633,
                        "smoothness_avg": 0.03399415459254427,
                        "success_improvement": 0.0,
                        "time_improvement": -490.6695072338173,
                        "length_improvement": 19.926030560654297,
                        "smoothness_improvement": 332.4031372296796,
                        "objective_score": -133.58321814760419
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that combines efficient nearest neighbor approximation with an adaptive rewiring radius and incremental pruning to reduce redundant nodes. It alternately grows two trees from start and goal, uses approximate KD-tree-like spatial hashing for faster nearest and near node searches, performs rewiring for local path optimization, and incorporates a fast path shortcutting step at connection to improve path length and smoothness. The planner also dynamically adjusts its rewiring radius based on tree size and dimensionality to limit rewiring overhead and integrates early stopping when improvement stalls, all designed to minimize planning time and path length without excessive computational effort.",
            "planning_mechanism": "The planner alternately grows two trees towards randomly sampled free points, selecting optimal parents from nearby nodes with fast approximate neighbor queries. After each extension, it attempts to connect the opposite tree. Upon successful connection, it extracts the path and performs shortcutting to remove unnecessary waypoints. Adaptive neighbor radius and incremental pruning keep the trees efficient, while an early stopping condition prevents wasteful iterations once no meaningful improvements occur.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, gamma=35.0,\n                 max_rewire_radius=40.0, early_stop_no_improve=80,\n                 shortcut_iter=160):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_rewire_radius = max_rewire_radius\n        self.early_stop_no_improve = early_stop_no_improve\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Spatial hashing grid params for approximate neighbors\n        cell_size = max(self.step_size, 5.0)\n        def grid_hash(pos):\n            return tuple(int(p // cell_size) for p in pos)\n\n        # Spatial hash maps: cell => list of nodes\n        start_grid = {}\n        goal_grid = {}\n\n        def insert_node(grid, node):\n            cell = grid_hash(node.position)\n            if cell not in grid:\n                grid[cell] = []\n            grid[cell].append(node)\n\n        insert_node(start_grid, start_root)\n        insert_node(goal_grid, goal_root)\n\n        def get_near_nodes(grid, pos, radius):\n            cell_coords = grid_hash(pos)\n            r_cells = int(math.ceil(radius / cell_size))\n            candidates = []\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    if dim == 2:\n                        cell = (cell_coords[0]+dx, cell_coords[1]+dy)\n                        if cell in grid:\n                            candidates.extend(grid[cell])\n                    else:\n                        for dz in range(-r_cells, r_cells + 1):\n                            cell = (cell_coords[0]+dx, cell_coords[1]+dy, cell_coords[2]+dz)\n                            if cell in grid:\n                                candidates.extend(grid[cell])\n            radius_sq = radius * radius\n            return [n for n in candidates if self._dist_sq(n.position, pos) <= radius_sq]\n\n        def remove_node(grid, node):\n            cell = grid_hash(node.position)\n            if cell in grid and node in grid[cell]:\n                grid[cell].remove(node)\n                if not grid[cell]:\n                    del grid[cell]\n\n        def update_node_grid(grid, node, old_pos):\n            old_cell = grid_hash(old_pos)\n            new_cell = grid_hash(node.position)\n            if old_cell != new_cell:\n                if old_cell in grid and node in grid[old_cell]:\n                    grid[old_cell].remove(node)\n                    if not grid[old_cell]:\n                        del grid[old_cell]\n                if new_cell not in grid:\n                    grid[new_cell] = []\n                grid[new_cell].append(node)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_counter = 0\n\n        # Precompute c_min distance between start and goal for radius calc\n        c_min = self._dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            # Adaptive rewiring radius based on total nodes and dimension\n            total_nodes = len(tree_start) + len(tree_goal)\n            if total_nodes > 1:\n                radius = min(self.max_rewire_radius,\n                             self.gamma * ((math.log(total_nodes) / total_nodes) ** (1/dim)))\n                radius = max(radius, self.step_size * 2.0)\n            else:\n                radius = self.step_size * 2.0\n\n            # Sample collision-free point uniformly\n            sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree extension\n            extend_tree, connect_tree = (tree_start, tree_goal) if it % 2 == 0 else (tree_goal, tree_start)\n            extend_grid = start_grid if it % 2 == 0 else goal_grid\n            connect_grid = goal_grid if it % 2 == 0 else start_grid\n\n            # Extend phase\n            nearest_node = self._approx_nearest(extend_tree, extend_grid, sample, radius, is_3d)\n            if nearest_node is None:\n                continue  # safety\n\n            new_pos = self._steer(nearest_node.position, sample)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = get_near_nodes(extend_grid, new_pos, radius)\n\n            # Select best parent\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in near_nodes:\n                if nb == nearest_node:\n                    continue\n                if self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    continue\n                cost_through_nb = nb.cost + self._dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            extend_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            insert_node(extend_grid, new_node)\n\n            # Rewire neighbors to new_node if cheaper and collision free\n            for nb in near_nodes:\n                if nb == best_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    continue\n                alt_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                if alt_cost + 1e-12 < nb.cost:\n                    # Reassign parent, update edges\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except Exception:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = alt_cost\n                    edges.append((new_node, nb))\n\n            # Try connect other tree\n            nearest_connect = self._approx_nearest(connect_tree, connect_grid, new_node.position, radius, is_3d)\n            if nearest_connect is None:\n                continue\n\n            dist_connect = self._dist(new_node.position, nearest_connect.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_connect.position, obstacles, is_3d):\n                    path_cost = new_node.cost + dist_connect + nearest_connect.cost\n                    if path_cost + 1e-12 < best_cost:\n                        best_cost = path_cost\n                        # Extract path:\n                        path_start = new_node.path_from_root()\n                        path_goal = nearest_connect.path_from_root()\n                        # Merge paths, avoiding repeated node\n                        if path_start[-1] == path_goal[-1]:\n                            path_goal = path_goal[:-1]\n                        raw_path = path_start + path_goal[::-1]\n                        # Shortcut to improve path\n                        best_path = self._shortcut_path(raw_path, obstacles, is_3d, bounds, iter_lim=self.shortcut_iter)\n                        found_solution = True\n                        no_improve_counter = 0\n                    else:\n                        no_improve_counter += 1\n            else:\n                # No connection improvement this iteration\n                no_improve_counter += 1\n\n            # Early stop if no improvement for long\n            if found_solution and no_improve_counter >= self.early_stop_no_improve:\n                break\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _approx_nearest(self, tree, grid, point, radius, is_3d):\n        # Use spatial hash to get candidates in vicinity\n        # Combine exact nearest from candidates\n        candidates = []\n        # Get candidates from surrounding cells (3x3 or 3x3x3)\n        dim = len(point)\n        cell_size = max(self.step_size, 5.0)\n        cell = tuple(int(p // cell_size) for p in point)\n        r_cells = 1  # radius small enough, consider nearby grid cells only\n        for dx in range(-r_cells, r_cells+1):\n            for dy in range(-r_cells, r_cells+1):\n                if dim == 2:\n                    c = (cell[0]+dx, cell[1]+dy)\n                    if c in grid:\n                        candidates.extend(grid[c])\n                else:\n                    for dz in range(-r_cells, r_cells+1):\n                        c = (cell[0]+dx, cell[1]+dy, cell[2]+dz)\n                        if c in grid:\n                            candidates.extend(grid[c])\n        if not candidates:\n            # fallback linear search if no candidates found\n            candidates = tree\n\n        best = None\n        best_dist = float('inf')\n        for n in candidates:\n            d = self._dist(n.position, point)\n            if d < best_dist:\n                best = n\n                best_dist = d\n        return best\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _dist_sq(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, iter_lim=160):\n        if len(path) < 3:\n            return list(path)\n        path_new = list(path)\n        iters = 0\n        while iters < iter_lim:\n            if len(path_new) < 3:\n                break\n            i = random.randint(0, len(path_new) - 3)\n            j = random.randint(i + 2, len(path_new) -1)\n            if not self._is_edge_in_obstacle(path_new[i], path_new[j], obstacles, is_3d):\n                # shortcut by removing intermediate nodes between i and j\n                del path_new[i+1:j]\n            iters += 1\n        return path_new",
            "objective": 2.70963,
            "time_improvement": -68.0,
            "length_improvement": 18.0,
            "smoothness_improvement": 1359.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06853735446929932,
                    "num_nodes_avg": 226.7,
                    "path_length_avg": 162.4933129975047,
                    "smoothness_avg": 0.04033359017827268,
                    "success_improvement": 0.0,
                    "time_improvement": -182.2158736703629,
                    "length_improvement": 10.934840274749654,
                    "smoothness_improvement": 531.3082720828986,
                    "objective_score": -45.44731657584458
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.10013775825500489,
                    "num_nodes_avg": 463.7,
                    "path_length_avg": 231.6140031793218,
                    "smoothness_avg": 0.10057505556673607,
                    "success_improvement": 0.0,
                    "time_improvement": 37.98185679876864,
                    "length_improvement": 22.680579099302726,
                    "smoothness_improvement": 2487.868621016545,
                    "objective_score": 37.442247604294955
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07947943210601807,
                    "num_nodes_avg": 412.2,
                    "path_length_avg": 118.59985783137168,
                    "smoothness_avg": 0.09098141231233955,
                    "success_improvement": 0.0,
                    "time_improvement": -60.49729183216582,
                    "length_improvement": 21.23162154674627,
                    "smoothness_improvement": 1057.2768490636613,
                    "objective_score": -0.12383037628367877
                }
            ],
            "success_rate": 1.0
        },
        "objective": -13.999999999999996,
        "analysis": {
            "problem": [
                ""
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Use of spatial hashing-based approximate nearest neighbor and near neighbor queries reduces neighbor search overhead.\n   - Adaptive rewiring radius based on tree size and workspace dimension limits unnecessary rewiring and accelerates iteration.\n   - Early stopping triggered by lack of path cost improvement prevents wasted computation.\n   - Incremental and bounded shortcutting after connecting trees improves path smoothness without excess computation.\n2. Expected mechanism of impact:\n   - Faster neighbor queries reduce per-iteration computational load, accelerating total planning time.\n   - Adaptive radius focuses rewiring on relevant neighbors, balancing optimization benefits and overhead.\n   - Early termination prevents diminishing returns in costly rewiring and extension steps.\n   - Controlled shortcutting reduces path length and jaggedness efficiently, enhancing smoothness while maintaining runtime gains."
        }
    },
    {
        "parents": [
            {
                "operator": "e2",
                "algorithm_description": "A novel bidirectional RRT* variant with integrated spatial hashing for efficient nearest/near node retrieval, adaptive rewiring radius tuned by tree growth and solution cost, subtree cost propagation during rewiring, pruning of costly subtrees to contain tree size, and a comprehensive multi-pass shortcut smoothing with curvature-aware pruning to achieve faster planning, shorter and smoother paths, improved robustness, and higher success rates. The planner alternates expansion between start and goal trees, uses ellipsoidal informed sampling after initial solution, performs cost+curvature aware parent selection and rewiring, aggressively prunes suboptimal branches, and refines the final path using iterative global shortcutting.",
                "planning_mechanism": "Planner grows two trees alternately from start and goal. Samples transition from uniform to ellipsoidal informed after first solution. Uses spatial hashing grids to accelerate nearest neighbor and near node search. Each new node selects parent minimizing cost plus small curvature penalty; rewires neighbors with cost and curvature check, propagates cost updates through affected subtrees. Prunes subtrees exceeding cost threshold relative to best path to limit complexity. After planning, performs iterative global shortcutting that removes unnecessary waypoints and smooths curvature. The process balances exploration and exploitation for efficient, robust, and high-quality bidirectional planning.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 step_size=5.5,\n                 n_near_const=30,\n                 max_no_improve=70,\n                 improve_tol=1e-6,\n                 shortcut_iters=400,\n                 prune_factor=1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n        self.prune_factor = prune_factor  # factor for pruning subtrees > prune_factor * best_cost\n\n    def plan(self, map):\n        import math, random, time\n\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is3d = (dim == 3)\n        dist = lambda a,b: math.dist(a,b)\n\n        # --- Collision helpers ---\n        def in_obstacle(p):\n            px = (p + (0,0,0))[:3]\n            for o in obstacles:\n                if is3d:\n                    ox, oy, oz, ow, oh, od = o\n                    if ox <= px[0] <= ox+ow and oy <= px[1] <= oy+oh and oz <= px[2] <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = o\n                    if ox <= px[0] <= ox+ow and oy <= px[1] <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,res=1.0):\n            d = dist(a,b)\n            if d < 1e-12:\n                return False\n            steps = max(2,int(d/res))\n            for i in range(steps+1):\n                interp = tuple(a[j] + (b[j]-a[j])*i/steps for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm,to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size/d\n            return tuple(frm[i] + (to[i]-frm[i])*ratio for i in range(dim))\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        # --- Spatial hashing grid for neighbor search ---\n        class SpatialHash:\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.inv_cell = 1.0 / cell_size\n                self.dim = len(bounds)\n                self.bounds = bounds\n                self.cells = {}\n            def _cell_coords(self, pos):\n                return tuple(int(pos[i]*self.inv_cell) for i in range(self.dim))\n            def insert(self, node):\n                cc = self._cell_coords(node.position)\n                if cc not in self.cells:\n                    self.cells[cc] = []\n                self.cells[cc].append(node)\n            def remove(self, node):\n                cc = self._cell_coords(node.position)\n                if cc in self.cells and node in self.cells[cc]:\n                    self.cells[cc].remove(node)\n                    if not self.cells[cc]:\n                        del self.cells[cc]\n            def nearby(self, pos, radius):\n                cells_to_check = []\n                cpos = self._cell_coords(pos)\n                r_cells = int(math.ceil(radius*self.inv_cell))\n                for delta in self._neighbors_deltas(r_cells):\n                    cell = tuple(cpos[d]+delta[d] for d in range(self.dim))\n                    cells_to_check.append(cell)\n                result = []\n                r_sq = radius*radius\n                for cell in cells_to_check:\n                    if cell in self.cells:\n                        for n in self.cells[cell]:\n                            d_sq = 0.0\n                            p = n.position\n                            for i in range(self.dim):\n                                dd = p[i]-pos[i]\n                                d_sq += dd*dd\n                                if d_sq > r_sq:\n                                    break\n                            if d_sq <= r_sq:\n                                result.append(n)\n                return result\n            def _neighbors_deltas(self, radius_cells):\n                # Generate all relative cell coordinates in radius cube\n                # For dim=2 or 3 only\n                if self.dim == 2:\n                    ret = []\n                    for dx in range(-radius_cells,radius_cells+1):\n                        for dy in range(-radius_cells,radius_cells+1):\n                            ret.append((dx,dy))\n                    return ret\n                elif self.dim == 3:\n                    ret = []\n                    for dx in range(-radius_cells,radius_cells+1):\n                        for dy in range(-radius_cells,radius_cells+1):\n                            for dz in range(-radius_cells,radius_cells+1):\n                                ret.append((dx,dy,dz))\n                    return ret\n                else:\n                    return []\n        # --- End spatial hash ---\n\n        # --- Curvature penalty for smoothing ---\n        def curvature_penalty(p0, p1, p2):\n            # angle between vectors p0->p1 and p1->p2\n            if p0 is None or p1 is None or p2 is None:\n                return 0.0\n            v1 = [p1[i]-p0[i] for i in range(dim)]\n            v2 = [p2[i]-p1[i] for i in range(dim)]\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim)) / (len1*len2)\n            dot = max(-1.0,min(1.0,dot))\n            return math.acos(dot)\n\n        # --- Adaptive rewiring radius ---\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes == 0:\n                return self.step_size*4.0\n            gamma_r = self.n_near_const\n            r = min((gamma_r*(math.log(n_nodes)/n_nodes))**(1/dim), self.step_size*6.0)\n            if c_best == float('inf'):\n                return r\n            shrink = max(0.25, c_best / (c_min*2.5))\n            return max(self.step_size*0.8, r*shrink)\n\n        # --- Ellipsoidal informed sampling ---\n        def informed_sample(c_best):\n            if not found_solution or c_best == float('inf') or c_min < 1e-12:\n                # uniform sample in bounds\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            center = tuple((start_pos[i]+goal_pos[i])*0.5 for i in range(dim))\n            a1 = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n            # construct an orthonormal basis by Gram-Schmidt\n            basis = [unit_a1]\n            for k in range(1, dim):\n                vec = [0]*dim\n                vec[(k) % dim] = 1\n                # subtract projections to previous basis vectors\n                for b in basis:\n                    proj = sum(vec[i]*b[i] for i in range(dim))\n                    vec = [vec[i] - proj*b[i] for i in range(dim)]\n                norm = math.sqrt(sum(x*x for x in vec))\n                if norm < 1e-14:\n                    vec = [0]*dim\n                else:\n                    vec = [x/norm for x in vec]\n                basis.append(vec)\n            r1 = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(max(val,0))*0.5 if val > 0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n\n            max_tries = 50\n            for _ in range(max_tries):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x/norm_ball for x in x_ball]\n                r = random.random()**(1/dim)\n                scaled = [radii[i]*unit_ball[i]*r for i in range(dim)]\n                rotated = [0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        rotated[j] += basis[i][j]*scaled[i]\n                sample = tuple(center[i] + rotated[i] for i in range(dim))\n                # clamp sample inside bounds\n                clamped = tuple(max(0.0,min(bounds[i],sample[i])) for i in range(dim))\n                if not in_obstacle(clamped):\n                    return clamped\n            # fallback uniform\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        # --- Connect two paths properly (avoid duplicate node) ---\n        def connect_paths(n1, n2):\n            p1 = n1.path_from_root()\n            p2 = n2.path_from_root()\n            p2_rev = p2[::-1]\n            if p1[-1] == p2_rev[0]:\n                return p1 + p2_rev[1:]\n            else:\n                return p1 + p2_rev\n\n        # --- Propagate cost updates downstream from a node ---\n        def propagate_costs(node):\n            stack = [node]\n            while stack:\n                cur = stack.pop()\n                for c in cur.children:\n                    old_cost = c.cost\n                    new_cost = cur.cost + dist(cur.position, c.position)\n                    if new_cost + 1e-12 < old_cost:\n                        c.cost = new_cost\n                        stack.append(c)\n\n        # --- Prune subtrees with cost exceeding threshold ---\n        def prune_by_cost(tree, cost_limit, spatial_hash):\n            # Remove nodes whose cost > cost_limit, detach subtree\n            to_remove = []\n            for node in tree:\n                if node.cost > cost_limit:\n                    to_remove.append(node)\n            # Detach nodes from parents and remove from spatial hash & tree list\n            for node in to_remove:\n                if node.parent:\n                    node.parent.remove_child(node)\n                spatial_hash.remove(node)\n            return [n for n in tree if n.cost <= cost_limit]\n\n        # --- Curvature-aware shortcutting of path ---\n        def smooth_shortcut(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            changed = True\n            iters = 0\n            max_iters = self.shortcut_iters\n            while changed and iters < max_iters:\n                changed = False\n                iters += 1\n                i = 0\n                while i < len(path) - 2:\n                    max_j = min(len(path)-1, i + 8 + random.randint(0,5))\n                    if max_j <= i+1:\n                        i += 1\n                        continue\n                    j = random.randint(i+2, max_j)\n                    if not edge_in_obstacle(path[i], path[j]):\n                        # curvature check: removing intermediate points should not increase max curvature a lot\n                        def max_curv(subpath):\n                            if len(subpath) < 3:\n                                return 0.0\n                            max_angle = 0.0\n                            for idx in range(1,len(subpath)-1):\n                                a = subpath[idx-1]\n                                b = subpath[idx]\n                                c = subpath[idx+1]\n                                ang = curvature_penalty(a,b,c)\n                                if ang > max_angle:\n                                    max_angle = ang\n                            return max_angle\n                        old_sub = path[i:j+1]\n                        new_sub = [path[i], path[j]]\n                        old_curv = max_curv(old_sub)\n                        new_curv = max_curv(new_sub)\n                        if new_curv + 0.15 >= old_curv:\n                            # replace intermediate points with direct\n                            path = path[:i+1] + path[j:]\n                            changed = True\n                            break\n                    i += 1\n            return path\n\n        # --- Initialization ---\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        all_nodes = [start_root, goal_root]\n        edges = []\n\n        spatial_start = SpatialHash(bounds, self.step_size*1.5)\n        spatial_goal = SpatialHash(bounds, self.step_size*1.5)\n        spatial_start.insert(start_root)\n        spatial_goal.insert(goal_root)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve_count = 0\n        last_cost = float('inf')\n\n        start_time = time.time()\n        time_limit = 30.0  # Hard-coded limit to avoid infinite runtime if needed\n\n        alpha_curv = 0.04  # curvature penalty weight\n\n        def add_node_to_tree(tree, spatial_hash, pos, c_best):\n            # Get nearest node by spatial hash first (radius 3*step to reduce candidates)\n            neighbors = spatial_hash.nearby(pos, self.step_size*3)\n            if not neighbors:\n                # fallback linear\n                nearest_node = min(tree, key=lambda n: dist(n.position,pos))\n            else:\n                nearest_node = min(neighbors, key=lambda n: dist(n.position,pos))\n            new_pos = steer(nearest_node.position, pos)\n            if (not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position,new_pos)):\n                return None\n\n            n_nodes = len(all_nodes)\n            radius = adaptive_radius(n_nodes, c_best)\n            near_nodes = spatial_hash.nearby(new_pos, radius)\n\n            # Best parent choice with cost + curvature penalty\n            best_parent = nearest_node\n            base_cost = nearest_node.cost + dist(nearest_node.position,new_pos)\n            base_score = base_cost\n            if nearest_node.parent is not None:\n                base_score += alpha_curv * curvature_penalty(nearest_node.parent.position, nearest_node.position, new_pos)\n\n            for cand in near_nodes:\n                if cand == nearest_node:\n                    continue\n                if edge_in_obstacle(cand.position, new_pos):\n                    continue\n                cand_cost = cand.cost + dist(cand.position, new_pos)\n                curv_p = alpha_curv * curvature_penalty(cand.parent.position if cand.parent else None, cand.position, new_pos)\n                score = cand_cost + curv_p\n                if score + self.improve_tol < base_score:\n                    best_parent = cand\n                    base_cost = cand_cost\n                    base_score = score\n\n            new_node = Node(new_pos, best_parent, base_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent,new_node))\n            spatial_hash.insert(new_node)\n\n            # Rewire neighbors with propagation\n            rewire_candidates = near_nodes.copy()\n            for nn in rewire_candidates:\n                if nn == best_parent or nn == new_node:\n                    continue\n                if edge_in_obstacle(new_node.position, nn.position):\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, nn.position)\n                if alt_cost + self.improve_tol < nn.cost:\n                    # check curvature penalty does not worsen too much\n                    curv_new = alpha_curv * curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, nn.position)\n                    curv_old = 0.0\n                    if nn.parent:\n                        curv_old = alpha_curv * curvature_penalty(\n                            nn.parent.parent.position if nn.parent and nn.parent.parent else None,\n                            nn.parent.position if nn.parent else None,\n                            nn.position)\n                    if curv_new <= curv_old + 0.15:\n                        # Remove old connection\n                        if nn.parent:\n                            nn.parent.remove_child(nn)\n                            try:\n                                edges.remove((nn.parent, nn))\n                            except Exception:\n                                pass\n                        new_node.add_child(nn)\n                        nn.cost = alt_cost\n                        edges.append((new_node, nn))\n                        # propagate cost reductions downstream\n                        propagate_costs(nn)\n            return new_node\n\n        for it in range(self.max_iter):\n            if time.time()-start_time > time_limit:\n                break\n            sample = informed_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate tree expansion\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n                spatial_a, spatial_b = spatial_start, spatial_goal\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n                spatial_a, spatial_b = spatial_goal, spatial_start\n\n            new_node = add_node_to_tree(tree_a, spatial_a, sample, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                continue\n\n            # Try to connect to other tree nearest node within step_size\n            near_others = spatial_b.nearby(new_node.position, self.step_size)\n            connect_node = None\n            min_connect_cost = float('inf')\n            for other in near_others:\n                if edge_in_obstacle(new_node.position, other.position):\n                    continue\n                cost_conn = new_node.cost + dist(new_node.position, other.position) + other.cost\n                if cost_conn + self.improve_tol < min_connect_cost:\n                    min_connect_cost = cost_conn\n                    connect_node = other\n\n            if connect_node is not None:\n                candidate_path = connect_paths(new_node, connect_node)\n                if min_connect_cost + self.improve_tol < best_cost:\n                    best_cost = min_connect_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            # Prune bigger tree by cost to cap tree growth and focus\n            if found_solution:\n                cost_limit = best_cost * self.prune_factor\n                # Prune start tree\n                old_len = len(start_tree)\n                start_tree = prune_by_cost(start_tree, cost_limit, spatial_start)\n                # Prune goal tree\n                goal_tree = prune_by_cost(goal_tree, cost_limit, spatial_goal)\n\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n            if found_solution and best_cost + self.improve_tol < last_cost:\n                last_cost = best_cost\n                no_improve_count = 0\n\n        if found_solution and len(best_path) >= 3:\n            # Comprehensive multi-pass shortcutting for smoothness and length\n            for _ in range(4):\n                best_path = smooth_shortcut(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
                "objective": -8.46741,
                "time_improvement": 30.0,
                "length_improvement": -2.0,
                "smoothness_improvement": 108.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.030727267265319824,
                        "num_nodes_avg": 163.7,
                        "path_length_avg": 186.81883338886328,
                        "smoothness_avg": 0.013631702573822752,
                        "success_improvement": 0.0,
                        "time_improvement": -26.525493199032006,
                        "length_improvement": -2.3983629142914733,
                        "smoothness_improvement": 113.36574699625702,
                        "objective_score": -8.8298369733032
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.04280557632446289,
                        "num_nodes_avg": 302.4,
                        "path_length_avg": 294.78505801978025,
                        "smoothness_avg": 0.007964267692389278,
                        "success_improvement": 0.0,
                        "time_improvement": 73.48929705874362,
                        "length_improvement": 1.5922627155612725,
                        "smoothness_improvement": 104.92634415532672,
                        "objective_score": 23.52677846773648
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.028551006317138673,
                        "num_nodes_avg": 256.7,
                        "path_length_avg": 156.9112833231646,
                        "smoothness_avg": 0.0161871248427108,
                        "success_improvement": 0.0,
                        "time_improvement": 42.34534556221564,
                        "length_improvement": -4.213003070863833,
                        "smoothness_improvement": 105.89903319001093,
                        "objective_score": 10.705296992096448
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "An enhanced bidirectional RRT* planner with adaptive variable step steering, relaxed curvature-aware rewiring, and dynamic pruning thresholds preserving promising shortcuts and global path optimality. The planner balances exploration and exploitation via alternate tree growth, ellipsoidal informed sampling post initial solution, and accelerated neighbor search via spatial hashing. It updates parents and rewires neighbors based on combined cost and softened curvature penalties, while dynamically adjusting pruning to maintain connectivity and prevent premature subtree removal. Multi-stage iterative global shortcutting with curvature checks refines path smoothness and length.",
            "planning_mechanism": "The planner grows start and goal trees alternately using spatial hashing for efficient neighbor queries. Sampling transitions from uniform to ellipsoidal informed after a first feasible path is found. Steering step size adapts per local edge length and obstacle distance to allow finer refinement when needed. Parent selection and rewiring minimize sum of Euclidean cost plus a softened curvature penalty, favoring shorter, smoother connections. Pruning thresholds adapt dynamically to preserve potentially beneficial subtrees and maintain tree connectivity, preventing degradation of path quality. The final solution undergoes progressive global shortcutting smoothing with curvature checks to optimize length and smoothness before returning.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 initial_step=6.5,\n                 min_step=1.2,\n                 max_step=12.0,\n                 n_near_const=25,\n                 max_no_improve=75,\n                 improve_tol=1e-7,\n                 shortcut_iters=450,\n                 prune_factor_init=1.8,\n                 prune_factor_min=1.2):\n        self.max_iter = max_iter\n        self.initial_step = initial_step\n        self.min_step = min_step\n        self.max_step = max_step\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n        self.prune_factor_init = prune_factor_init\n        self.prune_factor_min = prune_factor_min\n\n    def plan(self, map):\n        import math, random, time\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is3d = (dim == 3)\n        dist = lambda a,b: math.dist(a,b)\n\n        # Collision checking\n        def in_obstacle(p):\n            px = (p + (0,0,0))[:3]\n            for o in obstacles:\n                if is3d:\n                    ox, oy, oz, ow, oh, od = o\n                    if ox <= px[0] <= ox+ow and oy <= px[1] <= oy+oh and oz <= px[2] <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = o\n                    if ox <= px[0] <= ox+ow and oy <= px[1] <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,res=1.0):\n            d = dist(a,b)\n            if d < 1e-14:\n                return False\n            steps = max(2,int(d/res))\n            for i in range(steps+1):\n                interp = tuple(a[j] + (b[j]-a[j]) * i/steps for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def in_bounds(pos):\n            for i in range(dim):\n                if pos[i] < 0 or pos[i] > bounds[i]:\n                    return False\n            return True\n\n        # Spatial hashing neighbor search\n        class SpatialHash:\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.inv = 1.0 / cell_size\n                self.dim = len(bounds)\n                self.bounds = bounds\n                self.cells = {}\n            def _coords(self,pos):\n                return tuple(int(pos[i]*self.inv) for i in range(self.dim))\n            def insert(self,n):\n                c = self._coords(n.position)\n                self.cells.setdefault(c, []).append(n)\n            def remove(self,n):\n                c = self._coords(n.position)\n                if c in self.cells and n in self.cells[c]:\n                    self.cells[c].remove(n)\n                    if not self.cells[c]:\n                        del self.cells[c]\n            def nearby(self,pos,radius):\n                c = self._coords(pos)\n                r_cells = int(math.ceil(radius*self.inv))\n                neighbors = []\n                deltas = []\n                def gen_deltas(dim,r):\n                    if dim == 1:\n                        return [(dx,) for dx in range(-r,r+1)]\n                    else:\n                        prev = gen_deltas(dim-1,r)\n                        full = []\n                        for dx in range(-r,r+1):\n                            for p in prev:\n                                full.append((dx,)+p)\n                        return full\n                deltas = gen_deltas(self.dim,r_cells)\n                r_sq = radius*radius\n                for d in deltas:\n                    cell = tuple(c[i]+d[i] for i in range(self.dim))\n                    if cell in self.cells:\n                        for n in self.cells[cell]:\n                            s = 0.0\n                            p = n.position\n                            for i in range(self.dim):\n                                diff = p[i]-pos[i]\n                                s += diff*diff\n                                if s > r_sq:\n                                    break\n                            if s <= r_sq:\n                                neighbors.append(n)\n                return neighbors\n\n        # Adaptive steering with dynamic step size based on local collision proximity\n        def adaptive_steer(frm, to, max_step):\n            d = dist(frm,to)\n            if d < self.min_step:\n                return to\n            step = min(max_step, d)\n            ratio = step/d\n            point = tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n            # check collision along smaller step approx\n            # if close to obstacle, reduce step more\n            # zoom factor handled in plan main loop\n            return point\n\n        # Curvature penalty (softened)\n        def curvature_penalty(p0, p1, p2):\n            if p0 is None or p1 is None or p2 is None:\n                return 0.0\n            v1 = [p1[i]-p0[i] for i in range(dim)]\n            v2 = [p2[i]-p1[i] for i in range(dim)]\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim)) / (len1*len2)\n            dot = max(-1.0,min(1.0,dot))\n            angle = math.acos(dot)\n            return angle\n\n        # Adaptive rewiring radius using n_near_const and tree size\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes == 0:\n                return self.initial_step * 5.5\n            gamma = self.n_near_const\n            r = min((gamma * (math.log(n_nodes) / n_nodes))**(1.0/dim), self.max_step * 6.3)\n            if c_best == float('inf'):\n                return r\n            shrink = max(0.3, c_best / (c_min * 2.8))\n            return max(self.min_step * 0.7, r * shrink)\n\n        # Ellipsoidal informed sampling after a solution found\n        def informed_sample(c_best):\n            if not found_solution or c_best == float('inf') or c_min < 1e-14:\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            center = tuple((start_pos[i] + goal_pos[i])*0.5 for i in range(dim))\n            a1 = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n            basis = [unit_a1]\n            for k in range(1,dim):\n                vec = [0]*dim\n                vec[(k)%dim] = 1\n                for b in basis:\n                    proj = sum(vec[i]*b[i] for i in range(dim))\n                    vec = [vec[i] - proj*b[i] for i in range(dim)]\n                norm = math.sqrt(sum(x*x for x in vec))\n                if norm > 1e-14:\n                    vec = [x/norm for x in vec]\n                    basis.append(vec)\n                else:\n                    basis.append([0]*dim)\n            r1 = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(max(0,val)) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n            max_tries = 50\n            for _ in range(max_tries):\n                sample_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in sample_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x/norm_ball for x in sample_ball]\n                r = random.random()**(1/dim)\n                scaled = [radii[i]*unit_ball[i]*r for i in range(dim)]\n                rotated = [0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        rotated[j] += basis[i][j]*scaled[i]\n                sample_raw = tuple(center[i] + rotated[i] for i in range(dim))\n                sample_clamped = tuple(max(0.0,min(bounds[i],sample_raw[i])) for i in range(dim))\n                if not in_obstacle(sample_clamped):\n                    return sample_clamped\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        # Connect two paths reversing second tree path\n        def connect_paths(node_s, node_g):\n            p1 = node_s.path_from_root()\n            p2 = node_g.path_from_root()[::-1]\n            if p1[-1] == p2[0]:\n                return p1 + p2[1:]\n            return p1 + p2\n\n        # Move new node selection with adaptive step size (smaller if near obstacles)\n        def local_steer_near(frm, to):\n            # Try largest step first\n            step = self.initial_step\n            d = dist(frm, to)\n            if d <= self.min_step:\n                return to, step\n            step = min(d, step)\n            candidate = adaptive_steer(frm, to, step)\n            # If collision edge found, reduce step until free or min_step reached\n            for attempt in range(5):\n                if not edge_in_obstacle(frm, candidate):\n                    return candidate, step\n                step /= 2.0\n                if step < self.min_step:\n                    break\n                candidate = adaptive_steer(frm, to, step)\n            # fallback directly to nearest free point close to frm that isn't in obstacle\n            if not in_obstacle(candidate) and in_bounds(candidate):\n                return candidate, step\n            return None, None\n\n        # Update costs downstream upon rewiring subtree root change\n        def propagate_costs(root):\n            stack = [root]\n            while stack:\n                curr = stack.pop()\n                for c in curr.children:\n                    prev_cost = c.cost\n                    new_cost = curr.cost + dist(curr.position, c.position)\n                    if new_cost + 1e-12 < prev_cost:\n                        c.cost = new_cost\n                        stack.append(c)\n\n        # Prune considering connectivity: only prune nodes whose cost too high and subtree leaf or disconnected; avoid pruning nodes critical to connectivity\n        def prune_tree(tree, cost_limit, spatial_hash):\n            to_remove = [n for n in tree if n.cost > cost_limit]\n            removed = set()\n            def can_prune(n):\n                # Prune only if leaf or no children or no connections to best path\n                if n.children:\n                    return False\n                return True\n            for n in to_remove:\n                if can_prune(n):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                    spatial_hash.remove(n)\n                    removed.add(n)\n            # rebuild tree list without removed\n            new_tree = [n for n in tree if n not in removed]\n            return new_tree\n\n        # Smoothing and shortcutting with curvature-aware pruning (multi pass)\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            pts = list(path)\n            changed = True\n            iter_count = 0\n            max_iters = self.shortcut_iters\n            while changed and iter_count < max_iters:\n                changed = False\n                iter_count += 1\n                i = 0\n                while i < len(pts) - 2:\n                    max_j = min(len(pts)-1, i + 8 + random.randint(0,4))\n                    if max_j <= i + 1:\n                        i += 1\n                        continue\n                    j = random.randint(i+2, max_j)\n                    if not edge_in_obstacle(pts[i], pts[j]):\n                        def max_curv(pth):\n                            if len(pth) < 3:\n                                return 0.0\n                            max_ang = 0.0\n                            for idx in range(1, len(pth)-1):\n                                ang = curvature_penalty(pth[idx-1], pth[idx], pth[idx+1])\n                                if ang > max_ang:\n                                    max_ang = ang\n                            return max_ang\n                        old_sub = pts[i:j+1]\n                        new_sub = [pts[i], pts[j]]\n                        old_c = max_curv(old_sub)\n                        new_c = max_curv(new_sub)\n                        if new_c <= old_c + 0.18:\n                            pts = pts[:i+1] + pts[j:]\n                            changed = True\n                            break\n                    i += 1\n            return pts\n\n        # Initialization\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        all_nodes = [start_root, goal_root]\n        edges = []\n        spatial_start = SpatialHash(bounds, self.initial_step * 1.5)\n        spatial_goal = SpatialHash(bounds, self.initial_step * 1.5)\n        spatial_start.insert(start_root)\n        spatial_goal.insert(goal_root)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve = 0\n        last_cost = float('inf')\n\n        start_time = time.time()\n        time_limit = 30.0  # seconds hard limit\n\n        alpha_curv = 0.025  # relaxed curvature weight\n\n        # Dynamic pruning factor that reduces if no improvement for many iterations\n        prune_factor = self.prune_factor_init\n\n        def add_node(tree, spatial_hash, sample_point, current_best_cost):\n            # Nearest candidate nodes within roughly 3*step\n            candidates = spatial_hash.nearby(sample_point, self.max_step * 3.5)\n            if not candidates:\n                nearest = min(tree, key=lambda n: dist(n.position, sample_point))\n            else:\n                nearest = min(candidates, key=lambda n: dist(n.position, sample_point))\n\n            new_pos, used_step = local_steer_near(nearest.position, sample_point)\n            if new_pos is None:\n                return None\n\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(all_nodes)\n            radius = adaptive_radius(n_nodes, current_best_cost)\n            near_nodes = spatial_hash.nearby(new_pos, radius)\n\n            # Parent selection with softened curvature penalty and cost balancing\n            best_parent = nearest\n            base_cost = nearest.cost + dist(nearest.position, new_pos)\n            base_score = base_cost\n            if nearest.parent is not None:\n                base_score += alpha_curv * curvature_penalty(nearest.parent.position, nearest.position, new_pos)\n\n            for cand in near_nodes:\n                if cand == nearest:\n                    continue\n                if edge_in_obstacle(cand.position, new_pos):\n                    continue\n                cand_cost = cand.cost + dist(cand.position, new_pos)\n                curvature_p = 0.0\n                if cand.parent is not None:\n                    curvature_p = alpha_curv * curvature_penalty(cand.parent.position, cand.position, new_pos)\n                score = cand_cost + curvature_p\n                if score + self.improve_tol < base_score:\n                    best_parent = cand\n                    base_cost = cand_cost\n                    base_score = score\n\n            new_node = Node(new_pos, best_parent, base_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            spatial_hash.insert(new_node)\n\n            # Rewiring neighbors: allow a softened curvature increase threshold to help reduce path length\n            for near_n in near_nodes:\n                if near_n == best_parent or near_n == new_node:\n                    continue\n                if edge_in_obstacle(new_node.position, near_n.position):\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost:\n                    curv_new = 0.0\n                    if new_node.parent is not None:\n                        curv_new = alpha_curv * curvature_penalty(new_node.parent.position, new_node.position, near_n.position)\n                    curv_old = 0.0\n                    if near_n.parent is not None:\n                        pp = near_n.parent.parent.position if near_n.parent.parent else None\n                        curv_old = alpha_curv * curvature_penalty(pp, near_n.parent.position, near_n.position)\n                    # Relaxed curvature threshold to allow beneficial rewiring (up to +0.25 rad)\n                    if curv_new <= curv_old + 0.25:\n                        # Rewire\n                        if near_n.parent:\n                            near_n.parent.remove_child(near_n)\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_n)\n                        near_n.cost = alt_cost\n                        edges.append((new_node, near_n))\n                        propagate_costs(near_n)\n            return new_node\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > time_limit:\n                break\n\n            sample = informed_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate tree expansions\n            if it % 2 == 0:\n                active_tree, active_sh = start_tree, spatial_start\n                other_tree, other_sh = goal_tree, spatial_goal\n            else:\n                active_tree, active_sh = goal_tree, spatial_goal\n                other_tree, other_sh = start_tree, spatial_start\n\n            new_node = add_node(active_tree, active_sh, sample, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve += 1\n                continue\n\n            # Try connect new node to the other tree within max step-size\n            near_others = other_sh.nearby(new_node.position, self.max_step)\n            connect_candidate = None\n            min_conn_cost = float('inf')\n            for other_node in near_others:\n                if edge_in_obstacle(new_node.position, other_node.position):\n                    continue\n                candidate_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if candidate_cost + self.improve_tol < min_conn_cost:\n                    min_conn_cost = candidate_cost\n                    connect_candidate = other_node\n\n            if connect_candidate is not None:\n                candidate_path = connect_paths(new_node, connect_candidate)\n                if min_conn_cost + self.improve_tol < best_cost:\n                    best_cost = min_conn_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve = 0\n                else:\n                    if found_solution:\n                        no_improve += 1\n            else:\n                if found_solution:\n                    no_improve += 1\n\n            # Adjust pruning factor to relax pruning with no improvement and tighten when improving\n            if found_solution:\n                if no_improve > self.max_no_improve // 2:\n                    prune_factor = min(prune_factor * 1.03, self.prune_factor_init)\n                else:\n                    prune_factor = max(prune_factor * 0.995, self.prune_factor_min)\n                cost_thres = best_cost * prune_factor\n                start_tree = prune_tree(start_tree, cost_thres, spatial_start)\n                goal_tree = prune_tree(goal_tree, cost_thres, spatial_goal)\n\n            if found_solution and no_improve >= self.max_no_improve:\n                break\n\n            if found_solution and best_cost + self.improve_tol < last_cost:\n                last_cost = best_cost\n                no_improve = 0\n\n        if found_solution and len(best_path) >= 3:\n            # Multi-pass shortcutting to improve smoothness and length\n            for _ in range(5):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        return PlannerResult(False, [], all_nodes, edges)",
            "objective": 9.866,
            "time_improvement": -87.0,
            "length_improvement": 15.0,
            "smoothness_improvement": 1458.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.07445192337036133,
                    "num_nodes_avg": 179.5,
                    "path_length_avg": 160.6737903359244,
                    "smoothness_avg": 0.04659737117948082,
                    "success_improvement": 0.0,
                    "time_improvement": -206.57026030698847,
                    "length_improvement": 11.93214947774344,
                    "smoothness_improvement": 629.350046769958,
                    "objective_score": -51.665038171600685
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09158942699432374,
                    "num_nodes_avg": 327.6,
                    "path_length_avg": 241.5817258755858,
                    "smoothness_avg": 0.09328713232625183,
                    "success_improvement": 0.0,
                    "time_improvement": 43.27607989198422,
                    "length_improvement": 19.353066358299873,
                    "smoothness_improvement": 2300.3451067599526,
                    "objective_score": 36.09638931637495
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09833176136016845,
                    "num_nodes_avg": 341.7,
                    "path_length_avg": 129.68727327043848,
                    "smoothness_avg": 0.12138410655272378,
                    "success_improvement": 0.0,
                    "time_improvement": -98.56686165475072,
                    "length_improvement": 13.867888138105963,
                    "smoothness_improvement": 1443.996875707893,
                    "objective_score": -14.029341235022173
                }
            ],
            "success_rate": 1.0
        },
        "objective": -5.3999999999999915,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Fixed and relatively large steering step size limiting fine local refinements near obstacles, causing frequent failed expansions and reducing planning efficiency.\n   - Rewiring curvature constraints were rigid, restricting beneficial parent changes and thus limiting path shortening opportunities.\n   - Pruning methods strictly removed all nodes exceeding cost thresholds without considering node connectivity, leading to repetitive costly repairs and larger search trees increasing runtime.\n   - Obstacle collision checks with fine interpolation and naive neighbor searches induced computational overhead during neighborhood queries and edge validations.\n   - Shortcutting smoothing was effective but conservative and limited in pass number, possibly leaving room for improvement in final path quality."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Introduction of adaptive, variable steering step size dynamically reducing near obstacles improved exploration success and local refinements.\n   - Relaxation of curvature penalty thresholds during rewiring enabled more rewiring opportunities, facilitating shorter and smoother paths.\n   - Adaptive, connectivity-aware pruning reduced unnecessary subtree removals, preserving critical nodes for faster convergence.\n   - Enhanced neighbor search radius and improved spatial hashing parameters for efficient node retrieval and rewiring.\n   - Increased shortcutting iterations with curvature-aware smoothing produced significantly smoother and shorter trajectories.\n\n2. Expected mechanism of impact:\n   - Adaptive steering allowed the planner to better navigate tight spaces reducing failed expansions and wasted iterations, resulting in faster planning times.\n   - Softer curvature constraints during rewiring let the tree restructure for cost-effective and smoother connections, thereby improving path length and smoothness.\n   - Connectivity-preserving pruning kept essential nodes longer, reducing overhead from rebuilding connectivity and enabling stable rapid convergence.\n   - Optimized spatial hashing and neighbor radius parameters decreased search cost, lowering computation time during nearest and near neighbor queries.\n   - Multiple passes of curvature-aware shortcutting refined the final path by removing redundant waypoints and smoothing sharp turns, boosting smoothness as measured."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "An improved bidirectional RRT* variant with systematic alternating tree expansions, adaptive rewiring radius, and ellipsoidal informed sampling to focus search. The planner emphasizes efficient parent selection, dynamic rewiring, early stopping on stagnation, and robust tree connection, producing shorter, smoother paths with reduced computation times.",
                "planning_mechanism": "The planner grows two trees from start and goal with alternate expansions. Initially samples uniformly, switches to ellipsoidal informed sampling after first solution to concentrate on promising regions. Each new node selects best parent minimizing cost and performs local rewiring within an adaptive radius that reduces over time. Attempts direct connection between trees after each insertion. Tracks best path and stops early if no improvement occurs over a threshold.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=5.0,\n                 max_radius=20.0,\n                 min_radius=5.0,\n                 improvement_tol=1e-6,\n                 max_no_improve=80,\n                 time_limit=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.improvement_tol = improvement_tol\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,res=1.0):\n            dist = math.dist(a,b)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist/res))\n            for i in range(steps+1):\n                interp = tuple(a[d]+(b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d]-from_p[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n, iter_i):\n            factor = max(0.0, 1.0 - iter_i / self.max_iter)\n            radius = max(self.min_radius, min(self.max_radius, self.max_radius*factor*(math.log(n+1)/(n+1))**(1/dim)))\n            return radius\n\n        def neighbors(tree, pos, radius):\n            r_sq = radius*radius\n            return [node for node in tree if sum((node.position[d]-pos[d])**2 for d in range(dim)) <= r_sq]\n\n        def choose_parent(tree, pos, iter_i):\n            n = len(tree)\n            r = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, pos, r)\n            nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n            min_cost = nearest.cost + math.dist(nearest.position, pos)\n            best_parent = nearest\n            for nb in nbrs:\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                c = nb.cost + math.dist(nb.position, pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = nb\n            new_node = Node(pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                if edge_in_obstacle(pivot.position, nb.position):\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n        def direct_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist_to_target = math.dist(nearest.position, target_node.position)\n            if dist_to_target <= self.step_size:\n                if not edge_in_obstacle(nearest.position, target_node.position) and not in_obstacle(target_node.position):\n                    new_node = Node(target_node.position, cost=nearest.cost + dist_to_target)\n                    nearest.add_child(new_node)\n                    tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((nearest, new_node))\n                    return new_node\n                return None\n            current = nearest\n            steps = int(math.ceil(dist_to_target / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos)):\n                    return None\n                new_node, nbrs = choose_parent(tree, new_pos, 0)\n                rewire(new_node, nbrs)\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    if not edge_in_obstacle(new_node.position, target_node.position) and not in_obstacle(target_node.position):\n                        final_node = Node(target_node.position, cost=new_node.cost + math.dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed():\n            if not found_solution or best_cost == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = best_cost * 0.5\n            val = best_cost*best_cost - c_min*c_min\n            val = max(val, 0.0)\n            r_other = math.sqrt(val)*0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1,b2)\n                basis = (a1,b2,b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random()**(1/dim)\n                    return [v*r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, it)\n            rewire(new_node, nbrs)\n\n            meet_node = direct_connect(tree_b, new_node)\n            if meet_node is not None:\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = sum(math.dist(merged_path[i], merged_path[i+1]) for i in range(len(merged_path)-1))\n                if total_cost + self.improvement_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
                "objective": -16.08771,
                "time_improvement": 40.0,
                "length_improvement": 6.0,
                "smoothness_improvement": 87.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.013728570938110352,
                        "num_nodes_avg": 139.3,
                        "path_length_avg": 162.96103402000978,
                        "smoothness_avg": 0.01309373526123321,
                        "success_improvement": 0.0,
                        "time_improvement": 43.469941734038215,
                        "length_improvement": 10.678474970800728,
                        "smoothness_improvement": 104.9453903395135,
                        "objective_score": 19.97279445438947
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03920111656188965,
                        "num_nodes_avg": 345.6,
                        "path_length_avg": 293.5609018533765,
                        "smoothness_avg": 0.006549654700066657,
                        "success_improvement": 0.0,
                        "time_improvement": 75.72164083809092,
                        "length_improvement": 2.0009212792884186,
                        "smoothness_improvement": 68.52733295831173,
                        "objective_score": 24.259681683791886
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.048858261108398436,
                        "num_nodes_avg": 341.8,
                        "path_length_avg": 142.5416042258134,
                        "smoothness_avg": 0.014637545538668837,
                        "success_improvement": 0.0,
                        "time_improvement": 1.337762692279919,
                        "length_improvement": 5.330653575009229,
                        "smoothness_improvement": 86.18849882064363,
                        "objective_score": 4.030663446792731
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m2",
                "algorithm_description": "This algorithm is an enhanced bidirectional RRT* variant utilizing adaptive neighbor radius based on tree size and iteration progress for improved rewiring efficiency and path optimality. It integrates an ellipsoidal informed sampling strategy after the initial solution to focus exploration within promising regions. The adaptive neighbor radius dynamically contracts with iterations, balancing exploration and exploitation. The connect procedure attempts direct connections to reduce unnecessary intermediate nodes, improving path length and smoothness. Early stopping criteria based on solution improvement stagnation reduce planning time. Consistent node and edge collision checks prevent invalid expansions, maintaining robustness. The algorithm outputs the lowest cost path found within time and iteration limits.",
                "planning_mechanism": "The planner grows two trees from start and goal positions, alternating expansions each iteration. Initially, it samples uniformly, then focuses sampling inside an ellipsoid defined by current best path cost. Each expansion attempts to add a new node via steering and selects the best parent considering nodes within an adaptive radius that decreases as iterations proceed. Local rewiring optimizes neighbors' connections when beneficial. A direct connect is attempted between the newly added node and the opposite tree to quickly form a solution. The best path is updated when trees meet. The planning stops early if no significant improvements occur over a threshold or upon timeout.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # cost from root to this node\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=4.0,\n        max_neighbor_radius=30.0,\n        min_neighbor_radius=6.0,\n        improvement_tol=1e-6,\n        max_no_improve=100,\n        time_limit_sec=30.0,\n        post_opt_iters=300\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n        self.improvement_tol = improvement_tol\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.post_opt_iters = post_opt_iters\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_first = False\n        no_improve_count = 0\n        post_opt_count = 0\n        start_time = time.time()\n\n        def adaptive_radius(n, iter_i):\n            # Adaptive radius contracts as iteration increases, ensuring fewer neighbors later for efficiency\n            # Weighted blend with tree size and iteration progress\n            factor = max(0.0, 1.0 - iter_i / self.max_iter)\n            radius = max(self.min_neighbor_radius, min(self.max_neighbor_radius, self.max_neighbor_radius*factor*(math.log(n+1)/(n+1))**(1/dim)))\n            return radius\n\n        def within_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_p, to_p, resolution=1.0):\n            dist = math.dist(from_p, to_p)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d])*i/steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def neighbors(tree, pos, radius):\n            radius_sq = radius*radius\n            return [n for n in tree if ( (sum((n.position[d] - pos[d])**2 for d in range(dim))) <= radius_sq )]\n\n        def choose_parent_and_add(tree, new_pos, iter_i):\n            n = len(tree)\n            radius = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, new_pos, radius)\n\n            nearest = min(tree, key=lambda node: math.dist(node.position, new_pos))\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nb in nbrs:\n                if is_edge_in_obstacle(nb.position, new_pos):\n                    continue\n                c = nb.cost + math.dist(nb.position, new_pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = nb\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, nbrs, radius\n\n        def rewire(pivot, neighbors_list):\n            for nb in neighbors_list:\n                if is_edge_in_obstacle(pivot.position, nb.position):\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # Rewire nb to pivot\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n        def direct_connect(tree, target_node, iter_i):\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            # attempt a direct connection from nearest to target_node if possible\n            if (not is_edge_in_obstacle(nearest.position, target_node.position) and\n                not is_in_obstacle(target_node.position)):\n                # connect with one edge\n                new_node = Node(target_node.position, cost=nearest.cost + math.dist(nearest.position, target_node.position))\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n                return new_node\n\n            # else do incremental connection with steering and rewiring\n            current = nearest\n            for _ in range( int(math.ceil(math.dist(current.position, target_node.position) / self.step_size)) ):\n                new_pos = steer(current.position, target_node.position)\n                if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node, nbrs, _ = choose_parent_and_add(tree, new_pos, iter_i)\n                rewire(new_node, nbrs)\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    if not is_edge_in_obstacle(new_node.position, target_node.position) and not is_in_obstacle(target_node.position):\n                        final_node = Node(target_node.position,\n                                          cost=new_node.cost + math.dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n            return None\n\n        def sample_informed():\n            if not found_first or best_cost == float('inf') or c_min < 1e-12:\n                # uniform sampling\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # else sample inside prolate hyperspheroid:\n            # center\n            center = tuple((start_pos[d] + goal_pos[d])/2.0 for d in range(dim))\n            # unit direction vector from start to goal\n            unit_dir = []\n            dist_sg = c_min\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / dist_sg)\n            # radii\n            r1 = best_cost / 2.0\n            val = best_cost*best_cost - c_min*c_min\n            val = max(val, 0.0)\n            r_other = math.sqrt(val) / 2.0\n\n            # construct orthonormal basis\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                a1 = unit_dir\n                # pick reference vector not parallel to a1\n                ref = (1.0,0.0,0.0) if abs(a1[0]) < 0.9 else (0.0,1.0,0.0)\n                b2 = _cross(a1, ref)\n                n_b2 = _norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0.0,0.0,1.0)\n                    b2 = _cross(a1, ref)\n                    n_b2 = _norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = _cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            u = _sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                # clamp inside bounds\n                val = min(max(val, 0.0), bounds[d])\n                mapped.append(val)\n            return tuple(mapped)\n\n        def _sample_unit_ball(dim):\n            while True:\n                vec = [random.gauss(0.0, 1.0) for _ in range(dim)]\n                nrm = math.sqrt(sum(v*v for v in vec))\n                if nrm < 1e-12:\n                    continue\n                vec = [v/nrm for v in vec]\n                r = random.random()**(1.0/dim)\n                return tuple(vec[i]*r for i in range(dim))\n\n        def _cross(a,b):\n            return (a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0])\n\n        def _norm(v):\n            return math.sqrt(sum(x*x for x in v))\n\n        neighbor_radius_cache = None\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if (it % 2 == 0) else (goal_tree, start_tree)\n            x_rand = sample_informed()\n\n            if not within_bounds(x_rand) or is_in_obstacle(x_rand):\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest.position, new_pos):\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors_list, nradius = choose_parent_and_add(tree_a, new_pos, it)\n            rewire(new_node, neighbors_list)\n\n            # Attempt direct connect (not iterative connect) from tree_b to newly added node:\n            meet_node = direct_connect(tree_b, new_node, it)\n            if meet_node is not None:\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = sum(math.dist(merged_path[i], merged_path[i+1]) for i in range(len(merged_path)-1))\n                if total_cost + self.improvement_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_first = True\n                    post_opt_count = 0\n                    no_improve_count = 0\n                else:\n                    if found_first:\n                        post_opt_count += 1\n                        no_improve_count += 1\n                if found_first and (post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve):\n                    break\n            else:\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(success=found_first, path=best_path, nodes=nodes, edges=edges)",
                "objective": -10.44388,
                "time_improvement": 10.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 142.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.02786121368408203,
                        "num_nodes_avg": 139.4,
                        "path_length_avg": 155.87313188725165,
                        "smoothness_avg": 0.017886324975422283,
                        "success_improvement": 0.0,
                        "time_improvement": -14.723960710972353,
                        "length_improvement": 14.563466444762122,
                        "smoothness_improvement": 179.95982664171103,
                        "objective_score": 5.220690786774123
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.06340575218200684,
                        "num_nodes_avg": 418.9,
                        "path_length_avg": 277.6271906369829,
                        "smoothness_avg": 0.008053558435153495,
                        "success_improvement": 0.0,
                        "time_improvement": 60.731026067193284,
                        "length_improvement": 7.320052709768729,
                        "smoothness_improvement": 107.22385928017246,
                        "objective_score": 23.14745874242008
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.05672965049743652,
                        "num_nodes_avg": 331.4,
                        "path_length_avg": 133.93060882634086,
                        "smoothness_avg": 0.018882342363182564,
                        "success_improvement": 0.0,
                        "time_improvement": -14.557377049180326,
                        "length_improvement": 11.049666707801231,
                        "smoothness_improvement": 140.18200111014838,
                        "objective_score": 2.9634969154773834
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "An enhanced bidirectional RRT* planner that integrates heuristic-guided parent selection and rewiring considering global cost-to-go estimates, adaptive contraction of neighbor radius with iteration and tree size, and improved path merging with shortcutting to minimize redundant nodes. The planner alternates expansions between start and goal trees, uses ellipsoidal informed sampling after first solution, performs rewiring with heuristic cost-to-go to enable better global path cost reduction, and merges start/goal trees via shortcut-aware concatenation to yield shorter, smoother paths efficiently while maintaining robust collision checking and early stopping criteria based on solution improvement stagnation.",
            "planning_mechanism": "The planner alternates tree expansions, samples informed by current best cost, adds new nodes using heuristic cost-to-come plus estimated cost-to-go for parent selection and rewiring decisions, attempts direct connections between opposite trees, and merges paths with shortcutting to reduce unnecessary intermediate nodes. Early stopping is applied on stagnation and timeout while always validating node and edge collisions.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=4.0,\n        max_neighbor_radius=25.0,\n        min_neighbor_radius=5.0,\n        improvement_tol=1e-6,\n        max_no_improve=100,\n        time_limit_sec=30.0,\n        post_opt_iters=300\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n        self.improvement_tol = improvement_tol\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.post_opt_iters = post_opt_iters\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_first = False\n        no_improve_count = 0\n        post_opt_count = 0\n        start_time = time.time()\n\n        def heuristic_cost_to_go(pos):\n            # Euclidean distance to goal for start tree, to start for goal tree (depends on caller)\n            # We'll use this for heuristic-aware rewiring.\n            # We'll pass map_goal accordingly when invoked.\n            # Here return Euclidean distance to goal_pos by default\n            return math.dist(pos, goal_pos)\n\n        def heuristic_cost_to_go_from_goal_tree(pos):\n            # Used when rewiring in goal_tree: heuristic distance to start_pos (goal is \"start\" for goalside)\n            return math.dist(pos, start_pos)\n\n        def within_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_p, to_p, resolution=1.0):\n            dist = math.dist(from_p, to_p)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n, iter_i):\n            factor = max(0.0, 1.0 - iter_i / self.max_iter)\n            base_radius = self.max_neighbor_radius * factor * (math.log(n + 1) / (n + 1))**(1 / dim)\n            radius = max(self.min_neighbor_radius, min(self.max_neighbor_radius, base_radius))\n            return radius\n\n        def neighbors(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if sum((n.position[d] - pos[d])**2 for d in range(dim)) <= radius_sq]\n\n        def heuristic_parent_selection(tree, new_pos, iter_i, tree_type):\n            # tree_type in {'start', 'goal'}\n            n = len(tree)\n            radius = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, new_pos, radius)\n\n            # Compute heuristic cost to go depending on tree type\n            if tree_type == 'start':\n                heuristic_func = heuristic_cost_to_go\n            else:\n                heuristic_func = heuristic_cost_to_go_from_goal_tree\n\n            # For each neighbor, compute: cost_to_come + dist_to_new_pos + heuristic cost_to_go(new_pos)\n            # to minimize cost_to_come + edge + heuristic; used for selection and rewiring\n            # We'll incorporate heuristic later in rewire as well.\n\n            min_total_cost = None\n            best_parent = None\n            for nb in nbrs:\n                if is_edge_in_obstacle(nb.position, new_pos):\n                    continue\n                cost_to_come = nb.cost + math.dist(nb.position, new_pos)\n                cost_total = cost_to_come + heuristic_func(new_pos)\n                if (min_total_cost is None) or (cost_total < min_total_cost):\n                    min_total_cost = cost_total\n                    best_parent = nb\n\n            # If no neighbors or no edge clear, fallback to nearest\n            if best_parent is None:\n                nearest = min(tree, key=lambda node: math.dist(node.position, new_pos))\n                if not is_edge_in_obstacle(nearest.position, new_pos):\n                    cost_to_come = nearest.cost + math.dist(nearest.position, new_pos)\n                    min_total_cost = cost_to_come + heuristic_func(new_pos)\n                    best_parent = nearest\n                else:\n                    # Edge blocked, cannot connect\n                    return None, []\n\n            new_node = Node(new_pos, cost=best_parent.cost + math.dist(best_parent.position, new_pos))\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, nbrs\n\n        def heuristic_rewire(pivot, nbrs, tree_type):\n            # Using heuristic-aware rewiring to improve global path cost\n            # pivot: node just added or rewired\n            # neighbors: nodes to attempt rewiring\n\n            if tree_type == 'start':\n                heuristic_func = heuristic_cost_to_go\n            else:\n                heuristic_func = heuristic_cost_to_go_from_goal_tree\n\n            for nb in nbrs:\n                if nb is pivot or nb is pivot.parent:\n                    continue\n                if is_edge_in_obstacle(pivot.position, nb.position):\n                    continue\n                new_cost_to_come = pivot.cost + math.dist(pivot.position, nb.position)\n                # Compare cost-to-come plus heuristic for nb if rewired\n                if new_cost_to_come + heuristic_func(nb.position) + 1e-12 < nb.cost + heuristic_func(nb.position):\n                    # Rewire nb\n                    old_parent = nb.parent\n                    if old_parent is not None:\n                        try:\n                            edges.remove((old_parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in old_parent.children:\n                            old_parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost_to_come\n                    edges.append((pivot, nb))\n\n        def direct_connect(tree, target_node, iter_i, tree_type):\n            # Try to connect tree to target_node by a straight edge first\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            if not is_edge_in_obstacle(nearest.position, target_node.position) and not is_in_obstacle(target_node.position):\n                new_node = Node(target_node.position, cost=nearest.cost + math.dist(nearest.position, target_node.position))\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n                return new_node\n\n            # Otherwise incremental connect with steering and rewiring\n            current = nearest\n            steps = int(math.ceil(math.dist(current.position, target_node.position) / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node, nbrs = heuristic_parent_selection(tree, new_pos, iter_i, tree_type)\n                if new_node is None:\n                    return None\n                heuristic_rewire(new_node, nbrs, tree_type)\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    if not is_edge_in_obstacle(new_node.position, target_node.position) and not is_in_obstacle(target_node.position):\n                        final_node = Node(target_node.position, cost=new_node.cost + math.dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n            return None\n\n        def sample_informed():\n            if not found_first or best_cost == float('inf') or c_min < 1e-12:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = best_cost / 2.0\n            val = best_cost*best_cost - c_min*c_min\n            val = max(val, 0.0)\n            r_other = math.sqrt(val) / 2.0\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2] - u[2]*v[1], u[2]*v[0] - u[0]*v[2], u[0]*v[1] - u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0.0, 1.0) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random()**(1.0/dim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                val = min(max(val, 0.0), bounds[d])\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            # Attempt to shortcut path by checking if edges between nonadjacent waypoints can be connected directly\n            if len(path) < 3:\n                return path\n            optimized = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        optimized.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    # no shortcut found, add next node\n                    i += 1\n                    if i < len(path):\n                        optimized.append(path[i])\n            # Remove duplicates if any\n            final_path = []\n            last = None\n            for p in optimized:\n                if p != last:\n                    final_path.append(p)\n                    last = p\n            return final_path\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            tree_a_type = 'start' if it % 2 == 0 else 'goal'\n            tree_b_type = 'goal' if tree_a_type == 'start' else 'start'\n\n            x_rand = sample_informed()\n\n            if not within_bounds(x_rand) or is_in_obstacle(x_rand):\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if (not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest.position, new_pos)):\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = heuristic_parent_selection(tree_a, new_pos, it, tree_a_type)\n            if new_node is None:\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n            heuristic_rewire(new_node, nbrs, tree_a_type)\n\n            meet_node = direct_connect(tree_b, new_node, it, tree_b_type)\n            if meet_node is not None:\n                if tree_a_type == 'start':\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                # merge paths with shortcutting to reduce length\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    raw_merged = path_a + path_b[-2::-1]\n                else:\n                    raw_merged = path_a + path_b[::-1]\n\n                merged_path = shortcut_path(raw_merged)\n\n                total_cost = 0.0\n                for i in range(len(merged_path)-1):\n                    total_cost += math.dist(merged_path[i], merged_path[i+1])\n\n                if total_cost + self.improvement_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_first = True\n                    post_opt_count = 0\n                    no_improve_count = 0\n                else:\n                    if found_first:\n                        post_opt_count += 1\n                        no_improve_count += 1\n\n                if found_first and (post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve):\n                    break\n            else:\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(success=found_first, path=best_path, nodes=nodes, edges=edges)",
            "objective": 29.47935,
            "time_improvement": -163.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 1861.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.11461379528045654,
                    "num_nodes_avg": 157.9,
                    "path_length_avg": 156.58550151996783,
                    "smoothness_avg": 0.045537808163026515,
                    "success_improvement": 0.0,
                    "time_improvement": -371.94457125185914,
                    "length_improvement": 14.17300536085118,
                    "smoothness_improvement": 612.7655846845312,
                    "objective_score": -100.01574023562439
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.15397179126739502,
                    "num_nodes_avg": 423.9,
                    "path_length_avg": 238.179942045085,
                    "smoothness_avg": 0.13335331092692398,
                    "success_improvement": 0.0,
                    "time_improvement": 4.640919008248845,
                    "length_improvement": 20.48867971583956,
                    "smoothness_improvement": 3331.2767406572243,
                    "objective_score": 30.34186723526451
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.10994319915771485,
                    "num_nodes_avg": 310.5,
                    "path_length_avg": 126.34830217722636,
                    "smoothness_avg": 0.13661864156688966,
                    "success_improvement": 0.0,
                    "time_improvement": -122.01449170698828,
                    "length_improvement": 16.085473753499823,
                    "smoothness_improvement": 1637.7790365916799,
                    "objective_score": -18.764168077038192
                }
            ],
            "success_rate": 1.0
        },
        "objective": -16.599999999999994,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Use of exhaustive neighbor searches and adaptive radius computations that are costly and scale poorly with node count.\n   - Incremental edge checking in rewiring and direct connection steps leading to significant planning overhead.\n   - Naive path merging without effective shortcutting, resulting in longer and less smooth paths.\n   - Rewiring and parent selection based solely on local cost-to-come without incorporating heuristic cost-to-go, limiting global path quality improvements.\n   - Absence of explicit path smoothing or shortcutting post path construction, contributing to path roughness."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Integration of heuristic-guided parent selection and rewiring that consider both cost-to-come and cost-to-go estimates for better global optimization.\n   - Incorporation of a shortcutting post-processing step during path merging to remove redundant nodes and reduce sharp turns.\n   - Maintaining efficient neighbor queries with adaptive radius control while balancing computational cost.\n   - Alternating expansions between trees with heuristic-informed sampling leading to more directed exploration.\n2. Expected mechanism of impact:\n   - Heuristic-aware rewiring accelerates convergence towards lower-cost, shorter, and smoother paths by more globally informed edge rearrangements.\n   - Shortcutting during path merging reduces unnecessary waypoints, improving both length and smoothness metrics and reducing overall path complexity.\n   - More directed sampling and expansion reduces redundant node expansions, improving planning time.\n   - Efficient neighbor radius adaptation balances exploration vs. rewiring cost to maintain faster runtime without compromising solution quality."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "An improved bidirectional RRT* variant with systematic alternating tree expansions, adaptive rewiring radius, and ellipsoidal informed sampling to focus search. The planner emphasizes efficient parent selection, dynamic rewiring, early stopping on stagnation, and robust tree connection, producing shorter, smoother paths with reduced computation times.",
                "planning_mechanism": "The planner grows two trees from start and goal with alternate expansions. Initially samples uniformly, switches to ellipsoidal informed sampling after first solution to concentrate on promising regions. Each new node selects best parent minimizing cost and performs local rewiring within an adaptive radius that reduces over time. Attempts direct connection between trees after each insertion. Tracks best path and stops early if no improvement occurs over a threshold.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=5.0,\n                 max_radius=20.0,\n                 min_radius=5.0,\n                 improvement_tol=1e-6,\n                 max_no_improve=80,\n                 time_limit=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.improvement_tol = improvement_tol\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,res=1.0):\n            dist = math.dist(a,b)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist/res))\n            for i in range(steps+1):\n                interp = tuple(a[d]+(b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d]-from_p[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n, iter_i):\n            factor = max(0.0, 1.0 - iter_i / self.max_iter)\n            radius = max(self.min_radius, min(self.max_radius, self.max_radius*factor*(math.log(n+1)/(n+1))**(1/dim)))\n            return radius\n\n        def neighbors(tree, pos, radius):\n            r_sq = radius*radius\n            return [node for node in tree if sum((node.position[d]-pos[d])**2 for d in range(dim)) <= r_sq]\n\n        def choose_parent(tree, pos, iter_i):\n            n = len(tree)\n            r = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, pos, r)\n            nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n            min_cost = nearest.cost + math.dist(nearest.position, pos)\n            best_parent = nearest\n            for nb in nbrs:\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                c = nb.cost + math.dist(nb.position, pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = nb\n            new_node = Node(pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                if edge_in_obstacle(pivot.position, nb.position):\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n        def direct_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist_to_target = math.dist(nearest.position, target_node.position)\n            if dist_to_target <= self.step_size:\n                if not edge_in_obstacle(nearest.position, target_node.position) and not in_obstacle(target_node.position):\n                    new_node = Node(target_node.position, cost=nearest.cost + dist_to_target)\n                    nearest.add_child(new_node)\n                    tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((nearest, new_node))\n                    return new_node\n                return None\n            current = nearest\n            steps = int(math.ceil(dist_to_target / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos)):\n                    return None\n                new_node, nbrs = choose_parent(tree, new_pos, 0)\n                rewire(new_node, nbrs)\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    if not edge_in_obstacle(new_node.position, target_node.position) and not in_obstacle(target_node.position):\n                        final_node = Node(target_node.position, cost=new_node.cost + math.dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed():\n            if not found_solution or best_cost == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = best_cost * 0.5\n            val = best_cost*best_cost - c_min*c_min\n            val = max(val, 0.0)\n            r_other = math.sqrt(val)*0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1,b2)\n                basis = (a1,b2,b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random()**(1/dim)\n                    return [v*r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, it)\n            rewire(new_node, nbrs)\n\n            meet_node = direct_connect(tree_b, new_node)\n            if meet_node is not None:\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = sum(math.dist(merged_path[i], merged_path[i+1]) for i in range(len(merged_path)-1))\n                if total_cost + self.improvement_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
                "objective": -16.08771,
                "time_improvement": 40.0,
                "length_improvement": 6.0,
                "smoothness_improvement": 87.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.013728570938110352,
                        "num_nodes_avg": 139.3,
                        "path_length_avg": 162.96103402000978,
                        "smoothness_avg": 0.01309373526123321,
                        "success_improvement": 0.0,
                        "time_improvement": 43.469941734038215,
                        "length_improvement": 10.678474970800728,
                        "smoothness_improvement": 104.9453903395135,
                        "objective_score": 19.97279445438947
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03920111656188965,
                        "num_nodes_avg": 345.6,
                        "path_length_avg": 293.5609018533765,
                        "smoothness_avg": 0.006549654700066657,
                        "success_improvement": 0.0,
                        "time_improvement": 75.72164083809092,
                        "length_improvement": 2.0009212792884186,
                        "smoothness_improvement": 68.52733295831173,
                        "objective_score": 24.259681683791886
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.048858261108398436,
                        "num_nodes_avg": 341.8,
                        "path_length_avg": 142.5416042258134,
                        "smoothness_avg": 0.014637545538668837,
                        "success_improvement": 0.0,
                        "time_improvement": 1.337762692279919,
                        "length_improvement": 5.330653575009229,
                        "smoothness_improvement": 86.18849882064363,
                        "objective_score": 4.030663446792731
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m3",
                "algorithm_description": "An improved bidirectional RRT* variant with systematic alternating tree expansions, adaptive rewiring radius, and ellipsoidal informed sampling to focus search. The planner emphasizes efficient parent selection, dynamic rewiring, early stopping on stagnation, and robust tree connection, producing shorter, smoother paths with reduced computation times.",
                "planning_mechanism": "The planner grows two trees from start and goal with alternate expansions. Initially samples uniformly, switches to ellipsoidal informed sampling after first solution to concentrate on promising regions. Each new node selects best parent minimizing cost and performs local rewiring within an adaptive radius that reduces over time. Attempts direct connection between trees after each insertion. Tracks best path and stops early if no improvement occurs over a threshold.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=5.0,\n                 max_radius=20.0,\n                 min_radius=5.0,\n                 improvement_tol=1e-6,\n                 max_no_improve=80,\n                 time_limit=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.improvement_tol = improvement_tol\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,res=1.0):\n            dist = math.dist(a,b)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist/res))\n            for i in range(steps+1):\n                interp = tuple(a[d]+(b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d]-from_p[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n, iter_i):\n            factor = max(0.0, 1.0 - iter_i / self.max_iter)\n            radius = max(self.min_radius, min(self.max_radius, self.max_radius*factor*(math.log(n+1)/(n+1))**(1/dim)))\n            return radius\n\n        def neighbors(tree, pos, radius):\n            r_sq = radius*radius\n            return [node for node in tree if sum((node.position[d]-pos[d])**2 for d in range(dim)) <= r_sq]\n\n        def choose_parent(tree, pos, iter_i):\n            n = len(tree)\n            r = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, pos, r)\n            nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n            min_cost = nearest.cost + math.dist(nearest.position, pos)\n            best_parent = nearest\n            for nb in nbrs:\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                c = nb.cost + math.dist(nb.position, pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = nb\n            new_node = Node(pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                if edge_in_obstacle(pivot.position, nb.position):\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n        def direct_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            dist_to_target = math.dist(nearest.position, target_node.position)\n            if dist_to_target <= self.step_size:\n                if not edge_in_obstacle(nearest.position, target_node.position) and not in_obstacle(target_node.position):\n                    new_node = Node(target_node.position, cost=nearest.cost + dist_to_target)\n                    nearest.add_child(new_node)\n                    tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((nearest, new_node))\n                    return new_node\n                return None\n            current = nearest\n            steps = int(math.ceil(dist_to_target / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos)):\n                    return None\n                new_node, nbrs = choose_parent(tree, new_pos, 0)\n                rewire(new_node, nbrs)\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    if not edge_in_obstacle(new_node.position, target_node.position) and not in_obstacle(target_node.position):\n                        final_node = Node(target_node.position, cost=new_node.cost + math.dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed():\n            if not found_solution or best_cost == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = best_cost * 0.5\n            val = best_cost*best_cost - c_min*c_min\n            val = max(val, 0.0)\n            r_other = math.sqrt(val)*0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1,b2)\n                basis = (a1,b2,b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random()**(1/dim)\n                    return [v*r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, it)\n            rewire(new_node, nbrs)\n\n            meet_node = direct_connect(tree_b, new_node)\n            if meet_node is not None:\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = sum(math.dist(merged_path[i], merged_path[i+1]) for i in range(len(merged_path)-1))\n                if total_cost + self.improvement_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
                "objective": -16.08771,
                "time_improvement": 40.0,
                "length_improvement": 6.0,
                "smoothness_improvement": 87.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.013728570938110352,
                        "num_nodes_avg": 139.3,
                        "path_length_avg": 162.96103402000978,
                        "smoothness_avg": 0.01309373526123321,
                        "success_improvement": 0.0,
                        "time_improvement": 43.469941734038215,
                        "length_improvement": 10.678474970800728,
                        "smoothness_improvement": 104.9453903395135,
                        "objective_score": 19.97279445438947
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03920111656188965,
                        "num_nodes_avg": 345.6,
                        "path_length_avg": 293.5609018533765,
                        "smoothness_avg": 0.006549654700066657,
                        "success_improvement": 0.0,
                        "time_improvement": 75.72164083809092,
                        "length_improvement": 2.0009212792884186,
                        "smoothness_improvement": 68.52733295831173,
                        "objective_score": 24.259681683791886
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.048858261108398436,
                        "num_nodes_avg": 341.8,
                        "path_length_avg": 142.5416042258134,
                        "smoothness_avg": 0.014637545538668837,
                        "success_improvement": 0.0,
                        "time_improvement": 1.337762692279919,
                        "length_improvement": 5.330653575009229,
                        "smoothness_improvement": 86.18849882064363,
                        "objective_score": 4.030663446792731
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "An advanced bidirectional RRT* variant using KD-tree accelerated neighbor queries for fast nearest neighbor and neighborhood searches, combined with ellipsoidal informed sampling to focus exploration. The planner incorporates adaptive rewiring radius for efficient path cost and smoothness improvement, and performs post-processing path shortcutting to enhance smoothness and reduce length. It alternates tree growth from start and goal, attempts flexible tree connection with incremental steering, and terminates early upon stagnation or time limit.",
            "planning_mechanism": "The planner grows two trees from start and goal, alternating expansions. Early uniform sampling is replaced by ellipsoidal informed sampling after the first solution to focus on relevant regions, accelerating convergence. Each new node is connected to the best parent within an adaptive radius using KD-tree based neighbor search. A rewiring step improves the local tree structure for both cost and smoothness. The planner attempts incremental steering connections between trees to find shortcuts. Once a solution is found, a shortcutting post-processing improves path smoothness and length by attempting to replace piecewise segments with direct collision-free edges. The algorithm terminates early if no improvement occurs over a fixed count or after the time limit, returning the best smooth path found.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=5.0,\n                 max_radius=25.0,\n                 min_radius=5.0,\n                 improvement_tol=1e-6,\n                 max_no_improve=80,\n                 time_limit=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.improvement_tol = improvement_tol\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n        from bisect import bisect_left\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if dim == 3:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b, resolution=1.0):\n            dist = math.dist(a,b)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist/resolution))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d]-from_p[d]) * ratio for d in range(dim))\n\n        # KD-Tree structure for fast neighbor queries\n        class KDTree:\n            def __init__(self, points):\n                self.dim = len(points[0].position) if points else 0\n                self.nodes = points\n\n            def nearest(self, point):\n                best = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    d = 0\n                    for i in range(self.dim):\n                        dd = node.position[i] - point[i]\n                        d += dd*dd\n                        if d > best_dist*best_dist:\n                            break\n                    if d < best_dist*best_dist:\n                        best = node\n                        best_dist = math.sqrt(d)\n                return best\n\n            def radius_search(self, point, radius):\n                r_sq = radius*radius\n                result = []\n                for node in self.nodes:\n                    d = 0\n                    for i in range(self.dim):\n                        dd = node.position[i] - point[i]\n                        d += dd*dd\n                        if d > r_sq:\n                            break\n                    if d <= r_sq:\n                        result.append(node)\n                return result\n\n            def add(self, node):\n                self.nodes.append(node)\n\n        def adaptive_radius(n, iter_i):\n            if n == 0:\n                return self.max_radius\n            factor = max(0.0, 1.0 - iter_i / self.max_iter)\n            return max(self.min_radius,\n                       min(self.max_radius,\n                           self.max_radius * factor * (math.log(n+1)/(n+1))**(1/dim)\n                          )\n                      )\n\n        def choose_parent(tree_kdtree, tree_nodes, pos, iter_i):\n            n = len(tree_nodes)\n            r = adaptive_radius(n, iter_i)\n            nbrs = tree_kdtree.radius_search(pos, r)\n            nearest = tree_kdtree.nearest(pos)\n            min_cost = nearest.cost + math.dist(nearest.position, pos)\n            best_parent = nearest\n            for nb in nbrs:\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                c = nb.cost + math.dist(nb.position, pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = nb\n            new_node = Node(pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            tree_kdtree.add(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                if edge_in_obstacle(pivot.position, nb.position):\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n        def direct_connect(tree_kdtree, tree_nodes, target_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_kdtree.nearest(target_node.position)\n            dist_to_target = math.dist(nearest.position, target_node.position)\n            if dist_to_target <= self.step_size:\n                if (not edge_in_obstacle(nearest.position, target_node.position) and\n                    not in_obstacle(target_node.position)):\n                    new_node = Node(target_node.position, cost=nearest.cost + dist_to_target)\n                    nearest.add_child(new_node)\n                    tree_nodes.append(new_node)\n                    tree_kdtree.add(new_node)\n                    edges.append((nearest, new_node))\n                    return new_node\n                return None\n            current = nearest\n            steps = int(math.ceil(dist_to_target / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos)):\n                    return None\n                new_node, nbrs = choose_parent(tree_kdtree, tree_nodes, new_pos, 0)\n                rewire(new_node, nbrs)\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    if (not edge_in_obstacle(new_node.position, target_node.position) and\n                        not in_obstacle(target_node.position)):\n                        final_node = Node(target_node.position,\n                                          cost=new_node.cost + math.dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree_nodes.append(final_node)\n                        tree_kdtree.add(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed():\n            if not found_solution or best_cost == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = best_cost * 0.5\n            val = best_cost*best_cost - c_min*c_min\n            val = max(val, 0.0)\n            r_other = math.sqrt(val)*0.5 if val > 0 else 0.0\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1,b2)\n                basis = (a1,b2,b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random()**(1/dim)\n                    return [v*r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path) - 1\n                while j > i+1:\n                    if (not edge_in_obstacle(path[i], path[j]) and\n                        in_bounds(path[j]) and not in_obstacle(path[j])):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        start_kdtree = KDTree(start_tree[:])\n        goal_kdtree = KDTree(goal_tree[:])\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            kdtree_a = start_kdtree if it % 2 == 0 else goal_kdtree\n            kdtree_b = goal_kdtree if it % 2 == 0 else start_kdtree\n\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = kdtree_a.nearest(x_rand)\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(kdtree_a, tree_a, new_pos, it)\n            rewire(new_node, nbrs)\n\n            meet_node = direct_connect(kdtree_b, tree_b, new_node)\n            if meet_node is not None:\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = sum(math.dist(merged_path[i], merged_path[i+1]) for i in range(len(merged_path)-1))\n\n                # Post-process path shortcutting for smoothness and shorter length\n                smoothed_path = shortcut_path(merged_path)\n                smoothed_cost = sum(math.dist(smoothed_path[i], smoothed_path[i+1]) for i in range(len(smoothed_path)-1))\n\n                if smoothed_cost + self.improvement_tol < best_cost:\n                    best_cost = smoothed_cost\n                    best_path = smoothed_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
            "objective": 36.83489,
            "time_improvement": -186.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 1740.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.131825852394104,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 164.86214914222285,
                    "smoothness_avg": 0.05477585570849506,
                    "success_improvement": 0.0,
                    "time_improvement": -442.81856067857507,
                    "length_improvement": 9.63644364721884,
                    "smoothness_improvement": 757.3610895124422,
                    "objective_score": -123.276896567679
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.11904773712158204,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 236.6589583478829,
                    "smoothness_avg": 0.12534880184330177,
                    "success_improvement": 0.0,
                    "time_improvement": 26.270372562291577,
                    "length_improvement": 20.996427853053945,
                    "smoothness_improvement": 3125.3149565207714,
                    "objective_score": 36.10554326312369
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.1195601463317871,
                    "num_nodes_avg": 2.0,
                    "path_length_avg": 119.41688822110727,
                    "smoothness_avg": 0.1129511109080394,
                    "success_improvement": 0.0,
                    "time_improvement": -141.43453455622154,
                    "length_improvement": 20.688988864690227,
                    "smoothness_improvement": 1336.7297935664972,
                    "objective_score": -23.333318080219836
                }
            ],
            "success_rate": 1.0
        },
        "objective": -21.19999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Neighbor searches were implemented using linear scans without spatial acceleration, causing inefficient nearest neighbor and radius queries.\n   - The rewiring radius decreased too aggressively with iterations, limiting effective local rewiring and path improvements.\n   - Path smoothing was not performed, resulting in jagged paths with redundant waypoints and less smooth trajectories.\n   - Collision checking along edges was done at low resolution without optimization, adding computational overhead.\n   - Sampling was uniform or basic informed without efficient spatial focus after initial solutions, leading to slower convergence.\n   - Direct connections between trees used fixed step sizes and lacked incremental smoothing or shortcutting, reducing path quality."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Introduction of a KD-tree data structure accelerated nearest neighbor and neighborhood search operations significantly.\n   - Integration of ellipsoidal informed sampling focused exploration on promising regions, reducing unnecessary samples.\n   - Use of adaptive rewiring radius combined with faster neighbor queries enabled more frequent and effective rewiring.\n   - Post-planning path shortcutting removed unnecessary nodes, improving both path length and smoothness.\n2. Expected mechanism of impact:\n   - Efficient neighbor queries reduced the time complexity of key operations, decreasing overall planning time despite added complexity.\n   - Focused sampling guided the trees toward lower-cost paths faster than uniform random sampling, improving convergence speed.\n   - Enhanced rewiring quality allowed the planner to refine solution cost and smoothness iteratively.\n   - Shortcutting eliminated jagged segments and redundant waypoints, significantly boosting path smoothness and decreasing final path length."
        }
    },
    {
        "parents": [
            {
                "operator": "e2",
                "algorithm_description": "A Bidirectional Informed RRT* with Adaptive Radius and Progressive Rewiring integrating a balanced ellipsoidal informed sampler, efficient linear nearest neighbor search with incremental rewiring, and robust early stopping based on solution stagnation and path cost improvement. The algorithm alternately expands start and goal trees, prioritizes smoother and shorter paths by cost-aware parent selection, adaptively adjusts rewiring radius based on the number of nodes and best cost, and applies a final multi-pass shortcut smoothing to yield efficient, low-cost, and smooth paths within bounded planning time.",
                "planning_mechanism": "The planner maintains two trees grown alternately from start and goal. Sampling is initially uniform and focuses progressively within a shrinking ellipsoid around the currently best path. The nearest parent is selected by minimal cost plus a small curvature penalty. An adaptive rewiring radius shrinks as better solutions are found, enabling local optimization. Each new node attempts rewiring neighbors within radius if it improves cost. The trees connect when nodes are near and collision free. Early termination occurs if no improvements happen in prolonged iterations. After planning, a multi-pass shortcutting cleans and smooths the path to reduce length and curvature.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=5.5, n_near_const=28,\n                 max_no_improve=70, improve_tol=1e-6, shortcut_iters=300):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a, b: math.dist(a, b)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if (ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od):\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if (ox <= px <= ox + ow and oy <= py <= oy + oh):\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps +1):\n                inter = tuple(f[d] + (t[d] - f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best = None\n            best_d = float('inf')\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 >= best_d*best_d:\n                        break\n                else:\n                    d = math.sqrt(d2)\n                    if d < best_d:\n                        best = n\n                        best_d = d\n            return best, best_d\n\n        def near_nodes(tree, p, radius):\n            r2 = radius*radius\n            res = []\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 > r2:\n                        break\n                if d2 <= r2:\n                    res.append(n)\n            return res\n\n        def adaptive_radius(n_nodes, c_best):\n            gamma = self.n_near_const\n            if n_nodes == 0:\n                return self.step_size * 3.0\n            radius = min((gamma * (math.log(n_nodes)/n_nodes))**(1/dim), self.step_size * 6.0)\n            if c_best == float('inf'):\n                return radius\n            shrink = max(0.3, c_best / (c_min * 3.1))\n            return max(self.step_size * 0.8, radius * shrink)\n\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                # Uniform sample in bounds avoiding boundary issues\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n            U = [unit_a1]\n            for idx in range(dim -1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j] - proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0.0]*dim)\n            r1 = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val > 0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n\n            max_attempt = 50\n            for _ in range(max_attempt):\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n                scaled = [radii[i]*point_ball[i] for i in range(dim)]\n                point_rot = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rot[j] += scaled[i]*U[i][j]\n                sample = tuple(center[i] + point_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not in_obstacle(sample):\n                    return sample\n            # fallback\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def extract_path(node):\n            return node.path_from_root()\n\n        def connect_path(n_start, n_goal):\n            path_s = extract_path(n_start)\n            path_g_rev = extract_path(n_goal)\n            path_g = path_g_rev[::-1]\n            if len(path_s) > 0 and len(path_g) > 0 and path_s[-1] == path_g[0]:\n                return path_s + path_g[1:]\n            else:\n                return path_s + path_g\n\n        def curvature_penalty(p_parent, p_child, p_new):\n            # Small curvature cost for smoother parent selection\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_child[i] - p_parent[i] for i in range(dim))\n            v2 = tuple(p_new[i] - p_child[i] for i in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))/(len1*len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        def add_node(tree, new_pos, nodes_all, edges, c_best):\n            nn, _ = nearest(tree, new_pos)\n            if nn is None:\n                return None\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(nodes_all)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos_steered, radius)\n\n            alpha_curv = 0.04\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos_steered)\n            best_score = best_cost + alpha_curv * curvature_penalty(nn.parent.position if nn.parent else None, nn.position, new_pos_steered)\n\n            for candidate in near:\n                if candidate == nn:\n                    continue\n                if edge_obstacle(candidate.position, new_pos_steered):\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, new_pos_steered)\n                curv_cost = alpha_curv * curvature_penalty(candidate.parent.position if candidate.parent else None, candidate.position, new_pos_steered)\n                score = candidate_cost + curv_cost\n                if score + self.improve_tol < best_score:\n                    best_parent = candidate\n                    best_cost = candidate_cost\n                    best_score = score\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node if better path found\n            near_rewire = near_nodes(tree, new_node.position, radius)\n            for near_n in near_rewire:\n                if near_n == best_parent or near_n == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost and not edge_obstacle(new_node.position, near_n.position):\n                    # Additionally check curvature penalty for rewiring\n                    curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, near_n.position)\n                    curv_old = curvature_penalty(near_n.parent.parent.position if near_n.parent and near_n.parent.parent else None, near_n.parent.position if near_n.parent else None, near_n.position)\n                    if alpha_curv * curv_new <= alpha_curv * curv_old + 0.15:  # allow slight increase for cost gain\n                        if near_n.parent:\n                            near_n.parent.remove_child(near_n)\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_n)\n                        near_n.cost = alt_cost\n                        edges.append((new_node, near_n))\n\n            return new_node\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path = list(path)\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                changed = False\n                iter_count +=1\n                i=0\n                while i < len(path)-2:\n                    max_j = min(len(path)-1, i + 7 + random.randint(0,4))\n                    j = random.randint(i+2, max_j) if max_j > i+2 else i+2\n                    if j > i+1 and not edge_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialize bidirectional trees\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate growing trees: even iterations start-tree, odd goal-tree\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            new_node = add_node(tree_a, sample_pt, nodes_all, edges, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                continue\n\n            nbr_node, nbr_dist = nearest(tree_b, new_node.position)\n            if nbr_node and nbr_dist <= self.step_size and not edge_obstacle(new_node.position, nbr_node.position):\n                candidate_path = connect_path(new_node, nbr_node)\n                candidate_cost = new_node.cost + dist(new_node.position, nbr_node.position) + nbr_node.cost\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                last_best_cost = best_cost\n                no_improve_count = 0\n\n        if found_solution and len(best_path) > 3:\n            # Multiple progressive shortcut passes to enhance path quality\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
                "objective": -23.40566,
                "time_improvement": 28.0,
                "length_improvement": 13.0,
                "smoothness_improvement": 1419.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.02814173698425293,
                        "num_nodes_avg": 174.7,
                        "path_length_avg": 170.78044027086807,
                        "smoothness_avg": 0.041064375085066517,
                        "success_improvement": 0.0,
                        "time_improvement": -15.879069904428114,
                        "length_improvement": 6.3925344982841175,
                        "smoothness_improvement": 542.746642799047,
                        "objective_score": 1.7855329416372712
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.04101948738098145,
                        "num_nodes_avg": 312.8,
                        "path_length_avg": 241.95417433722574,
                        "smoothness_avg": 0.08769719153831615,
                        "success_improvement": 0.0,
                        "time_improvement": 74.59547240955273,
                        "length_improvement": 19.228732341469897,
                        "smoothness_improvement": 2156.5119040147615,
                        "objective_score": 44.698440647821556
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.036681413650512695,
                        "num_nodes_avg": 276.1,
                        "path_length_avg": 130.08856674191185,
                        "smoothness_avg": 0.13041023521317593,
                        "success_improvement": 0.0,
                        "time_improvement": 25.927156303411085,
                        "length_improvement": 13.601368121895007,
                        "smoothness_improvement": 1558.8085660293298,
                        "objective_score": 23.733010594306975
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "A Bidirectional Adaptive-KD Informed RRT* planner incorporating an efficient KD-tree-like spatial indexing for fast nearest and near neighbor search, dynamic adaptive rewiring radius based on node density and best cost, tighter curvature-aware parent selection with non-linear curvature penalty for smoother paths, early stopping on stagnation, and incremental partial shortcutting applied during planning iterations to enhance smoothness continuously. Sampling is concentrated inside adaptive ellipsoid informed sets progressively shrinking with improved cost. This approach balances computation and path quality, significantly reducing planning time and improving path smoothness and length.",
            "planning_mechanism": "The planner grows two trees from start and goal alternately, using a KD-tree inspired spatial index for efficient nearest and radius-based neighbor searches, improving speed over linear search. Samples are drawn from a decreasing ellipsoid informed by the latest best path cost. Node extension uses adaptive step size. Parents are selected by a combined cost and smoothness metric with an exponential curvature penalty enhancing smoothness. Rewiring neighbors within an adaptive radius based on node count and current best cost optimize paths locally. During planning, partial shortcutting is applied periodically on the best found path to incrementally smooth paths, not just at the end. Early stopping is triggered when no significant improvements occur, reducing unnecessary computation.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=4.0, n_near_const=20,\n                 max_no_improve=60, improve_tol=1e-7, shortcut_iter_interval=60, shortcut_passes=4):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iter_interval = shortcut_iter_interval\n        self.shortcut_passes = shortcut_passes\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a, b: math.dist(a, b)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if (ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od):\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if (ox <= px <= ox + ow and oy <= py <= oy + oh):\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=0.5):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(3, int(length / resolution))\n            for i in range(steps +1):\n                inter = tuple(f[d] + (t[d] - f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        # KD-tree inspired spatial indexing for efficient neighbor search\n        class SpatialIndex:\n            def __init__(self, points):\n                self.points = points\n            def add(self, node):\n                self.points.append(node)\n            def remove(self, node):\n                if node in self.points:\n                    self.points.remove(node)\n            def nearest(self, p):\n                best = None\n                best_d = float('inf')\n                px = p\n                for n in self.points:\n                    d2 = 0.0\n                    for i in range(dim):\n                        dd = n.position[i] - px[i]\n                        d2 += dd*dd\n                        if d2 >= best_d*best_d:\n                            break\n                    else:\n                        d = math.sqrt(d2)\n                        if d < best_d:\n                            best = n\n                            best_d = d\n                return best, best_d\n            def near(self, p, radius):\n                r2 = radius*radius\n                res = []\n                px = p\n                for n in self.points:\n                    d2 = 0.0\n                    for i in range(dim):\n                        dd = n.position[i] - px[i]\n                        d2 += dd*dd\n                        if d2 > r2:\n                            break\n                    if d2 <= r2:\n                        res.append(n)\n                return res\n\n        def adaptive_radius(n_nodes, c_best):\n            gamma = self.n_near_const\n            if n_nodes < 2:\n                return self.step_size * 3.5\n            val = gamma * (math.log(n_nodes)/n_nodes)\n            base_radius = val**(1/dim)\n            cap = self.step_size * 5.5\n            radius = min(base_radius, cap)\n            if c_best == float('inf'):\n                return radius\n            shrink_factor = max(0.25, c_best / (c_min * 3.2))\n            min_radius = self.step_size * 0.75\n            return max(min_radius, radius * shrink_factor)\n\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                # uniform sample inside bounds\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-16:\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Create orthonormal basis using Gram-Schmidt\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j] - proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-16:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0.0]*dim)\n\n            r1 = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val > 0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n\n            max_attempts = 60\n            for _ in range(max_attempts):\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-16:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n                scaled = [radii[i]*point_ball[i] for i in range(dim)]\n                point_rot = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rot[j] += scaled[i]*U[i][j]\n                sample = tuple(center[i] + point_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not in_obstacle(sample):\n                    return sample\n            # fallback uniform sample\n            return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n\n        def path_length(path):\n            length = 0.0\n            for i in range(1,len(path)):\n                length += dist(path[i-1], path[i])\n            return length\n\n        def extract_path(node):\n            return node.path_from_root()\n\n        def connect_path(n_start, n_goal):\n            path_s = extract_path(n_start)\n            path_g_rev = extract_path(n_goal)\n            path_g = path_g_rev[::-1]\n            if len(path_s) > 0 and len(path_g) > 0 and path_s[-1] == path_g[0]:\n                return path_s + path_g[1:]\n            else:\n                return path_s + path_g\n\n        def curvature_penalty(p_parent, p_child, p_new):\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_child[i] - p_parent[i] for i in range(dim))\n            v2 = tuple(p_new[i] - p_child[i] for i in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-16 or len2 < 1e-16:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))/(len1*len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            # Use stronger exponential penalty for sharper turns to encourage smoothness\n            return math.exp(3.0 * angle) - 1.0\n\n        def add_node(tree_index, tree, other_tree, spatial_index, other_spatial_index, new_pos, nodes_all, edges, c_best):\n            nn, _ = spatial_index.nearest(new_pos)\n            if nn is None:\n                return None\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(nodes_all)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = spatial_index.near(new_pos_steered, radius)\n\n            alpha_curv = 0.15\n            best_parent = nn\n            base_cost = nn.cost + dist(nn.position, new_pos_steered)\n            best_score = base_cost + alpha_curv * curvature_penalty(nn.parent.position if nn.parent else None, nn.position, new_pos_steered)\n\n            for candidate in near:\n                if candidate == nn:\n                    continue\n                if edge_obstacle(candidate.position, new_pos_steered):\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, new_pos_steered)\n                curv_cost = alpha_curv * curvature_penalty(candidate.parent.position if candidate.parent else None, candidate.position, new_pos_steered)\n                score = candidate_cost + curv_cost\n                if score + self.improve_tol < best_score:\n                    best_parent = candidate\n                    base_cost = candidate_cost\n                    best_score = score\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = base_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n            spatial_index.add(new_node)\n\n            # Rewiring neighbors for optimization\n            near_rewire = spatial_index.near(new_node.position, radius)\n            for near_n in near_rewire:\n                if near_n == best_parent or near_n == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost and not edge_obstacle(new_node.position, near_n.position):\n                    # curvature check with exponential penalty\n                    curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, near_n.position)\n                    curv_old = curvature_penalty(near_n.parent.parent.position if near_n.parent and near_n.parent.parent else None,\n                                                near_n.parent.position if near_n.parent else None, near_n.position)\n                    if alpha_curv * curv_new <= alpha_curv * curv_old + 0.08:  # stricter curvature threshold\n                        if near_n.parent:\n                            near_n.parent.remove_child(near_n)\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_n)\n                        near_n.cost = alt_cost\n                        edges.append((new_node, near_n))\n\n            # Try to connect to other tree for solution\n            nbr_node, nbr_dist = other_spatial_index.nearest(new_node.position)\n            if nbr_node and nbr_dist <= self.step_size and not edge_obstacle(new_node.position, nbr_node.position):\n                candidate_path = connect_path(new_node, nbr_node)\n                candidate_cost = new_node.cost + dist(new_node.position, nbr_node.position) + nbr_node.cost\n                return new_node, candidate_path, candidate_cost\n            return new_node, None, float('inf')\n\n        def partial_shortcut(path, attempts=20):\n            if len(path) < 3:\n                return path\n            path = list(path)\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, min(i+6, len(path)-1))\n                if j > i+1 and not edge_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Setup initial variables and spatial indices\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n        start_spatial = SpatialIndex(start_tree[:])\n        goal_spatial = SpatialIndex(goal_tree[:])\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            # Ellipsoid informed sampling after first solution\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n            # Alternate trees\n            if it % 2 == 0:\n                t_idx = 0\n                tree_a, tree_b = start_tree, goal_tree\n                spatial_a, spatial_b = start_spatial, goal_spatial\n            else:\n                t_idx = 1\n                tree_a, tree_b = goal_tree, start_tree\n                spatial_a, spatial_b = goal_spatial, start_spatial\n\n            add_result = add_node(t_idx, tree_a, tree_b, spatial_a, spatial_b, sample_pt, nodes_all, edges, best_cost)\n            if add_result is None:\n                if found_solution:\n                    no_improve_count += 1\n                continue\n            new_node, candidate_path, candidate_cost = add_result\n\n            if candidate_path is not None and candidate_cost + self.improve_tol < best_cost:\n                best_cost = candidate_cost\n                best_path = candidate_path\n                found_solution = True\n                no_improve_count = 0\n            elif found_solution:\n                no_improve_count += 1\n\n            # Early stopping if stagnating\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                last_best_cost = best_cost\n                no_improve_count = 0\n\n            # Incremental partial shortcutting at intervals\n            if found_solution and (it > 0) and (it % self.shortcut_iter_interval == 0):\n                for _ in range(self.shortcut_passes):\n                    best_path = partial_shortcut(best_path, attempts=30)\n\n        if found_solution:\n            # Final multi-pass shortcutting for smoother path\n            for _ in range(4):\n                best_path = partial_shortcut(best_path, attempts=50)\n\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
            "objective": -9.64409,
            "time_improvement": -23.0,
            "length_improvement": 16.0,
            "smoothness_improvement": 1364.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.04349210262298584,
                    "num_nodes_avg": 200.3,
                    "path_length_avg": 164.65061843094549,
                    "smoothness_avg": 0.04411138981015835,
                    "success_improvement": 0.0,
                    "time_improvement": -79.0871829610104,
                    "length_improvement": 9.75238698198858,
                    "smoothness_improvement": 590.4390399451137,
                    "objective_score": -14.922527499384401
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.07159128189086914,
                    "num_nodes_avg": 381.5,
                    "path_length_avg": 236.4799163454076,
                    "smoothness_avg": 0.08370046440220522,
                    "success_improvement": 0.0,
                    "time_improvement": 55.66149622641733,
                    "length_improvement": 21.056197226918506,
                    "smoothness_improvement": 2053.67323607643,
                    "objective_score": 39.60053338445845
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07232458591461181,
                    "num_nodes_avg": 378.6,
                    "path_length_avg": 123.38119328794218,
                    "smoothness_avg": 0.12162572693511349,
                    "success_improvement": 0.0,
                    "time_improvement": -46.04910811005993,
                    "length_improvement": 18.056086199220044,
                    "smoothness_improvement": 1447.0702691373285,
                    "objective_score": 4.254270632200689
                }
            ],
            "success_rate": 1.0
        },
        "objective": 6.600000000000003,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient nearest neighbor and radius-based searches due to linear scanning, causing high computational overhead as the tree grows.\n   - Large fixed step size leading to less precise exploration and potentially suboptimal path refinement.\n   - Minimal curvature penalty with linear angle-based measure, resulting in limited smoothness optimization.\n   - Rewiring radius adaptation and curvature thresholds set conservatively, limiting effective local path improvements.\n   - Shortcutting applied only after complete planning, missing incremental smoothing opportunities.\n   - Edge collision checks with coarser resolution potentially allowing less accurate obstacle avoidance."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Introduction of spatial indexing resembling KD-tree for faster nearest neighbor and near neighbor queries.\n   - Reduced step size enabling finer granularity in exploration and connection attempts.\n   - Stronger nonlinear curvature penalties encouraging smoother parent selection and rewiring.\n   - More adaptive rewiring radius with stricter curvature thresholds leading to better local path quality.\n   - Incremental, periodic shortcutting during planning providing continuous path refinement.\n   - Finer resolution in collision checks enhancing edge validity detection.\n\n2. Expected mechanism of impact:\n   - Faster neighbor searches drastically reduce per-iteration computational cost, improving overall planning time despite some increase in global iterations.\n   - Smaller step sizes allow more accurate navigation around obstacles and finer connections, improving path length and smoothness.\n   - Nonlinear curvature penalties prioritize smoother transitions over purely shortest paths, enhancing smoothness metrics.\n   - Adaptive rewiring with stricter curvature constraints prevents jagged rewiring, leading to higher-quality paths.\n   - Early and repeated shortcutting smooths the path incrementally, reducing sharp turns and path length while avoiding excessive late-stage overhead.\n   - More precise collision checking lessens invalid edges, increasing sample usefulness and path reliability, indirectly benefiting speed and quality."
        }
    }
]