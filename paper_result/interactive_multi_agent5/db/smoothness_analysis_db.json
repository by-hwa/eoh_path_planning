[
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -23.76291481494683,
                "time_improvement": 61.0,
                "length_improvement": 8.0,
                "smoothness_improvement": 166.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.012529301643371581,
                        "num_nodes_avg": 131.9,
                        "path_length_avg": 176.77827310097746,
                        "smoothness_avg": 0.01645631271580969,
                        "success_improvement": 0.0,
                        "time_improvement": 48.408166070262766,
                        "length_improvement": 3.105027282357968,
                        "smoothness_improvement": 157.5770294574498,
                        "objective_score": 17.173351337780858
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.01886875629425049,
                        "num_nodes_avg": 256.8,
                        "path_length_avg": 267.7347696890942,
                        "smoothness_avg": 0.010597136127488454,
                        "success_improvement": 0.0,
                        "time_improvement": 88.31404606735866,
                        "length_improvement": 10.622427559723258,
                        "smoothness_improvement": 172.67194536891012,
                        "objective_score": 33.7310300828861
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.026641178131103515,
                        "num_nodes_avg": 304.4,
                        "path_length_avg": 136.29588257526552,
                        "smoothness_avg": 0.02101448639210645,
                        "success_improvement": 0.0,
                        "time_improvement": 46.20196913892299,
                        "length_improvement": 9.478764505998065,
                        "smoothness_improvement": 167.3027157795587,
                        "objective_score": 20.384363024173528
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm with post-optimization: a single-tree, asymptotically optimal sampler that, after the first feasible path, restricts sampling to a start\u2013goal prolate hyperspheroid to accelerate convergence while continuing local rewiring to reduce path cost.",
                "planning_mechanism": "Mechanism: (1) Grow one tree from the start using uniform sampling; (2) when a goal-connecting edge is found, record the best cost and switch to informed sampling inside the ellipsoid defined by start, goal, and current best path length; (3) for each sample, steer a step from the nearest node, then select the lowest-cost parent among nearby nodes and rewire neighbors if the new node offers cheaper paths; (4) whenever the new node lies within one step of the goal and the edge is collision-free, connect and update the best path; (5) after the first solution, continue only a limited number of additional iterations or until no further improvements occur; (6) every candidate node and edge is validated against obstacle occupancy and line-segment collisions, and results include the best path found within the iteration budget.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 post_opt_iters: int = 500, max_no_improve: int = 150,\n                 improve_tol: float = 1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        goal_node = Node(goal)\n        nodes.append(root)\n        tree = [root]\n\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        c_min = math.dist(start, goal)\n\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        for _ in range(self.max_iter):\n            x_rand = self._sample(start, goal, best_cost, c_min, is_3d, bounds)\n\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n            x_new_pos = self._steer(x_nearest.position, x_rand)\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            x_new = Node(x_new_pos)\n            near_nodes = [n for n in tree if math.dist(n.position, x_new_pos) <= 20.0]\n\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near_nodes:\n                new_cost = n.cost + math.dist(n.position, x_new_pos)\n                if new_cost < min_cost and not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                    best_parent = n\n                    min_cost = new_cost\n\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            x_new.parent = best_parent\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            for n in near_nodes:\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost + 1e-12 < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        if n in n.parent.children:\n                            n.parent.children.remove(n)\n                    n.parent = x_new\n                    n.cost = alt_cost\n                    x_new.add_child(n)\n                    edges.append((x_new, n))\n\n            if math.dist(x_new.position, goal) < self.step_size and                not self._is_edge_in_obstacle(x_new.position, goal, obstacles, is_3d):\n                # \uc0c8 \ud574 \ud6c4\ubcf4\n                goal_node = Node(goal)  # \ubaa9\ud45c \ub178\ub4dc\ub294 \uc0c8\ub85c \ub9cc\ub4e4\uc5b4 \uba85\ud655\ud788 \uc5f0\uacb0\n                goal_node.parent = x_new\n                goal_node.cost = x_new.cost + math.dist(x_new.position, goal)\n                nodes.append(goal_node)\n                edges.append((x_new, goal_node))\n\n                if goal_node.cost + self.improve_tol < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    no_improve_streak = 0  \n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0  \n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        if success_state and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample(self, start, goal, c_best, c_min, is_3d, bounds):\n        import numpy as np\n        import math, random\n\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        dim = len(start)\n        L = np.diag([c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1))\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        I = np.eye(dim)\n        M = np.outer(a1, I[:, 0])\n        U, _, Vt = np.linalg.svd(M)\n        C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(x_ball)\n            if norm > 1e-6:\n                x_ball = x_ball / norm * random.random() ** (1.0 / dim)\n            x_rand = np.dot(C, np.dot(L, x_ball)) + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    \n",
                "objective": 254.21494524343552,
                "time_improvement": -899.0,
                "length_improvement": 22.0,
                "smoothness_improvement": 414.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.35683939456939695,
                        "num_nodes_avg": 772.1,
                        "path_length_avg": 150.94653533720216,
                        "smoothness_avg": 0.030245912861543284,
                        "success_improvement": 0.0,
                        "time_improvement": -1369.3555401750432,
                        "length_improvement": 17.263812080762307,
                        "smoothness_improvement": 373.41421633417696,
                        "objective_score": -398.5813037223847
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.6798739194869995,
                        "num_nodes_avg": 1185.7,
                        "path_length_avg": 222.10813211370723,
                        "smoothness_avg": 0.021429118285859527,
                        "success_improvement": 0.0,
                        "time_improvement": -321.06512900112574,
                        "length_improvement": 25.853912472332702,
                        "smoothness_improvement": 451.3866482651889,
                        "objective_score": -78.55025797561215
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.5478150129318238,
                        "num_nodes_avg": 1082.6,
                        "path_length_avg": 114.7698430835218,
                        "smoothness_avg": 0.040749199207674086,
                        "success_improvement": 0.0,
                        "time_improvement": -1006.2336968296382,
                        "length_improvement": 23.77533497656441,
                        "smoothness_improvement": 418.326806128603,
                        "objective_score": -285.51327403230977
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "A bidirectional variant of RRT* with informed sampling and efficient rewiring that grows two trees simultaneously, restricts sampling to an ellipsoidal informed subset after first solution, and performs local rewiring to improve path cost and smoothness with early termination on convergence.",
            "planning_mechanism": "The planner grows start and goal trees bidirectionally with RRT* rewiring, initially samples uniformly to quickly find a path, then constrains samples to an ellipsoidal informed set defined by the current best path cost. After each extension, it attempts to connect the two trees if close enough, while performing localized rewiring to continuously improve path quality. Early stopping criteria limit iterations after no improvements to reduce planning time.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, radius=15.0,\n                 post_opt_iters=500, max_no_improve=100, improve_tol=1e-5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n\n        c_min = math.dist(start, goal)\n        found_solution = False\n\n        no_improve_count = 0\n        post_opt_count = 0\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            return tuple(frm[i] + (to[i]-frm[i]) * self.step_size / d for i in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            distance = dist(f, t)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                inter = tuple(f[j] + (t[j]-f[j])*(i/steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def nearest(tree, p):\n            best = tree[0]\n            best_d = dist(best.position, p)\n            for n in tree:\n                d2 = dist(n.position, p)\n                if d2 < best_d:\n                    best = n\n                    best_d = d2\n            return best\n\n        def near_nodes(tree, p, radius):\n            result = []\n            r2 = radius**2\n            for n in tree:\n                d2 = sum((n.position[i]-p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def extract_path(n_start, n_goal):\n            path_start, node = [], n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def ellipsoid_sample(c_best):\n            # Sample inside prolate hyperspheroid defined by start, goal, c_best\n            import random\n            import math\n\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i]+goal[i])/2 for i in range(dim))\n            a1 = [goal[i]-start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-12:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            # Compute rotation matrix via Gram-Schmidt or approximate as identity except along a1 axis\n            # For simplicity, rotate only along principal axis for 2D or 3D (orthonormal basis)\n            # Since imports are restricted, implement a simple orthonormal basis:\n\n            # Construct orthonormal basis U with unit_a1 as first vector\n            U = [unit_a1]\n            for i in range(dim-1):\n                base = [0]*dim\n                base[(i+1)%dim] = 1  # simple perpendicular approx\n                # Gram-Schmidt orthogonalize base vs U\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j]-proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-12:\n                    U.append([x/norm_base for x in base])\n                else:\n                    # fallback: constructs zero vector, skip\n                    U.append([0]*dim)\n\n            # L matrix diagonal\n            r1 = c_best / 2\n            if c_best*c_best - c_min*c_min < 0:\n                r2 = 0\n            else:\n                r2 = math.sqrt(c_best*c_best - c_min*c_min) / 2\n            radii = [r1] + [r2] * (dim - 1)\n\n            # Sample unit ball in dim\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-12:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n\n                # Scale by radii\n                point_scaled = [radii[i]*point_ball[i] for i in range(dim)]\n\n                # Rotate via U matrix: point = sum(point_scaled[i] * U[i]) over basis vectors\n                point_rotated = [0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i]*U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        for iter_count in range(self.max_iter):\n            if found_solution:\n                sample_pt = ellipsoid_sample(best_cost)\n            else:\n                sample_pt = ellipsoid_sample(float('inf'))\n\n            # Alternate growing start and goal trees\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n\n                if in_obstacle(new_pos) or edge_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                near = near_nodes(tree_a, new_pos, self.radius)\n\n                # Choose best parent in near nodes with minimal cost + dist and collision free edge\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for candidate in near:\n                    cand_cost = candidate.cost + dist(candidate.position, new_pos)\n                    if cand_cost + self.improve_tol < min_cost and not edge_obstacle(candidate.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = candidate\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire near nodes if new_node offers lower cost connection\n                for near_node in near:\n                    if near_node == best_parent:\n                        continue\n                    alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if alt_cost + self.improve_tol < near_node.cost and not edge_obstacle(new_node.position, near_node.position):\n                        # Remove old edge\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                        if near_node.parent and near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n                # Try connect trees if nodes close enough\n                connect_node = nearest(tree_b, new_node.position)\n                if dist(new_node.position, connect_node.position) <= self.step_size and not edge_obstacle(new_node.position, connect_node.position):\n                    path = extract_path(new_node, connect_node)\n                    path_cost = new_node.cost + dist(new_node.position, connect_node.position) + connect_node.cost\n                    if path_cost + self.improve_tol < best_cost:\n                        best_cost = path_cost\n                        # Stitch trees at connection nodes: assign parents carefully\n                        # For bidirectional path extraction, keep nodes and edges unchanged,\n                        # just store nodes for path extraction\n                        best_path = path\n                        found_solution = True\n                        best_goal_node = connect_node\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n\n                    if found_solution and no_improve_count >= self.max_no_improve:\n                        post_opt_count += 1\n                        if post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_opt_count += 1\n                        if no_improve_count >= self.max_no_improve or post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
            "objective": 52.64884,
            "time_improvement": -220.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 323.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06786198616027832,
                    "num_nodes_avg": 317.3,
                    "path_length_avg": 155.50621247453464,
                    "smoothness_avg": 0.02411673119934513,
                    "success_improvement": 0.0,
                    "time_improvement": -179.4349134355319,
                    "length_improvement": 14.764580789082476,
                    "smoothness_improvement": 277.4792135897667,
                    "objective_score": -43.58432948926125
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.14667820930480957,
                    "num_nodes_avg": 670.6,
                    "path_length_avg": 226.29277909188164,
                    "smoothness_avg": 0.017873034085429756,
                    "success_improvement": 0.0,
                    "time_improvement": 9.158040406689327,
                    "length_improvement": 24.45695686263326,
                    "smoothness_improvement": 359.8860404442116,
                    "objective_score": 19.22101644180781
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2925038576126099,
                    "num_nodes_avg": 613.1,
                    "path_length_avg": 120.56565817380633,
                    "smoothness_avg": 0.03399415459254427,
                    "success_improvement": 0.0,
                    "time_improvement": -490.6695072338173,
                    "length_improvement": 19.926030560654297,
                    "smoothness_improvement": 332.4031372296796,
                    "objective_score": -133.58321814760419
                }
            ],
            "success_rate": 1.0
        },
        "objective": 230.2,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient or uninformed sampling leading to slow convergence and unnecessary exploration.\n   - Redundant and computationally expensive collision checking and nearest neighbor searches.\n   - Fixed or suboptimal rewiring radius affecting the optimization of path costs.\n   - Lack of effective bidirectional tree growth and connection strategies that limit timely path discovery.\n   - Absence or limited early stopping criteria, causing excessive iterations without significant improvement.\n   - Paths extracted without sufficient smoothing or shortcutting, yielding jagged or less optimal trajectories."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Incorporation of bidirectional RRT* growth with systematic alternating expansion and connection attempts.\n   - Adoption of informed sampling restricting growth to an ellipsoidal subset bounded by current best path cost.\n   - Efficient local rewiring with adaptive cost comparison and dynamic parent updating reducing suboptimal branches.\n   - Implementation of robust early stopping based on improvement tolerance and iteration limits after stagnation.\n   - Enhanced path extraction that considers combined trees and incremental cost leads to smoother, shorter paths.\n2. Expected mechanism of impact:\n   - Focused sampling accelerates convergence to high-quality solutions by avoiding irrelevant state space regions.\n   - Dynamic rewiring maintains lower-cost connectivity and reduces path length and jaggedness.\n   - Bidirectional search expedites connection between start and goal, improving planning time.\n   - Early termination prevents wasteful computations once improvements plateau.\n   - Overall, these combined strategies produce shorter, smoother paths more efficiently."
        }
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional, asymptotically optimal planner that blends RRT-Connect\u2019s fast greedy tree-connection with RRT*\u2019s cost-optimal rewiring, and\u2014after an initial solution\u2014focuses sampling within the prolate hyperspheroid (ellipsoid) defined by the start, goal, and current best path length to accelerate convergence.",
                "planning_mechanism": "The planner grows two trees from start and goal. Each iteration: (1) sample uniformly until a first solution is found, then sample inside the informed ellipsoid; (2) extend one tree toward the sample using RRT*-style best-parent selection and local rewiring; (3) greedily \u201cconnect\u201d the opposite tree toward the new node, also rewiring locally; (4) if trees meet, update the best path and continue only a limited number of post-optimization iterations (user-tunable). Every node and edge is checked for point-in-obstacle and edge-obstacle collisions, positions are clamped to bounds, and a hard 30-second time limit halts the search and returns the best path found so far.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cumulative path cost from the root of its tree\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        neighbor_radius: float = 25.0,\n        post_opt_iters: int = 400,      # extra iterations after first solution\n        max_no_improve: int = 150,      # stop early if no improvement for this many iters\n        improve_tol: float = 1e-6,      # minimal improvement to count\n        time_limit_sec: float = 30.0,   # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Core data\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_cost = float('inf')\n        best_path = []\n        c_min = math.dist(start_position, goal_position)\n\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            # Enforce 30s time limit\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=success_state,\n                    path=best_path if success_state else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Alternate trees (RRT-Connect style)\n            tree_a, tree_b = (start_tree, goal_tree) if (it % 2 == 0) else (goal_tree, start_tree)\n\n            # Informed sampling: uniform before first solution; ellipsoid after\n            x_rand = self._sample_informed(start_position, goal_position, best_cost, c_min, bounds)\n\n            # Extend tree_a one step with RRT* best-parent + local rewire\n            a_nearest = self._nearest(tree_a, x_rand)\n            a_new_pos = self._steer(a_nearest.position, x_rand)\n\n            if not self._within_bounds(a_new_pos, bounds):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                if found_first_solution and (post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve):\n                    break\n                continue\n\n            if self._is_in_obstacle(a_new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(a_nearest.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                if found_first_solution and (post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve):\n                    break\n                continue\n\n            a_new, a_neighbors = self._add_with_best_parent(tree_a, a_new_pos, obstacles, is_3d, nodes, edges)\n            self._rewire_from(a_new, a_neighbors, obstacles, is_3d, edges)\n\n            # Greedy connect tree_b toward a_new (RRT-Connect) with local RRT* rewiring\n            b_meet = self._connect_with_rewire(tree_b, a_new, obstacles, is_3d, nodes, edges, bounds)\n\n            if b_meet is not None:\n                # Build full path depending on which side expanded\n                if it % 2 == 0:\n                    path_a = a_new.path_from_root()       # start side\n                    path_b = b_meet.path_from_root()      # goal side\n                else:\n                    path_a = b_meet.path_from_root()       # start side\n                    path_b = a_new.path_from_root()        # goal side\n\n                # Merge (avoid double-counting the joint if equal)\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged = path_a + path_b[-2::-1]\n                else:\n                    merged = path_a + path_b[::-1]\n\n                cost = self._path_cost(merged)\n\n                if cost + self.improve_tol < best_cost:\n                    best_cost = cost\n                    best_path = merged\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------------- Helpers ----------------------\n    def _within_bounds(self, pos, bounds):\n        return all(0.0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _path_cost(self, path):\n        return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _neighbors(self, tree, pos):\n        return [n for n in tree if math.dist(n.position, pos) <= self.neighbor_radius]\n\n    def _add_with_best_parent(self, tree, new_pos, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, new_pos)\n        candidates = self._neighbors(tree, new_pos)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in candidates:\n            if self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                continue\n            cand_cost = nb.cost + math.dist(nb.position, new_pos)\n            if cand_cost < min_cost:\n                min_cost = cand_cost\n                best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, candidates\n\n    def _rewire_from(self, pivot: Node, neighbors, obstacles, is_3d, edges):\n        for nb in neighbors:\n            if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                continue\n            new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost:\n                if nb.parent is not None:\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    if nb in nb.parent.children:\n                        nb.parent.children.remove(nb)\n                pivot.add_child(nb)\n                nb.cost = new_cost\n                edges.append((pivot, nb))\n\n    def _connect_with_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        \"\"\"\n        Greedily advance 'tree' toward 'target_node' like RRT-Connect.\n        At each step, insert with best parent and locally rewire.\n        Return the final node in 'tree' placed at target_node.position (if reached), else None.\n        \"\"\"\n        current = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(current.position, target_node.position)\n\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node, neighbors = self._add_with_best_parent(tree, new_pos, obstacles, is_3d, nodes, edges)\n            self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(new_node.position, target_node.position) <= self.step_size:\n                # final short edge\n                if not self._is_edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d) and target_node.valid:\n                    final_node = Node(\n                        target_node.position,\n                        parent=None,\n                        cost=new_node.cost + math.dist(new_node.position, target_node.position)\n                    )\n                    new_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                return None\n\n            current = new_node\n\n    # ------------------ Informed Sampling ------------------\n    def _sample_informed(self, start, goal, c_best, c_min, bounds):\n        \"\"\"Uniform before first solution; prolate hyperspheroid after (supports 2D/3D).\"\"\"\n        dim = len(bounds)\n        if c_best == float('inf') or c_min <= 1e-12:\n            # uniform in bounds\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # radii along orthonormal basis aligned with start->goal\n        r1 = c_best / 2.0\n        r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n        r_other = math.sqrt(r_other_sq) / 2.0\n\n        # center\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n        # first axis (unit)\n        a1_vec = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n        # orthonormal basis\n        if dim == 2:\n            a2_vec = (-a1_vec[1], a1_vec[0])\n            basis = (a1_vec, a2_vec)\n            radii = (r1, r_other)\n        else:  # dim == 3\n            # pick any non-parallel vector\n            ref = (1.0, 0.0, 0.0) if abs(a1_vec[0]) < 0.9 else (0.0, 1.0, 0.0)\n            # b2 = normalize(cross(a1, ref)), b3 = cross(a1, b2)\n            b2 = self._normalize(self._cross(a1_vec, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1_vec, ref))\n            b3 = self._cross(a1_vec, b2)\n            basis = (a1_vec, b2, b3)\n            radii = (r1, r_other, r_other)\n\n        # sample unit ball\n        u = self._sample_unit_ball(dim)\n\n        # map: x = center + sum_i (basis_i * radii_i * u_i)\n        mapped = []\n        for d in range(dim):\n            val = center[d]\n            for i in range(dim):\n                val += basis[i][d] * radii[i] * u[i]\n            mapped.append(val)\n\n        # clamp to bounds to be safe\n        mapped = tuple(min(max(mapped[d], 0.0), bounds[d]) for d in range(dim))\n        return mapped\n\n    def _sample_unit_ball(self, dim):\n        # Draw direction from normal distribution and radius with correct PDF\n        while True:\n            vec = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(v * v for v in vec))\n            if n > 1e-12:\n                vec = [v / n for v in vec]\n                r = random.random() ** (1.0 / dim)\n                return tuple(vec[i] * r for i in range(dim))\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)\n\n    # ------------------ Collision Utilities ------------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": 728.0268551361356,
                "time_improvement": -2481.0,
                "length_improvement": 22.0,
                "smoothness_improvement": 637.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 1.1499050855636597,
                        "num_nodes_avg": 453.8,
                        "path_length_avg": 150.36607672434712,
                        "smoothness_avg": 0.03422582042689417,
                        "success_improvement": 0.0,
                        "time_improvement": -4634.957613598991,
                        "length_improvement": 17.581970644423482,
                        "smoothness_improvement": 435.70841223952453,
                        "objective_score": -1377.7595596318454
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.9876691579818726,
                        "num_nodes_avg": 670.7,
                        "path_length_avg": 228.91285104264793,
                        "smoothness_avg": 0.029672116164352454,
                        "success_improvement": 0.0,
                        "time_improvement": -511.69141732906655,
                        "length_improvement": 23.582301430877845,
                        "smoothness_improvement": 663.4849208702007,
                        "objective_score": -136.04061973584226
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 1.1859658002853393,
                        "num_nodes_avg": 549.8,
                        "path_length_avg": 115.13263046293164,
                        "smoothness_avg": 0.0717808135970949,
                        "success_improvement": 0.0,
                        "time_improvement": -2294.887508726318,
                        "length_improvement": 23.53438887323898,
                        "smoothness_improvement": 813.0466506465236,
                        "objective_score": -670.2803860407195
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
                "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -22.142109273517423,
                "time_improvement": 49.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 177.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.018251991271972655,
                        "num_nodes_avg": 78.7,
                        "path_length_avg": 175.55592835957023,
                        "smoothness_avg": 0.017196193462405217,
                        "success_improvement": 0.0,
                        "time_improvement": 24.843879619675935,
                        "length_improvement": 3.775013804415195,
                        "smoothness_improvement": 169.1577698184268,
                        "objective_score": 10.563961017644031
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.04780585765838623,
                        "num_nodes_avg": 302.9,
                        "path_length_avg": 259.03658233660315,
                        "smoothness_avg": 0.01078988487631875,
                        "success_improvement": 0.0,
                        "time_improvement": 70.39248153962646,
                        "length_improvement": 13.526132861425937,
                        "smoothness_improvement": 177.6315095076258,
                        "objective_score": 30.121581726281626
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.023344540596008302,
                        "num_nodes_avg": 176.0,
                        "path_length_avg": 128.09376742543256,
                        "smoothness_avg": 0.022442540549775757,
                        "success_improvement": 0.0,
                        "time_improvement": 52.85905490960737,
                        "length_improvement": 14.926218845764677,
                        "smoothness_improvement": 185.467459257119,
                        "objective_score": 25.74078507662661
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "This algorithm is an enhanced bidirectional RRT* variant utilizing adaptive neighbor radius based on tree size and iteration progress for improved rewiring efficiency and path optimality. It integrates an ellipsoidal informed sampling strategy after the initial solution to focus exploration within promising regions. The adaptive neighbor radius dynamically contracts with iterations, balancing exploration and exploitation. The connect procedure attempts direct connections to reduce unnecessary intermediate nodes, improving path length and smoothness. Early stopping criteria based on solution improvement stagnation reduce planning time. Consistent node and edge collision checks prevent invalid expansions, maintaining robustness. The algorithm outputs the lowest cost path found within time and iteration limits.",
            "planning_mechanism": "The planner grows two trees from start and goal positions, alternating expansions each iteration. Initially, it samples uniformly, then focuses sampling inside an ellipsoid defined by current best path cost. Each expansion attempts to add a new node via steering and selects the best parent considering nodes within an adaptive radius that decreases as iterations proceed. Local rewiring optimizes neighbors' connections when beneficial. A direct connect is attempted between the newly added node and the opposite tree to quickly form a solution. The best path is updated when trees meet. The planning stops early if no significant improvements occur over a threshold or upon timeout.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # cost from root to this node\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=4.0,\n        max_neighbor_radius=30.0,\n        min_neighbor_radius=6.0,\n        improvement_tol=1e-6,\n        max_no_improve=100,\n        time_limit_sec=30.0,\n        post_opt_iters=300\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n        self.improvement_tol = improvement_tol\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.post_opt_iters = post_opt_iters\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_first = False\n        no_improve_count = 0\n        post_opt_count = 0\n        start_time = time.time()\n\n        def adaptive_radius(n, iter_i):\n            # Adaptive radius contracts as iteration increases, ensuring fewer neighbors later for efficiency\n            # Weighted blend with tree size and iteration progress\n            factor = max(0.0, 1.0 - iter_i / self.max_iter)\n            radius = max(self.min_neighbor_radius, min(self.max_neighbor_radius, self.max_neighbor_radius*factor*(math.log(n+1)/(n+1))**(1/dim)))\n            return radius\n\n        def within_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_p, to_p, resolution=1.0):\n            dist = math.dist(from_p, to_p)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d])*i/steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def neighbors(tree, pos, radius):\n            radius_sq = radius*radius\n            return [n for n in tree if ( (sum((n.position[d] - pos[d])**2 for d in range(dim))) <= radius_sq )]\n\n        def choose_parent_and_add(tree, new_pos, iter_i):\n            n = len(tree)\n            radius = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, new_pos, radius)\n\n            nearest = min(tree, key=lambda node: math.dist(node.position, new_pos))\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nb in nbrs:\n                if is_edge_in_obstacle(nb.position, new_pos):\n                    continue\n                c = nb.cost + math.dist(nb.position, new_pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = nb\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, nbrs, radius\n\n        def rewire(pivot, neighbors_list):\n            for nb in neighbors_list:\n                if is_edge_in_obstacle(pivot.position, nb.position):\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # Rewire nb to pivot\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n        def direct_connect(tree, target_node, iter_i):\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            # attempt a direct connection from nearest to target_node if possible\n            if (not is_edge_in_obstacle(nearest.position, target_node.position) and\n                not is_in_obstacle(target_node.position)):\n                # connect with one edge\n                new_node = Node(target_node.position, cost=nearest.cost + math.dist(nearest.position, target_node.position))\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n                return new_node\n\n            # else do incremental connection with steering and rewiring\n            current = nearest\n            for _ in range( int(math.ceil(math.dist(current.position, target_node.position) / self.step_size)) ):\n                new_pos = steer(current.position, target_node.position)\n                if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node, nbrs, _ = choose_parent_and_add(tree, new_pos, iter_i)\n                rewire(new_node, nbrs)\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    if not is_edge_in_obstacle(new_node.position, target_node.position) and not is_in_obstacle(target_node.position):\n                        final_node = Node(target_node.position,\n                                          cost=new_node.cost + math.dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n            return None\n\n        def sample_informed():\n            if not found_first or best_cost == float('inf') or c_min < 1e-12:\n                # uniform sampling\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # else sample inside prolate hyperspheroid:\n            # center\n            center = tuple((start_pos[d] + goal_pos[d])/2.0 for d in range(dim))\n            # unit direction vector from start to goal\n            unit_dir = []\n            dist_sg = c_min\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / dist_sg)\n            # radii\n            r1 = best_cost / 2.0\n            val = best_cost*best_cost - c_min*c_min\n            val = max(val, 0.0)\n            r_other = math.sqrt(val) / 2.0\n\n            # construct orthonormal basis\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                a1 = unit_dir\n                # pick reference vector not parallel to a1\n                ref = (1.0,0.0,0.0) if abs(a1[0]) < 0.9 else (0.0,1.0,0.0)\n                b2 = _cross(a1, ref)\n                n_b2 = _norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0.0,0.0,1.0)\n                    b2 = _cross(a1, ref)\n                    n_b2 = _norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = _cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            u = _sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                # clamp inside bounds\n                val = min(max(val, 0.0), bounds[d])\n                mapped.append(val)\n            return tuple(mapped)\n\n        def _sample_unit_ball(dim):\n            while True:\n                vec = [random.gauss(0.0, 1.0) for _ in range(dim)]\n                nrm = math.sqrt(sum(v*v for v in vec))\n                if nrm < 1e-12:\n                    continue\n                vec = [v/nrm for v in vec]\n                r = random.random()**(1.0/dim)\n                return tuple(vec[i]*r for i in range(dim))\n\n        def _cross(a,b):\n            return (a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0])\n\n        def _norm(v):\n            return math.sqrt(sum(x*x for x in v))\n\n        neighbor_radius_cache = None\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if (it % 2 == 0) else (goal_tree, start_tree)\n            x_rand = sample_informed()\n\n            if not within_bounds(x_rand) or is_in_obstacle(x_rand):\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest.position, new_pos):\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors_list, nradius = choose_parent_and_add(tree_a, new_pos, it)\n            rewire(new_node, neighbors_list)\n\n            # Attempt direct connect (not iterative connect) from tree_b to newly added node:\n            meet_node = direct_connect(tree_b, new_node, it)\n            if meet_node is not None:\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = sum(math.dist(merged_path[i], merged_path[i+1]) for i in range(len(merged_path)-1))\n                if total_cost + self.improvement_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_first = True\n                    post_opt_count = 0\n                    no_improve_count = 0\n                else:\n                    if found_first:\n                        post_opt_count += 1\n                        no_improve_count += 1\n                if found_first and (post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve):\n                    break\n            else:\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(success=found_first, path=best_path, nodes=nodes, edges=edges)",
            "objective": -10.44388,
            "time_improvement": 10.0,
            "length_improvement": 11.0,
            "smoothness_improvement": 142.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02786121368408203,
                    "num_nodes_avg": 139.4,
                    "path_length_avg": 155.87313188725165,
                    "smoothness_avg": 0.017886324975422283,
                    "success_improvement": 0.0,
                    "time_improvement": -14.723960710972353,
                    "length_improvement": 14.563466444762122,
                    "smoothness_improvement": 179.95982664171103,
                    "objective_score": 5.220690786774123
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.06340575218200684,
                    "num_nodes_avg": 418.9,
                    "path_length_avg": 277.6271906369829,
                    "smoothness_avg": 0.008053558435153495,
                    "success_improvement": 0.0,
                    "time_improvement": 60.731026067193284,
                    "length_improvement": 7.320052709768729,
                    "smoothness_improvement": 107.22385928017246,
                    "objective_score": 23.14745874242008
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05672965049743652,
                    "num_nodes_avg": 331.4,
                    "path_length_avg": 133.93060882634086,
                    "smoothness_avg": 0.018882342363182564,
                    "success_improvement": 0.0,
                    "time_improvement": -14.557377049180326,
                    "length_improvement": 11.049666707801231,
                    "smoothness_improvement": 140.18200111014838,
                    "objective_score": 2.9634969154773834
                }
            ],
            "success_rate": 1.0
        },
        "objective": 283.2,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Excessive computational overhead from frequent local rewiring with fixed large neighbor radius causing long planning times.\n   - Inefficient nearest neighbor and distance computations due to linear search without spatial indexing impacting scalability.\n   - Greedy connect strategies expanding incrementally rather than attempting direct connections, increasing path length and jaggedness.\n   - Lack of adaptive neighbor radius leading to unnecessary rewiring of distant nodes, resulting in suboptimal and non-smooth paths.\n   - Absence of early stopping criteria based on improvement stagnation causing wasted iterations.\n   - Path merging performed without post-processing smoothing or shortcutting leading to jagged, less smooth paths."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Introduction of an adaptive neighbor radius contracting with iterations to limit rewiring overhead.\n   - Incorporation of direct connection attempts in place of purely incremental connect steps.\n   - Use of ellipsoidal informed sampling after initial solution to focus exploration in promising regions.\n   - Addition of early stopping criteria based on stagnation of path improvement.\n2. Expected mechanism of impact:\n   - Adaptive radius reduces unnecessary rewiring, speeding planning and preventing redundant edge recalculations.\n   - Direct connect shortcuts create fewer intermediate nodes, decreasing overall path length and jaggedness.\n   - Informed sampling prioritizes sampling inside likely optimal regions, improving solution quality and convergence speed.\n   - Early termination avoids wasted computations once improvements plateau, improving time efficiency.\n   - The combined rewiring and parent selection within adaptive radius improves path smoothness by avoiding long-range, jagged connections."
        }
    },
    {
        "parents": [
            {
                "operator": "e2",
                "algorithm_description": "A bidirectional variant of RRT* with informed sampling and efficient rewiring that grows two trees simultaneously, restricts sampling to an ellipsoidal informed subset after first solution, and performs local rewiring to improve path cost and smoothness with early termination on convergence.",
                "planning_mechanism": "The planner grows start and goal trees bidirectionally with RRT* rewiring, initially samples uniformly to quickly find a path, then constrains samples to an ellipsoidal informed set defined by the current best path cost. After each extension, it attempts to connect the two trees if close enough, while performing localized rewiring to continuously improve path quality. Early stopping criteria limit iterations after no improvements to reduce planning time.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, radius=15.0,\n                 post_opt_iters=500, max_no_improve=100, improve_tol=1e-5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n\n        c_min = math.dist(start, goal)\n        found_solution = False\n\n        no_improve_count = 0\n        post_opt_count = 0\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            return tuple(frm[i] + (to[i]-frm[i]) * self.step_size / d for i in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            distance = dist(f, t)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                inter = tuple(f[j] + (t[j]-f[j])*(i/steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def nearest(tree, p):\n            best = tree[0]\n            best_d = dist(best.position, p)\n            for n in tree:\n                d2 = dist(n.position, p)\n                if d2 < best_d:\n                    best = n\n                    best_d = d2\n            return best\n\n        def near_nodes(tree, p, radius):\n            result = []\n            r2 = radius**2\n            for n in tree:\n                d2 = sum((n.position[i]-p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def extract_path(n_start, n_goal):\n            path_start, node = [], n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def ellipsoid_sample(c_best):\n            # Sample inside prolate hyperspheroid defined by start, goal, c_best\n            import random\n            import math\n\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i]+goal[i])/2 for i in range(dim))\n            a1 = [goal[i]-start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-12:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            # Compute rotation matrix via Gram-Schmidt or approximate as identity except along a1 axis\n            # For simplicity, rotate only along principal axis for 2D or 3D (orthonormal basis)\n            # Since imports are restricted, implement a simple orthonormal basis:\n\n            # Construct orthonormal basis U with unit_a1 as first vector\n            U = [unit_a1]\n            for i in range(dim-1):\n                base = [0]*dim\n                base[(i+1)%dim] = 1  # simple perpendicular approx\n                # Gram-Schmidt orthogonalize base vs U\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j]-proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-12:\n                    U.append([x/norm_base for x in base])\n                else:\n                    # fallback: constructs zero vector, skip\n                    U.append([0]*dim)\n\n            # L matrix diagonal\n            r1 = c_best / 2\n            if c_best*c_best - c_min*c_min < 0:\n                r2 = 0\n            else:\n                r2 = math.sqrt(c_best*c_best - c_min*c_min) / 2\n            radii = [r1] + [r2] * (dim - 1)\n\n            # Sample unit ball in dim\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-12:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n\n                # Scale by radii\n                point_scaled = [radii[i]*point_ball[i] for i in range(dim)]\n\n                # Rotate via U matrix: point = sum(point_scaled[i] * U[i]) over basis vectors\n                point_rotated = [0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i]*U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        for iter_count in range(self.max_iter):\n            if found_solution:\n                sample_pt = ellipsoid_sample(best_cost)\n            else:\n                sample_pt = ellipsoid_sample(float('inf'))\n\n            # Alternate growing start and goal trees\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n\n                if in_obstacle(new_pos) or edge_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                near = near_nodes(tree_a, new_pos, self.radius)\n\n                # Choose best parent in near nodes with minimal cost + dist and collision free edge\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for candidate in near:\n                    cand_cost = candidate.cost + dist(candidate.position, new_pos)\n                    if cand_cost + self.improve_tol < min_cost and not edge_obstacle(candidate.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = candidate\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire near nodes if new_node offers lower cost connection\n                for near_node in near:\n                    if near_node == best_parent:\n                        continue\n                    alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if alt_cost + self.improve_tol < near_node.cost and not edge_obstacle(new_node.position, near_node.position):\n                        # Remove old edge\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                        if near_node.parent and near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n                # Try connect trees if nodes close enough\n                connect_node = nearest(tree_b, new_node.position)\n                if dist(new_node.position, connect_node.position) <= self.step_size and not edge_obstacle(new_node.position, connect_node.position):\n                    path = extract_path(new_node, connect_node)\n                    path_cost = new_node.cost + dist(new_node.position, connect_node.position) + connect_node.cost\n                    if path_cost + self.improve_tol < best_cost:\n                        best_cost = path_cost\n                        # Stitch trees at connection nodes: assign parents carefully\n                        # For bidirectional path extraction, keep nodes and edges unchanged,\n                        # just store nodes for path extraction\n                        best_path = path\n                        found_solution = True\n                        best_goal_node = connect_node\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n\n                    if found_solution and no_improve_count >= self.max_no_improve:\n                        post_opt_count += 1\n                        if post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_opt_count += 1\n                        if no_improve_count >= self.max_no_improve or post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
                "objective": 52.64884,
                "time_improvement": -220.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 323.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.06786198616027832,
                        "num_nodes_avg": 317.3,
                        "path_length_avg": 155.50621247453464,
                        "smoothness_avg": 0.02411673119934513,
                        "success_improvement": 0.0,
                        "time_improvement": -179.4349134355319,
                        "length_improvement": 14.764580789082476,
                        "smoothness_improvement": 277.4792135897667,
                        "objective_score": -43.58432948926125
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.14667820930480957,
                        "num_nodes_avg": 670.6,
                        "path_length_avg": 226.29277909188164,
                        "smoothness_avg": 0.017873034085429756,
                        "success_improvement": 0.0,
                        "time_improvement": 9.158040406689327,
                        "length_improvement": 24.45695686263326,
                        "smoothness_improvement": 359.8860404442116,
                        "objective_score": 19.22101644180781
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.2925038576126099,
                        "num_nodes_avg": 613.1,
                        "path_length_avg": 120.56565817380633,
                        "smoothness_avg": 0.03399415459254427,
                        "success_improvement": 0.0,
                        "time_improvement": -490.6695072338173,
                        "length_improvement": 19.926030560654297,
                        "smoothness_improvement": 332.4031372296796,
                        "objective_score": -133.58321814760419
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "An enhanced bidirectional RRT* variant that incorporates adaptive neighbor radius shrinking to concentrate rewiring efforts for local optimality, an efficient nearest-neighbor caching structure for faster lookups, and progressive informed sampling with dynamic ellipsoidal restriction. The planner prioritizes early discovery and incremental path improvement, applies a smooth path shortcutting post-processing step to reduce path length and curvature, and enforces robust termination criteria based on stagnation and solution quality thresholds to minimize planning time.",
            "planning_mechanism": "The planner grows two trees alternately with rewiring using an adaptive radius, restricts sampling progressively to a shrinking ellipsoid after finding a solution to focus on promising areas, connects the trees upon proximity, and applies a final shortcut smoothing pass to improve total path length and smoothness before returning the best feasible path found within iteration and time limits.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, n_near_const=35, \n                 max_no_improve=80, improve_tol=1e-6, shortcut_iters=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const  # base neighbor count for adaptive radius\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        # --- Local helper imports & definitions ---\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        dist = lambda a, b: math.dist(a, b)\n\n        # Node collections\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        # To reduce overhead of nearest neighbor search, cache all nodes' positions lists for faster processing\n        # We implement simple linear searches but with caching and limit radius dynamically to reduce checks\n\n        # Adaptive radius for near-node rewiring, shrinks with best_cost to focus local improvements\n        # r_n = min((gamma * (log(n)/n))^(1/d), max_radius) but approximate w/o logs for lightweight\n        def adaptive_radius(n_nodes, c_best):\n            # Use gamma ~ 30 (typical for 2D), avoid zero or undefined\n            gamma = self.n_near_const\n            if n_nodes == 0:\n                return self.step_size * 2.5\n            r = min((gamma * (math.log(n_nodes)/n_nodes))**(1/dim), self.step_size * 5)\n            # Shrink with c_best, stronger around best solution to focus rewiring\n            if c_best == float('inf'):\n                return r\n            shrink_factor = max(0.25, c_best / (c_min * 3))\n            return max(self.step_size*0.75, r * shrink_factor)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-10:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[j] + (t[j] - f[j]) * (i / steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        # Efficient nearest neighbor search (linear but with early exit)\n        def nearest(tree, p):\n            best = None\n            best_d = float('inf')\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 >= best_d*best_d:\n                        break\n                else:\n                    d = math.sqrt(d2)\n                    if d < best_d:\n                        best = n\n                        best_d = d\n            return best\n\n        # Near nodes within radius (adaptive radius)\n        def near_nodes(tree, p, radius):\n            r2 = radius*radius\n            result = []\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 > r2:\n                        break\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        # Extract path from start via parent chain\n        def extract_path(node_start_root):\n            return node_start_root.path_from_root()\n\n        # Extract full path from two connection nodes (start tree and goal tree)\n        def connect_path(n_start, n_goal):\n            path_start = extract_path(n_start)\n            path_goal_rev = extract_path(n_goal)\n            path_goal = path_goal_rev[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        # Ellipsoidal informed sampling centered between start and goal, focused progressively as c_best shrinks\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-12:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Orthonormal basis U with unit_a1 first vector\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0] * dim\n                base[(idx + 1) % dim] = 1\n                for u in U:\n                    proj = sum(base[j] * u[j] for j in range(dim))\n                    base = [base[j] - proj * u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-12:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0] * dim)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-12:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n                point_scaled = [radii[i] * point_ball[i] for i in range(dim)]\n\n                point_rotated = [0.0] * dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i] * U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        # Path shortcutting by attempting to connect non-adjacent nodes directly if collision free\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                changed = False\n                iter_count += 1\n                i = 0\n                while i < len(path) - 2:\n                    j = min(len(path) - 1, i + 2 + random.randint(0, 3))\n                    if j > i + 1 and not edge_obstacle(path[i], path[j]):\n                        # Shortcut feasible, remove intermediate nodes\n                        path = path[:i + 1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Add node to tree selecting best parent among near nodes\n        def add_node(tree, new_pos, nodes_all, edges, c_best):\n            nn = nearest(tree, new_pos)\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(nodes_all)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos_steered, radius)\n\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos_steered)\n            for near_node in near:\n                if near_node == nn:\n                    continue\n                cand_cost = near_node.cost + dist(near_node.position, new_pos_steered)\n                if cand_cost + self.improve_tol < best_cost and not edge_obstacle(near_node.position, new_pos_steered):\n                    best_parent = near_node\n                    best_cost = cand_cost\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if beneficial\n            for near_node in near:\n                if near_node is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not edge_obstacle(new_node.position, near_node.position):\n                        # Remove old parent-child relationship\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n            return new_node\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n        start_time = time.time()\n\n        for iter_count in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate tree growing: start tree first odd iters, goal second even iters\n            if iter_count % 2 == 0:\n                tree_a = start_tree\n                tree_b = goal_tree\n            else:\n                tree_a = goal_tree\n                tree_b = start_tree\n\n            new_node = add_node(tree_a, sample_pt, nodes_all, edges, best_cost)\n            if new_node is None:\n                # Could not add node (collision), continue\n                continue\n\n            # Attempt connection to other tree\n            nearest_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_b.position) <= self.step_size:\n                if not edge_obstacle(new_node.position, nearest_b.position):\n                    # Connect path candidates\n                    path_candidate = connect_path(new_node, nearest_b)\n                    candidate_cost = new_node.cost + dist(new_node.position, nearest_b.position) + nearest_b.cost\n\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = path_candidate\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            # Early termination when no meaningful improvement for long\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            # Restart no improve count if significant improvement detected\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                no_improve_count = 0\n                last_best_cost = best_cost\n\n        # Final path smoothing via shortcutting if solution found\n        if found_solution and len(best_path) > 2:\n            best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
            "objective": -12.90672,
            "time_improvement": -15.0,
            "length_improvement": 14.0,
            "smoothness_improvement": 1865.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.03639078140258789,
                    "num_nodes_avg": 237.0,
                    "path_length_avg": 168.02193260520104,
                    "smoothness_avg": 0.04984815517379989,
                    "success_improvement": 0.0,
                    "time_improvement": -49.84611306639963,
                    "length_improvement": 7.9045162611873945,
                    "smoothness_improvement": 680.2318754714814,
                    "objective_score": -6.809964785850045
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.046571874618530275,
                    "num_nodes_avg": 354.8,
                    "path_length_avg": 240.5937710240402,
                    "smoothness_avg": 0.12631217131652547,
                    "success_improvement": 0.0,
                    "time_improvement": 71.15672210389786,
                    "length_improvement": 19.68287412444948,
                    "smoothness_improvement": 3150.1031469538016,
                    "objective_score": 48.907256840608056
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08302063941955566,
                    "num_nodes_avg": 467.5,
                    "path_length_avg": 130.26416789587537,
                    "smoothness_avg": 0.14664374877167838,
                    "success_improvement": 0.0,
                    "time_improvement": -67.64825112539418,
                    "length_improvement": 13.484742196660818,
                    "smoothness_improvement": 1765.2976602601516,
                    "objective_score": -3.377141718321006
                }
            ],
            "success_rate": 1.0
        },
        "objective": 502.19999999999993,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient nearest and near-node searches performed via basic linear scans without adaptive radius control, leading to costly computations and longer planning times.\n   - Use of fixed-radius neighborhoods for rewiring that do not adapt based on tree size or solution quality, resulting in suboptimal local improvements and slower convergence.\n   - Absence of dedicated path smoothing or shortcutting post-processing, causing longer and less smooth paths.\n   - Sampling strategies were not progressively focused after initial solution discovery, limiting efficiency in refining the path.\n   - Termination criteria lacked adaptive mechanisms based on stagnation or solution quality, potentially wasting computational effort."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Incorporation of an adaptive neighbor radius that shrinks as better solutions are found, focusing rewiring efforts for local optimality.\n   - Improved nearest neighbor search heuristics with early pruning and cached positions to reduce computational overhead.\n   - Progressive informed sampling with dynamic ellipsoidal restriction, concentrating exploration on promising regions near the current best path.\n   - Implementation of a path shortcutting post-processing step that directly connects non-adjacent nodes when collision-free, improving path smoothness and reducing length.\n   - Robust early termination mechanisms based on lack of improvement, avoiding unnecessary planning iterations.\n2. Expected mechanism of impact:\n   - Adaptive radius reduces unnecessary rewiring checks as the tree grows, lowering per-iteration costs and accelerating convergence.\n   - Focused sampling concentrates computational efforts on promising solution spaces, improving likelihood and speed of finding better paths.\n   - Post-planning shortcutting removes unnecessary waypoints and sharp turns, greatly enhancing path smoothness and decreasing total path length.\n   - Early stopping prevents wasted computation once improvements stagnate, reducing overall planning time.\n   - Collectively, these improvements enable more efficient exploration, faster solution refinement, better path quality, and smoother trajectories."
        }
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional, asymptotically optimal planner that blends RRT-Connect\u2019s fast greedy tree-connection with RRT*\u2019s cost-optimal rewiring, and\u2014after an initial solution\u2014focuses sampling within the prolate hyperspheroid (ellipsoid) defined by the start, goal, and current best path length to accelerate convergence.",
                "planning_mechanism": "The planner grows two trees from start and goal. Each iteration: (1) sample uniformly until a first solution is found, then sample inside the informed ellipsoid; (2) extend one tree toward the sample using RRT*-style best-parent selection and local rewiring; (3) greedily \u201cconnect\u201d the opposite tree toward the new node, also rewiring locally; (4) if trees meet, update the best path and continue only a limited number of post-optimization iterations (user-tunable). Every node and edge is checked for point-in-obstacle and edge-obstacle collisions, positions are clamped to bounds, and a hard 30-second time limit halts the search and returns the best path found so far.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cumulative path cost from the root of its tree\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        neighbor_radius: float = 25.0,\n        post_opt_iters: int = 400,      # extra iterations after first solution\n        max_no_improve: int = 150,      # stop early if no improvement for this many iters\n        improve_tol: float = 1e-6,      # minimal improvement to count\n        time_limit_sec: float = 30.0,   # hard wall time limit\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Core data\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_cost = float('inf')\n        best_path = []\n        c_min = math.dist(start_position, goal_position)\n\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            # Enforce 30s time limit\n            if time.time() - start_time > self.time_limit_sec:\n                return PlannerResult(\n                    success=success_state,\n                    path=best_path if success_state else [],\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            # Alternate trees (RRT-Connect style)\n            tree_a, tree_b = (start_tree, goal_tree) if (it % 2 == 0) else (goal_tree, start_tree)\n\n            # Informed sampling: uniform before first solution; ellipsoid after\n            x_rand = self._sample_informed(start_position, goal_position, best_cost, c_min, bounds)\n\n            # Extend tree_a one step with RRT* best-parent + local rewire\n            a_nearest = self._nearest(tree_a, x_rand)\n            a_new_pos = self._steer(a_nearest.position, x_rand)\n\n            if not self._within_bounds(a_new_pos, bounds):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                if found_first_solution and (post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve):\n                    break\n                continue\n\n            if self._is_in_obstacle(a_new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(a_nearest.position, a_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                if found_first_solution and (post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve):\n                    break\n                continue\n\n            a_new, a_neighbors = self._add_with_best_parent(tree_a, a_new_pos, obstacles, is_3d, nodes, edges)\n            self._rewire_from(a_new, a_neighbors, obstacles, is_3d, edges)\n\n            # Greedy connect tree_b toward a_new (RRT-Connect) with local RRT* rewiring\n            b_meet = self._connect_with_rewire(tree_b, a_new, obstacles, is_3d, nodes, edges, bounds)\n\n            if b_meet is not None:\n                # Build full path depending on which side expanded\n                if it % 2 == 0:\n                    path_a = a_new.path_from_root()       # start side\n                    path_b = b_meet.path_from_root()      # goal side\n                else:\n                    path_a = b_meet.path_from_root()       # start side\n                    path_b = a_new.path_from_root()        # goal side\n\n                # Merge (avoid double-counting the joint if equal)\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged = path_a + path_b[-2::-1]\n                else:\n                    merged = path_a + path_b[::-1]\n\n                cost = self._path_cost(merged)\n\n                if cost + self.improve_tol < best_cost:\n                    best_cost = cost\n                    best_path = merged\n                    success_state = True\n                    no_improve_streak = 0\n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0\n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        extracted_path = best_path if success_state else []\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # ---------------------- Helpers ----------------------\n    def _within_bounds(self, pos, bounds):\n        return all(0.0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _path_cost(self, path):\n        return sum(math.dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _neighbors(self, tree, pos):\n        return [n for n in tree if math.dist(n.position, pos) <= self.neighbor_radius]\n\n    def _add_with_best_parent(self, tree, new_pos, obstacles, is_3d, nodes, edges):\n        nearest = self._nearest(tree, new_pos)\n        candidates = self._neighbors(tree, new_pos)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in candidates:\n            if self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                continue\n            cand_cost = nb.cost + math.dist(nb.position, new_pos)\n            if cand_cost < min_cost:\n                min_cost = cand_cost\n                best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, candidates\n\n    def _rewire_from(self, pivot: Node, neighbors, obstacles, is_3d, edges):\n        for nb in neighbors:\n            if self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                continue\n            new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n            if new_cost + 1e-12 < nb.cost:\n                if nb.parent is not None:\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except ValueError:\n                        pass\n                    if nb in nb.parent.children:\n                        nb.parent.children.remove(nb)\n                pivot.add_child(nb)\n                nb.cost = new_cost\n                edges.append((pivot, nb))\n\n    def _connect_with_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        \"\"\"\n        Greedily advance 'tree' toward 'target_node' like RRT-Connect.\n        At each step, insert with best parent and locally rewire.\n        Return the final node in 'tree' placed at target_node.position (if reached), else None.\n        \"\"\"\n        current = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(current.position, target_node.position)\n\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node, neighbors = self._add_with_best_parent(tree, new_pos, obstacles, is_3d, nodes, edges)\n            self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(new_node.position, target_node.position) <= self.step_size:\n                # final short edge\n                if not self._is_edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d) and target_node.valid:\n                    final_node = Node(\n                        target_node.position,\n                        parent=None,\n                        cost=new_node.cost + math.dist(new_node.position, target_node.position)\n                    )\n                    new_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n                return None\n\n            current = new_node\n\n    # ------------------ Informed Sampling ------------------\n    def _sample_informed(self, start, goal, c_best, c_min, bounds):\n        \"\"\"Uniform before first solution; prolate hyperspheroid after (supports 2D/3D).\"\"\"\n        dim = len(bounds)\n        if c_best == float('inf') or c_min <= 1e-12:\n            # uniform in bounds\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # radii along orthonormal basis aligned with start->goal\n        r1 = c_best / 2.0\n        r_other_sq = max(c_best * c_best - c_min * c_min, 0.0)\n        r_other = math.sqrt(r_other_sq) / 2.0\n\n        # center\n        center = tuple((s + g) / 2.0 for s, g in zip(start, goal))\n        # first axis (unit)\n        a1_vec = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n        # orthonormal basis\n        if dim == 2:\n            a2_vec = (-a1_vec[1], a1_vec[0])\n            basis = (a1_vec, a2_vec)\n            radii = (r1, r_other)\n        else:  # dim == 3\n            # pick any non-parallel vector\n            ref = (1.0, 0.0, 0.0) if abs(a1_vec[0]) < 0.9 else (0.0, 1.0, 0.0)\n            # b2 = normalize(cross(a1, ref)), b3 = cross(a1, b2)\n            b2 = self._normalize(self._cross(a1_vec, ref))\n            if self._norm(b2) < 1e-12:\n                ref = (0.0, 0.0, 1.0)\n                b2 = self._normalize(self._cross(a1_vec, ref))\n            b3 = self._cross(a1_vec, b2)\n            basis = (a1_vec, b2, b3)\n            radii = (r1, r_other, r_other)\n\n        # sample unit ball\n        u = self._sample_unit_ball(dim)\n\n        # map: x = center + sum_i (basis_i * radii_i * u_i)\n        mapped = []\n        for d in range(dim):\n            val = center[d]\n            for i in range(dim):\n                val += basis[i][d] * radii[i] * u[i]\n            mapped.append(val)\n\n        # clamp to bounds to be safe\n        mapped = tuple(min(max(mapped[d], 0.0), bounds[d]) for d in range(dim))\n        return mapped\n\n    def _sample_unit_ball(self, dim):\n        # Draw direction from normal distribution and radius with correct PDF\n        while True:\n            vec = [random.gauss(0.0, 1.0) for _ in range(dim)]\n            n = math.sqrt(sum(v * v for v in vec))\n            if n > 1e-12:\n                vec = [v / n for v in vec]\n                r = random.random() ** (1.0 / dim)\n                return tuple(vec[i] * r for i in range(dim))\n\n    def _cross(self, a, b):\n        ax, ay, az = a\n        bx, by, bz = b\n        return (ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx)\n\n    def _norm(self, v):\n        return math.sqrt(sum(x * x for x in v))\n\n    def _normalize(self, v):\n        n = self._norm(v)\n        if n < 1e-12:\n            return v\n        return tuple(x / n for x in v)\n\n    # ------------------ Collision Utilities ------------------\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": 728.0268551361356,
                "time_improvement": -2481.0,
                "length_improvement": 22.0,
                "smoothness_improvement": 637.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 1.1499050855636597,
                        "num_nodes_avg": 453.8,
                        "path_length_avg": 150.36607672434712,
                        "smoothness_avg": 0.03422582042689417,
                        "success_improvement": 0.0,
                        "time_improvement": -4634.957613598991,
                        "length_improvement": 17.581970644423482,
                        "smoothness_improvement": 435.70841223952453,
                        "objective_score": -1377.7595596318454
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.9876691579818726,
                        "num_nodes_avg": 670.7,
                        "path_length_avg": 228.91285104264793,
                        "smoothness_avg": 0.029672116164352454,
                        "success_improvement": 0.0,
                        "time_improvement": -511.69141732906655,
                        "length_improvement": 23.582301430877845,
                        "smoothness_improvement": 663.4849208702007,
                        "objective_score": -136.04061973584226
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 1.1859658002853393,
                        "num_nodes_avg": 549.8,
                        "path_length_avg": 115.13263046293164,
                        "smoothness_avg": 0.0717808135970949,
                        "success_improvement": 0.0,
                        "time_improvement": -2294.887508726318,
                        "length_improvement": 23.53438887323898,
                        "smoothness_improvement": 813.0466506465236,
                        "objective_score": -670.2803860407195
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm with post-optimization: a single-tree, asymptotically optimal sampler that, after the first feasible path, restricts sampling to a start\u2013goal prolate hyperspheroid to accelerate convergence while continuing local rewiring to reduce path cost.",
                "planning_mechanism": "Mechanism: (1) Grow one tree from the start using uniform sampling; (2) when a goal-connecting edge is found, record the best cost and switch to informed sampling inside the ellipsoid defined by start, goal, and current best path length; (3) for each sample, steer a step from the nearest node, then select the lowest-cost parent among nearby nodes and rewire neighbors if the new node offers cheaper paths; (4) whenever the new node lies within one step of the goal and the edge is collision-free, connect and update the best path; (5) after the first solution, continue only a limited number of additional iterations or until no further improvements occur; (6) every candidate node and edge is validated against obstacle occupancy and line-segment collisions, and results include the best path found within the iteration budget.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 post_opt_iters: int = 500, max_no_improve: int = 150,\n                 improve_tol: float = 1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        goal_node = Node(goal)\n        nodes.append(root)\n        tree = [root]\n\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        c_min = math.dist(start, goal)\n\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        for _ in range(self.max_iter):\n            x_rand = self._sample(start, goal, best_cost, c_min, is_3d, bounds)\n\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n            x_new_pos = self._steer(x_nearest.position, x_rand)\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            x_new = Node(x_new_pos)\n            near_nodes = [n for n in tree if math.dist(n.position, x_new_pos) <= 20.0]\n\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near_nodes:\n                new_cost = n.cost + math.dist(n.position, x_new_pos)\n                if new_cost < min_cost and not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                    best_parent = n\n                    min_cost = new_cost\n\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            x_new.parent = best_parent\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            for n in near_nodes:\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost + 1e-12 < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        if n in n.parent.children:\n                            n.parent.children.remove(n)\n                    n.parent = x_new\n                    n.cost = alt_cost\n                    x_new.add_child(n)\n                    edges.append((x_new, n))\n\n            if math.dist(x_new.position, goal) < self.step_size and                not self._is_edge_in_obstacle(x_new.position, goal, obstacles, is_3d):\n                # \uc0c8 \ud574 \ud6c4\ubcf4\n                goal_node = Node(goal)  # \ubaa9\ud45c \ub178\ub4dc\ub294 \uc0c8\ub85c \ub9cc\ub4e4\uc5b4 \uba85\ud655\ud788 \uc5f0\uacb0\n                goal_node.parent = x_new\n                goal_node.cost = x_new.cost + math.dist(x_new.position, goal)\n                nodes.append(goal_node)\n                edges.append((x_new, goal_node))\n\n                if goal_node.cost + self.improve_tol < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    no_improve_streak = 0  \n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0  \n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        if success_state and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample(self, start, goal, c_best, c_min, is_3d, bounds):\n        import numpy as np\n        import math, random\n\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        dim = len(start)\n        L = np.diag([c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1))\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        I = np.eye(dim)\n        M = np.outer(a1, I[:, 0])\n        U, _, Vt = np.linalg.svd(M)\n        C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(x_ball)\n            if norm > 1e-6:\n                x_ball = x_ball / norm * random.random() ** (1.0 / dim)\n            x_rand = np.dot(C, np.dot(L, x_ball)) + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    \n",
                "objective": 254.21494524343552,
                "time_improvement": -899.0,
                "length_improvement": 22.0,
                "smoothness_improvement": 414.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.35683939456939695,
                        "num_nodes_avg": 772.1,
                        "path_length_avg": 150.94653533720216,
                        "smoothness_avg": 0.030245912861543284,
                        "success_improvement": 0.0,
                        "time_improvement": -1369.3555401750432,
                        "length_improvement": 17.263812080762307,
                        "smoothness_improvement": 373.41421633417696,
                        "objective_score": -398.5813037223847
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.6798739194869995,
                        "num_nodes_avg": 1185.7,
                        "path_length_avg": 222.10813211370723,
                        "smoothness_avg": 0.021429118285859527,
                        "success_improvement": 0.0,
                        "time_improvement": -321.06512900112574,
                        "length_improvement": 25.853912472332702,
                        "smoothness_improvement": 451.3866482651889,
                        "objective_score": -78.55025797561215
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.5478150129318238,
                        "num_nodes_avg": 1082.6,
                        "path_length_avg": 114.7698430835218,
                        "smoothness_avg": 0.040749199207674086,
                        "success_improvement": 0.0,
                        "time_improvement": -1006.2336968296382,
                        "length_improvement": 23.77533497656441,
                        "smoothness_improvement": 418.326806128603,
                        "objective_score": -285.51327403230977
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "Hybrid bidirectional RRT* with adaptive neighbor radius, informed ellipsoidal sampling, enhanced rewiring, and dynamic early stopping for improved efficiency, path length, and smoothness. The planner alternates expanding two trees growing from start and goal, focuses sampling inside a prolate hyperspheroid once a solution is found to accelerate convergence, adaptively adjusts the neighbor radius based on node density to balance rewiring cost and solution quality, and employs robust rewiring strategies along with early stopping criteria triggered by stagnation in cost improvement.",
            "planning_mechanism": "The planner initializes two trees from start and goal respectively. It alternates growth between the two trees each iteration by sampling first uniformly and then inside the ellipsoid bounded by current best solution cost. Each new sample is connected with the lowest-cost parent within an adaptive neighbor radius, followed by rewiring of nearby nodes to improve path costs. The opposite tree is greedily connected toward the newly added node using rewiring as well. Upon connecting the two trees, the planner updates the best path and restarts a post-optimization phase with limited iterations or until improvements stall. Using incremental nearest neighbor radius adjustment and strict collision checking, the algorithm efficiently reduces runtime and yields smoother, shorter paths with high success rates.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 6000,\n        step_size: float = 4.0,\n        neighbor_factor: float = 1.5,\n        k_nearest_min: int = 10,\n        post_opt_iters: int = 300,\n        max_no_improve: int = 120,\n        improve_tol: float = 1e-5,\n        time_limit_sec: float = 30.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor  # multiplier for adaptive radius\n        self.k_nearest_min = k_nearest_min  # minimum neighbors for rewiring\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map) -> PlannerResult:\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize trees\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Variables for best path tracking\n        best_cost = float('inf')\n        best_path = []\n        c_min = math.dist(start, goal)\n        found_first_solution = False\n        no_improve_count = 0\n        post_opt_count = 0\n\n        start_time = time.time()\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d_ = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d_:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2, resolution=1.0):\n            dist_p = dist(p1, p2)\n            steps = max(1, int(dist_p / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d_] + (p2[d_] - p1[d_]) * i / steps for d_ in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_informed(c_best):\n            # Uniform until first solution found\n            if c_best == float('inf') or c_min < 1e-12:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Sample inside prolate hyperspheroid defined by start, goal, c_best\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            a1_vec = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            r1 = c_best / 2.0\n            val_sq = max(c_best * c_best - c_min * c_min, 0.0)\n            r_ortho = math.sqrt(val_sq) / 2.0\n\n            # Construct orthonormal basis\n            if dim == 2:\n                a2_vec = (-a1_vec[1], a1_vec[0])\n                basis = (a1_vec, a2_vec)\n                radii = (r1, r_ortho)\n            else:\n                # dim=3\n                def cross(u, v):\n                    return (\n                        u[1]*v[2] - u[2]*v[1],\n                        u[2]*v[0] - u[0]*v[2],\n                        u[0]*v[1] - u[1]*v[0],\n                    )\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                def normalize(v):\n                    n_ = norm(v)\n                    if n_ < 1e-12:\n                        return v\n                    return tuple(x / n_ for x in v)\n                ref = (1.0, 0.0, 0.0) if abs(a1_vec[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = normalize(cross(a1_vec, ref))\n                if norm(b2) < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = normalize(cross(a1_vec, ref))\n                b3 = cross(a1_vec, b2)\n                basis = (a1_vec, b2, b3)\n                radii = (r1, r_ortho, r_ortho)\n\n            # Sample random point in unit n-ball\n            def sample_unit_ball(n):\n                while True:\n                    vec = [random.gauss(0.0, 1.0) for _ in range(n)]\n                    norm_v = math.sqrt(sum(x*x for x in vec))\n                    if norm_v > 1e-12:\n                        vec = [x/norm_v for x in vec]\n                        r = random.random() ** (1.0 / n)\n                        return [x * r for x in vec]\n\n            u = sample_unit_ball(dim)\n            point = [center[d] for d in range(dim)]\n            for i in range(dim):\n                for d_ in range(dim):\n                    point[d_] += basis[i][d_] * radii[i] * u[i]\n            mapped = tuple(min(max(point[d_], 0.0), bounds[d_]) for d_ in range(dim))\n            return mapped\n\n        def nearest(tree, point):\n            # Simple nearest; could be improved with spatial index.\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def neighbors(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def adaptive_radius(num_nodes):\n            # Use formula r = neighbor_factor * (log(n)/n)^{1/dim}\n            # Enforce min radius for initial small trees\n            if num_nodes <= 1:\n                return 30.0\n            val = math.log(num_nodes) / num_nodes\n            if val <= 0.0:\n                return 30.0\n            r = self.neighbor_factor * (val ** (1.0 / dim))\n            # Clamp radius in reasonable bounds\n            return max(min(r, 30.0), 7.0)\n\n        def add_node_with_best_parent(tree, new_pos):\n            # Try best parent minimizing cost + edge validity\n            r = adaptive_radius(len(tree))\n            nbrs = neighbors(tree, new_pos, r)\n            if not nbrs:\n                nearest_node = nearest(tree, new_pos)\n                nbrs = [nearest_node]\n            min_cost = float('inf')\n            best_parent = None\n            for n in nbrs:\n                if is_edge_in_obstacle(n.position, new_pos):\n                    continue\n                cost_ = n.cost + dist(n.position, new_pos)\n                if cost_ < min_cost:\n                    min_cost = cost_\n                    best_parent = n\n            if best_parent is None:\n                return None, []\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, nbrs\n\n        def rewire(node, nbrs, tree):\n            # Rewire neighbors if cheaper cost via node\n            for n in nbrs:\n                if n == node or n.parent is None:\n                    continue\n                if is_edge_in_obstacle(node.position, n.position):\n                    continue\n                new_cost = node.cost + dist(node.position, n.position)\n                if new_cost + 1e-14 < n.cost:\n                    # Remove old edge\n                    if (n.parent, n) in edges:\n                        edges.remove((n.parent, n))\n                    n.parent.remove_child(n)\n                    node.add_child(n)\n                    n.cost = new_cost\n                    edges.append((node, n))\n\n        def greedy_connect(tree, target_node):\n            # Like RRT-Connect: iteratively steer and add with rewiring until close or blocked\n            current = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(current.position, target_node.position)\n                if not within_bounds(new_pos):\n                    return None\n                if is_in_obstacle(new_pos) or is_edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node, nbrs = add_node_with_best_parent(tree, new_pos)\n                if new_node is None:\n                    return None\n                rewire(new_node, nbrs, tree)\n                if dist(new_node.position, target_node.position) <= self.step_size:\n                    # Check final edge connection\n                    if (not is_edge_in_obstacle(new_node.position, target_node.position)) and target_node.valid:\n                        final_node = Node(target_node.position,\n                                         parent=None,\n                                         cost=new_node.cost + dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    return None\n                current = new_node\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            # Alternate tree expansion (connect style)\n            tree_a, tree_b = (start_tree, goal_tree) if (it % 2 == 0) else (goal_tree, start_tree)\n\n            x_rand = sample_informed(best_cost)\n\n            if not within_bounds(x_rand):\n                if found_first_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(x_rand):\n                if found_first_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest_a = nearest(tree_a, x_rand)\n            new_pos = steer(nearest_a.position, x_rand)\n            if not within_bounds(new_pos):\n                if found_first_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest_a.position, new_pos):\n                if found_first_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = add_node_with_best_parent(tree_a, new_pos)\n            if new_node is None:\n                if found_first_solution:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs, tree_a)\n\n            node_b_meet = greedy_connect(tree_b, new_node)\n            if node_b_meet is not None:\n                # Merge path from both trees\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = node_b_meet.path_from_root()\n                else:\n                    path_a = node_b_meet.path_from_root()\n                    path_b = new_node.path_from_root()\n                # Remove duplicate joint node if any\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    full_path = path_a + path_b[-2::-1]\n                else:\n                    full_path = path_a + path_b[::-1]\n\n                cost_path = 0.0\n                for i in range(len(full_path) - 1):\n                    cost_path += dist(full_path[i], full_path[i + 1])\n\n                if cost_path + self.improve_tol < best_cost:\n                    best_cost = cost_path\n                    best_path = full_path\n                    found_first_solution = True\n                    no_improve_count = 0\n                    post_opt_count = 0\n                else:\n                    no_improve_count += 1\n                    post_opt_count += 1\n\n                if found_first_solution and (post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve):\n                    break\n            else:\n                if found_first_solution:\n                    no_improve_count += 1\n                    post_opt_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(\n            success=found_first_solution,\n            path=best_path if found_first_solution else [],\n            nodes=nodes,\n            edges=edges,\n        )",
            "objective": 11.13217,
            "time_improvement": -62.0,
            "length_improvement": 12.0,
            "smoothness_improvement": 68.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.07701032161712647,
                    "num_nodes_avg": 434.2,
                    "path_length_avg": 155.61617858282244,
                    "smoothness_avg": 0.010452144229353361,
                    "success_improvement": 0.0,
                    "time_improvement": -217.10496217866594,
                    "length_improvement": 14.704306622605435,
                    "smoothness_improvement": 63.59875438385533,
                    "objective_score": -55.990910908117236
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.052776336669921875,
                    "num_nodes_avg": 502.5,
                    "path_length_avg": 269.0545941642491,
                    "smoothness_avg": 0.006460910848831797,
                    "success_improvement": 0.0,
                    "time_improvement": 67.31412344086479,
                    "length_improvement": 10.18183216087539,
                    "smoothness_improvement": 66.24388974642639,
                    "objective_score": 26.634555777516802
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0674659013748169,
                    "num_nodes_avg": 505.7,
                    "path_length_avg": 134.37283667640756,
                    "smoothness_avg": 0.013798571007821869,
                    "success_improvement": 0.0,
                    "time_improvement": -36.237692881731306,
                    "length_improvement": 10.755960026414227,
                    "smoothness_improvement": 75.51680471492838,
                    "objective_score": -4.040147825096213
                }
            ],
            "success_rate": 1.0
        },
        "objective": 268.40000000000003,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient and costly nearest and neighbor searches without adaptive spatial structures, leading to longer planning times.\n   - Fixed large neighbor radius causing excessive rewiring attempts without proportional path improvements.\n   - Lack of adaptive rewiring radius and early stopping criteria resulted in unnecessary computations post initial solution.\n   - Simple path merging without smoothing generated paths with abrupt angle changes and reduced smoothness.\n   - Sampling strategies lacked dynamic adaptation to current best path cost, limiting convergence efficiency."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Introduction of adaptive neighbor radius based on node density reducing costly rewiring.\n   - Use of informed sampling within an ellipsoidal region focused on promising areas after the first solution.\n   - Enhanced rewiring logic with robust parent reassignment and pruning of redundant edges improving path quality.\n   - Dynamic early stopping criteria triggered by stagnation in solution improvements, reducing wasted computation.\n   - More conservative step size facilitating finer control during tree extension and smoother path construction.\n\n2. Expected mechanism of impact:\n   - Adaptive radius reduces unnecessary neighbor checks, lowering planning time.\n   - Informed sampling concentrates exploration near the current best path, improving convergence speed and path length.\n   - Advanced rewiring refines tree structure, resulting in shorter and smoother paths by reducing sharp turns and redundant nodes.\n   - Early stopping mechanisms prevent excessive iterations once improvement plateaus, enhancing efficiency.\n   - Smaller step size and careful steering yield smoother, piecewise paths with fewer abrupt changes, enhancing overall smoothness."
        }
    },
    {
        "parents": [
            {
                "operator": "m2",
                "algorithm_description": "This algorithm is an enhanced bidirectional RRT* variant utilizing adaptive neighbor radius based on tree size and iteration progress for improved rewiring efficiency and path optimality. It integrates an ellipsoidal informed sampling strategy after the initial solution to focus exploration within promising regions. The adaptive neighbor radius dynamically contracts with iterations, balancing exploration and exploitation. The connect procedure attempts direct connections to reduce unnecessary intermediate nodes, improving path length and smoothness. Early stopping criteria based on solution improvement stagnation reduce planning time. Consistent node and edge collision checks prevent invalid expansions, maintaining robustness. The algorithm outputs the lowest cost path found within time and iteration limits.",
                "planning_mechanism": "The planner grows two trees from start and goal positions, alternating expansions each iteration. Initially, it samples uniformly, then focuses sampling inside an ellipsoid defined by current best path cost. Each expansion attempts to add a new node via steering and selects the best parent considering nodes within an adaptive radius that decreases as iterations proceed. Local rewiring optimizes neighbors' connections when beneficial. A direct connect is attempted between the newly added node and the opposite tree to quickly form a solution. The best path is updated when trees meet. The planning stops early if no significant improvements occur over a threshold or upon timeout.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # Tuple[float, ...]\n        self.parent = parent      # Node or None\n        self.cost = cost          # cost from root to this node\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=4.0,\n        max_neighbor_radius=30.0,\n        min_neighbor_radius=6.0,\n        improvement_tol=1e-6,\n        max_no_improve=100,\n        time_limit_sec=30.0,\n        post_opt_iters=300\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n        self.improvement_tol = improvement_tol\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.post_opt_iters = post_opt_iters\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_first = False\n        no_improve_count = 0\n        post_opt_count = 0\n        start_time = time.time()\n\n        def adaptive_radius(n, iter_i):\n            # Adaptive radius contracts as iteration increases, ensuring fewer neighbors later for efficiency\n            # Weighted blend with tree size and iteration progress\n            factor = max(0.0, 1.0 - iter_i / self.max_iter)\n            radius = max(self.min_neighbor_radius, min(self.max_neighbor_radius, self.max_neighbor_radius*factor*(math.log(n+1)/(n+1))**(1/dim)))\n            return radius\n\n        def within_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_p, to_p, resolution=1.0):\n            dist = math.dist(from_p, to_p)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d])*i/steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def neighbors(tree, pos, radius):\n            radius_sq = radius*radius\n            return [n for n in tree if ( (sum((n.position[d] - pos[d])**2 for d in range(dim))) <= radius_sq )]\n\n        def choose_parent_and_add(tree, new_pos, iter_i):\n            n = len(tree)\n            radius = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, new_pos, radius)\n\n            nearest = min(tree, key=lambda node: math.dist(node.position, new_pos))\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for nb in nbrs:\n                if is_edge_in_obstacle(nb.position, new_pos):\n                    continue\n                c = nb.cost + math.dist(nb.position, new_pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = nb\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, nbrs, radius\n\n        def rewire(pivot, neighbors_list):\n            for nb in neighbors_list:\n                if is_edge_in_obstacle(pivot.position, nb.position):\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    # Rewire nb to pivot\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n        def direct_connect(tree, target_node, iter_i):\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            # attempt a direct connection from nearest to target_node if possible\n            if (not is_edge_in_obstacle(nearest.position, target_node.position) and\n                not is_in_obstacle(target_node.position)):\n                # connect with one edge\n                new_node = Node(target_node.position, cost=nearest.cost + math.dist(nearest.position, target_node.position))\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n                return new_node\n\n            # else do incremental connection with steering and rewiring\n            current = nearest\n            for _ in range( int(math.ceil(math.dist(current.position, target_node.position) / self.step_size)) ):\n                new_pos = steer(current.position, target_node.position)\n                if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node, nbrs, _ = choose_parent_and_add(tree, new_pos, iter_i)\n                rewire(new_node, nbrs)\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    if not is_edge_in_obstacle(new_node.position, target_node.position) and not is_in_obstacle(target_node.position):\n                        final_node = Node(target_node.position,\n                                          cost=new_node.cost + math.dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n            return None\n\n        def sample_informed():\n            if not found_first or best_cost == float('inf') or c_min < 1e-12:\n                # uniform sampling\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # else sample inside prolate hyperspheroid:\n            # center\n            center = tuple((start_pos[d] + goal_pos[d])/2.0 for d in range(dim))\n            # unit direction vector from start to goal\n            unit_dir = []\n            dist_sg = c_min\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / dist_sg)\n            # radii\n            r1 = best_cost / 2.0\n            val = best_cost*best_cost - c_min*c_min\n            val = max(val, 0.0)\n            r_other = math.sqrt(val) / 2.0\n\n            # construct orthonormal basis\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                a1 = unit_dir\n                # pick reference vector not parallel to a1\n                ref = (1.0,0.0,0.0) if abs(a1[0]) < 0.9 else (0.0,1.0,0.0)\n                b2 = _cross(a1, ref)\n                n_b2 = _norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0.0,0.0,1.0)\n                    b2 = _cross(a1, ref)\n                    n_b2 = _norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = _cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            u = _sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                # clamp inside bounds\n                val = min(max(val, 0.0), bounds[d])\n                mapped.append(val)\n            return tuple(mapped)\n\n        def _sample_unit_ball(dim):\n            while True:\n                vec = [random.gauss(0.0, 1.0) for _ in range(dim)]\n                nrm = math.sqrt(sum(v*v for v in vec))\n                if nrm < 1e-12:\n                    continue\n                vec = [v/nrm for v in vec]\n                r = random.random()**(1.0/dim)\n                return tuple(vec[i]*r for i in range(dim))\n\n        def _cross(a,b):\n            return (a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0])\n\n        def _norm(v):\n            return math.sqrt(sum(x*x for x in v))\n\n        neighbor_radius_cache = None\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if (it % 2 == 0) else (goal_tree, start_tree)\n            x_rand = sample_informed()\n\n            if not within_bounds(x_rand) or is_in_obstacle(x_rand):\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest.position, new_pos):\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, neighbors_list, nradius = choose_parent_and_add(tree_a, new_pos, it)\n            rewire(new_node, neighbors_list)\n\n            # Attempt direct connect (not iterative connect) from tree_b to newly added node:\n            meet_node = direct_connect(tree_b, new_node, it)\n            if meet_node is not None:\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = sum(math.dist(merged_path[i], merged_path[i+1]) for i in range(len(merged_path)-1))\n                if total_cost + self.improvement_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_first = True\n                    post_opt_count = 0\n                    no_improve_count = 0\n                else:\n                    if found_first:\n                        post_opt_count += 1\n                        no_improve_count += 1\n                if found_first and (post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve):\n                    break\n            else:\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(success=found_first, path=best_path, nodes=nodes, edges=edges)",
                "objective": -10.44388,
                "time_improvement": 10.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 142.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.02786121368408203,
                        "num_nodes_avg": 139.4,
                        "path_length_avg": 155.87313188725165,
                        "smoothness_avg": 0.017886324975422283,
                        "success_improvement": 0.0,
                        "time_improvement": -14.723960710972353,
                        "length_improvement": 14.563466444762122,
                        "smoothness_improvement": 179.95982664171103,
                        "objective_score": 5.220690786774123
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.06340575218200684,
                        "num_nodes_avg": 418.9,
                        "path_length_avg": 277.6271906369829,
                        "smoothness_avg": 0.008053558435153495,
                        "success_improvement": 0.0,
                        "time_improvement": 60.731026067193284,
                        "length_improvement": 7.320052709768729,
                        "smoothness_improvement": 107.22385928017246,
                        "objective_score": 23.14745874242008
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.05672965049743652,
                        "num_nodes_avg": 331.4,
                        "path_length_avg": 133.93060882634086,
                        "smoothness_avg": 0.018882342363182564,
                        "success_improvement": 0.0,
                        "time_improvement": -14.557377049180326,
                        "length_improvement": 11.049666707801231,
                        "smoothness_improvement": 140.18200111014838,
                        "objective_score": 2.9634969154773834
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
                "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -18.199350067879823,
                "time_improvement": 67.0,
                "length_improvement": -4.0,
                "smoothness_improvement": 78.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.009241986274719238,
                        "num_nodes_avg": 98.6,
                        "path_length_avg": 188.60059541559173,
                        "smoothness_avg": 0.011107369580525531,
                        "success_improvement": 0.0,
                        "time_improvement": 61.94432581815326,
                        "length_improvement": -3.3749749149674124,
                        "smoothness_improvement": 73.85445397432328,
                        "objective_score": 16.927585066337148
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.013762164115905761,
                        "num_nodes_avg": 215.1,
                        "path_length_avg": 298.4716236591105,
                        "smoothness_avg": 0.007330142954732018,
                        "success_improvement": 0.0,
                        "time_improvement": 91.47670289636794,
                        "length_improvement": 0.3615809932444448,
                        "smoothness_improvement": 88.6098579138185,
                        "objective_score": 28.103008754426142
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.02535843849182129,
                        "num_nodes_avg": 323.5,
                        "path_length_avg": 164.19293370544943,
                        "smoothness_avg": 0.013510302519313377,
                        "success_improvement": 0.0,
                        "time_improvement": 48.79227750896705,
                        "length_improvement": -9.049128539847096,
                        "smoothness_improvement": 71.85005081886685,
                        "objective_score": 9.567456382876191
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "An improved bidirectional RRT* planner using adaptive neighborhood radius, efficient KD-tree nearest neighbor searches, and integrated batch rewiring for path quality refinement. Sampling alternates between uniform exploration and informed ellipsoidal regions defined by current best path cost to focus search. The planner performs incremental expansions with collision checks, rewires neighbors for cost improvement, and attempts direct connection between trees to quickly form solutions. Early stopping occurs after no significant improvement. Path extraction follows parent pointers from merged connecting nodes for a smooth, optimized path.",
            "planning_mechanism": "The planner grows two trees from start and goal positions, expanding alternately. It samples points uniformly or inside an ellipsoid when a solution exists. Expansion picks the best parent within an adaptive radius, then rewires neighbors to lower cost paths. After each expansion, it attempts a direct connection to the opposite tree. If a path is found, it updates the best solution and focuses sampling accordingly. Early stopping criteria reduce runtime. The output is the optimized path with recorded nodes and edges.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=4.0, max_neighbor_radius=30.0,\n                 min_neighbor_radius=5.0, improvement_tol=1e-5, max_no_improve=100,\n                 time_limit_sec=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n        self.improvement_tol = improvement_tol\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n        def edge_in_obstacle(a,b,res=1.0):\n            dist = math.dist(a,b)\n            if dist < 1e-12: return False\n            steps = max(2, int(dist/res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n        def steer(a,b):\n            dist = math.dist(a,b)\n            if dist <= self.step_size:\n                return b\n            ratio = self.step_size / dist\n            return tuple(a[d] + (b[d]-a[d])*ratio for d in range(dim))\n\n        # KD-tree for nearest neighbor search\n        class KDNode:\n            def __init__(self, points, depth=0):\n                self.axis = depth % dim\n                self.left = None\n                self.right = None\n                self.node = None\n                if not points:\n                    return\n                points.sort(key=lambda n: n.position[self.axis])\n                median = len(points)//2\n                self.node = points[median]\n                left_points = points[:median]\n                right_points = points[median+1:]\n                if left_points:\n                    self.left = KDNode(left_points, depth+1)\n                if right_points:\n                    self.right = KDNode(right_points, depth+1)\n            def nearest(self, point, best=None, best_dist=float('inf')):\n                if self.node is None:\n                    return best, best_dist\n                d = math.dist(self.node.position, point)\n                if d < best_dist:\n                    best = self.node\n                    best_dist = d\n                diff = point[self.axis] - self.node.position[self.axis]\n                close, away = (self.left, self.right) if diff < 0 else (self.right, self.left)\n                if close:\n                    best, best_dist = close.nearest(point, best, best_dist)\n                if away and abs(diff) < best_dist:\n                    best, best_dist = away.nearest(point, best, best_dist)\n                return best, best_dist\n\n        def build_kdtree(nodes):\n            if not nodes:\n                return None\n            return KDNode(nodes)\n\n        def kdtree_nearest(tree, point):\n            if not tree:\n                return None\n            node, _ = tree.nearest(point)\n            return node\n\n        def dist_sq(a,b):\n            return sum((a[d]-b[d])**2 for d in range(dim))\n\n        def neighbors_within_radius(tree, point, radius):\n            radius_sq = radius*radius\n            result = []\n            stack = [tree]\n            while stack:\n                node = stack.pop()\n                if node is None or node.node is None:\n                    continue\n                pos = node.node.position\n                if dist_sq(pos, point) <= radius_sq:\n                    result.append(node.node)\n                diff = point[node.axis] - pos[node.axis]\n                if diff < 0:\n                    stack.append(node.left)\n                    if diff*diff < radius_sq:\n                        stack.append(node.right)\n                else:\n                    stack.append(node.right)\n                    if diff*diff < radius_sq:\n                        stack.append(node.left)\n            return result\n\n        def adaptive_radius(n, iter_i):\n            if n == 0:\n                return self.max_neighbor_radius\n            factor = max(0.25, 1.0 - iter_i / self.max_iter)\n            r = self.max_neighbor_radius * factor * math.sqrt(math.log(n+1)/(n+1))\n            return max(self.min_neighbor_radius, min(self.max_neighbor_radius, r))\n\n        def sample_uniform():\n            return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n        def sample_informed():\n            if best_cost == float('inf') or c_min < 1e-12 or not found_first:\n                return sample_uniform()\n            center = tuple((start_pos[d]+goal_pos[d])*0.5 for d in range(dim))\n            unit_vector = [(goal_pos[d]-start_pos[d])/c_min for d in range(dim)]\n            r1 = best_cost * 0.5\n            val = best_cost*best_cost - c_min*c_min\n            r_other = math.sqrt(max(val,0))*0.5\n            # 2D or 3D basis\n            if dim == 2:\n                a1 = unit_vector\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_vector\n                ref = (1,0,0) if abs(a1[0])<0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x/n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1,b2,b3)\n                radii = (r1,r_other,r_other)\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    unit_vec = [v/nrm for v in vec]\n                    r = random.random()**(1.0/dim)\n                    return [unit_vec[i]*r for i in range(dim)]\n            u = sample_unit_ball(dim)\n            res = [center[d]+sum(basis[i][d]*radii[i]*u[i] for i in range(dim)) for d in range(dim)]\n            # clamp\n            return tuple(min(max(0.0,res[d]),bounds[d]) for d in range(dim))\n\n        def choose_parent_and_add(tree, pos, iter_i):\n            n = len(tree)\n            radius = adaptive_radius(n, iter_i)\n            kdt = build_kdtree(tree)\n            near_nodes = neighbors_within_radius(kdt, pos, radius) if kdt else []\n            nearest = min(tree, key=lambda node: math.dist(node.position, pos))\n            min_cost = nearest.cost + math.dist(nearest.position,pos)\n            best_par = nearest\n            for nb in near_nodes:\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                c = nb.cost + math.dist(nb.position, pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_par = nb\n            new_node = Node(pos, cost=min_cost)\n            best_par.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_par, new_node))\n            return new_node, near_nodes\n\n        def rewire(pivot, near_nodes):\n            for nb in near_nodes:\n                if nb is pivot.parent:\n                    continue\n                if edge_in_obstacle(pivot.position, nb.position):\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n        def try_connect(tree, target_node):\n            kdt = build_kdtree(tree)\n            nearest = kdt.nearest(target_node.position)[0] if kdt else None\n            if nearest is None:\n                return None\n            if not edge_in_obstacle(nearest.position, target_node.position) and not in_obstacle(target_node.position):\n                new_node = Node(target_node.position, cost=nearest.cost+math.dist(nearest.position, target_node.position))\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest,new_node))\n                return new_node\n            cur = nearest\n            dist_total = math.dist(cur.position, target_node.position)\n            steps = int(math.ceil(dist_total/self.step_size))\n            for _ in range(steps):\n                new_pos = steer(cur.position, target_node.position)\n                if (not in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(cur.position, new_pos):\n                    return None\n                new_node, near_nodes = choose_parent_and_add(tree, new_pos, 0)\n                rewire(new_node, near_nodes)\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    if not edge_in_obstacle(new_node.position, target_node.position) and not in_obstacle(target_node.position):\n                        final_node = Node(target_node.position,\n                                          cost=new_node.cost+math.dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node,final_node))\n                        return final_node\n                    else:\n                        return None\n                cur = new_node\n            return None\n\n        def extract_path(node_from_start, node_from_goal, reversed_branch):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()\n            # merge properly without duplicating middle point\n            if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                return path_start + path_goal[-2::-1] if reversed_branch else path_start + path_goal[-2::-1]\n            return path_start + path_goal[::-1]\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_first = False\n        no_improve_count = 0\n        start_time = time.time()\n\n        for iter_i in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            x_rand = sample_informed()\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_first:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if (not in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_first:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, near_nodes = choose_parent_and_add(tree_a, new_pos, iter_i)\n            rewire(new_node, near_nodes)\n\n            meet_node = try_connect(tree_b, new_node)\n            if meet_node is not None:\n                reversed_branch = (iter_i % 2 != 0)\n                candidate_path = extract_path(new_node, meet_node, reversed_branch)\n                cost_path = sum(math.dist(candidate_path[i], candidate_path[i+1]) for i in range(len(candidate_path)-1))\n                if cost_path + self.improvement_tol < best_cost:\n                    best_cost = cost_path\n                    best_path = candidate_path\n                    found_first = True\n                    no_improve_count = 0\n                else:\n                    if found_first:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_first:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(success=found_first, path=best_path, nodes=nodes, edges=edges)",
            "objective": 31.3389,
            "time_improvement": -128.0,
            "length_improvement": 11.0,
            "smoothness_improvement": 123.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.049280643463134766,
                    "num_nodes_avg": 193.7,
                    "path_length_avg": 159.42829900434148,
                    "smoothness_avg": 0.015782508309550324,
                    "success_improvement": 0.0,
                    "time_improvement": -102.92262456987744,
                    "length_improvement": 12.614823012657153,
                    "smoothness_improvement": 147.0305273098034,
                    "objective_score": -22.572740926819925
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.09595170021057128,
                    "num_nodes_avg": 359.6,
                    "path_length_avg": 272.5345381516294,
                    "smoothness_avg": 0.007447989450209298,
                    "success_improvement": 0.0,
                    "time_improvement": 40.57440082783746,
                    "length_improvement": 9.02012669325395,
                    "smoothness_improvement": 91.6421331238487,
                    "objective_score": 18.04260692992285
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.20817940235137938,
                    "num_nodes_avg": 397.9,
                    "path_length_avg": 135.5776476160814,
                    "smoothness_avg": 0.01818395158978751,
                    "success_improvement": 0.0,
                    "time_improvement": -320.388387376327,
                    "length_improvement": 9.955781967214673,
                    "smoothness_improvement": 131.29852202240792,
                    "objective_score": -89.48655442245725
                }
            ],
            "success_rate": 1.0
        },
        "objective": 81.39999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient neighbor search due to lack of advanced spatial data structures, leading to slower planning.\n   - Incomplete or simplistic rewiring strategies that do not fully optimize path cost or smoothness.\n   - Exploration methods that do not adequately focus sampling around promising regions, causing longer convergence times.\n   - Incremental tree connection approaches that can miss better tree merging opportunities, leading to suboptimal paths.\n   - Path extraction methods that concatenate paths without effective smoothing or shortcutting, resulting in less smooth trajectories."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Integration of efficient nearest neighbor queries using KD-tree spatial indexing structures.\n   - Adoption of informed sampling strategies to concentrate exploration within ellipsoidal regions defined by current best solution costs.\n   - More robust rewiring mechanisms that leverage neighbor sets within adaptive radii for incremental cost and smoothness improvements.\n   - Enhanced tree connection attempts combining direct connection with incremental steering steps and rewiring.\n2. Expected mechanism of impact:\n   - KD-tree usage drastically reduces computational overhead for nearest neighbor searches, accelerating planning times.\n   - Informed sampling focuses computational effort on relevant regions, improving convergence speed and path quality.\n   - Adaptive rewiring refines path segments iteratively, reducing path length and significantly increasing smoothness.\n   - More flexible tree merging captures better connection points, leading to shorter and better optimized paths."
        }
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
                "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost: float = 0.0):\n        self.position = position              # Tuple[float, ...]\n        self.parent: Optional[\"Node\"] = parent\n        self.cost: float = cost\n        self.children: List[\"Node\"] = []\n        self.valid = True\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(\n        self,\n        max_iter: int = 5000,\n        step_size: float = 5.0,\n        gamma_rrt_star: float = 50.0,\n        max_radius: float = 60.0,\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma_rrt_star = gamma_rrt_star\n        self.max_radius = max_radius\n\n    # ======================= Public API =======================\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, parent=None, cost=0.0)\n        goal_root  = Node(goal_position,  parent=None, cost=0.0)\n        nodes.extend([start_root, goal_root])\n\n        tree_a: List[Node] = [start_root]\n        tree_b: List[Node] = [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, bounds)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges, bounds)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    path_b = path_b[:-1]\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree: List[Node], point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree: List[Node], position, bounds) -> List[Node]:\n        n = max(1, len(tree))\n        d = len(position)\n        # \uacf5\uac04 \uc2a4\ucf00\uc77c\uc744 \uac04\ub2e8\ud788 bounds\ub85c \ucd94\uc815 (\uc815\ubc00 X, \uc2e4\uc6a9\uc801)\n        scale = max(1.0, sum(bounds) / d)\n        r_theory = self.gamma_rrt_star * ((math.log(n + 1) / (n + 1)) ** (1.0 / d))\n        radius = max(self.step_size * 2.0, min(self.max_radius, r_theory * 0.5 + scale * 0.02))\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _choose_parent_and_add(self, tree, new_pos, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, new_pos)\n        neighbors = self._near_nodes(tree, new_pos, bounds)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cand = nb.cost + math.dist(nb.position, new_pos)\n                if cand < min_cost:\n                    min_cost = cand\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        return new_node, neighbors\n\n    def _rewire_from(self, pivot: Node, neighbors: List[Node], obstacles, is_3d, edges):\n        for nb in neighbors:\n            if not self._is_edge_in_obstacle(pivot.position, nb.position, obstacles, is_3d):\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:  # \uc791\uc740 \uc218\uce58 \ubc84\ud37c\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n    def _extend_and_rewire(self, tree, sample_point, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, sample_point)\n        new_pos = self._steer(nearest.position, sample_point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n        self._rewire_from(new_node, neighbors, obstacles, is_3d, edges)\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node: Node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree, target_node.position)\n\n        while True:\n            new_pos = self._steer(nearest.position, target_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node, neighbors = self._choose_parent_and_add(tree, new_pos, obstacles, is_3d, nodes, edges, bounds)\n            self._rewire_from(connect_node, neighbors, obstacles, is_3d, edges)\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                if (not self._is_edge_in_obstacle(connect_node.position, target_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                    final_node = Node(target_node.position, parent=None, cost=connect_node.cost + math.dist(connect_node.position, target_node.position))\n                    connect_node.add_child(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((connect_node, final_node))\n                    return final_node\n                else:\n                    return None\n\n            nearest = connect_node\n\n        \n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n        \n        \n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -22.142109273517423,
                "time_improvement": 49.0,
                "length_improvement": 11.0,
                "smoothness_improvement": 177.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.018251991271972655,
                        "num_nodes_avg": 78.7,
                        "path_length_avg": 175.55592835957023,
                        "smoothness_avg": 0.017196193462405217,
                        "success_improvement": 0.0,
                        "time_improvement": 24.843879619675935,
                        "length_improvement": 3.775013804415195,
                        "smoothness_improvement": 169.1577698184268,
                        "objective_score": 10.563961017644031
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.04780585765838623,
                        "num_nodes_avg": 302.9,
                        "path_length_avg": 259.03658233660315,
                        "smoothness_avg": 0.01078988487631875,
                        "success_improvement": 0.0,
                        "time_improvement": 70.39248153962646,
                        "length_improvement": 13.526132861425937,
                        "smoothness_improvement": 177.6315095076258,
                        "objective_score": 30.121581726281626
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.023344540596008302,
                        "num_nodes_avg": 176.0,
                        "path_length_avg": 128.09376742543256,
                        "smoothness_avg": 0.022442540549775757,
                        "success_improvement": 0.0,
                        "time_improvement": 52.85905490960737,
                        "length_improvement": 14.926218845764677,
                        "smoothness_improvement": 185.467459257119,
                        "objective_score": 25.74078507662661
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
                "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -18.199350067879823,
                "time_improvement": 67.0,
                "length_improvement": -4.0,
                "smoothness_improvement": 78.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.009241986274719238,
                        "num_nodes_avg": 98.6,
                        "path_length_avg": 188.60059541559173,
                        "smoothness_avg": 0.011107369580525531,
                        "success_improvement": 0.0,
                        "time_improvement": 61.94432581815326,
                        "length_improvement": -3.3749749149674124,
                        "smoothness_improvement": 73.85445397432328,
                        "objective_score": 16.927585066337148
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.013762164115905761,
                        "num_nodes_avg": 215.1,
                        "path_length_avg": 298.4716236591105,
                        "smoothness_avg": 0.007330142954732018,
                        "success_improvement": 0.0,
                        "time_improvement": 91.47670289636794,
                        "length_improvement": 0.3615809932444448,
                        "smoothness_improvement": 88.6098579138185,
                        "objective_score": 28.103008754426142
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.02535843849182129,
                        "num_nodes_avg": 323.5,
                        "path_length_avg": 164.19293370544943,
                        "smoothness_avg": 0.013510302519313377,
                        "success_improvement": 0.0,
                        "time_improvement": 48.79227750896705,
                        "length_improvement": -9.049128539847096,
                        "smoothness_improvement": 71.85005081886685,
                        "objective_score": 9.567456382876191
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m1",
            "algorithm_description": "A bidirectional RRT* inspired planner that grows two trees from start and goal with rewiring and dynamic neighbor radius, incorporating path shortcutting after connection to reduce path length and improve smoothness while ensuring collision-free nodes and edges throughout. It balances exploration and optimization, seeks lowest cost connections, and maintains efficient updates for paths and parents.",
            "planning_mechanism": "The planner samples collision-free points within the map bounds, extends the nearest node of one tree towards the sample, rewires neighbors for lower-cost paths, and attempts to connect the other tree to the newly added node with rewiring as well. Upon connection, a path is extracted and post-processed with shortcutting to smooth and shorten it. The rewiring radius adapts with the tree size to balance exploration and optimization. This enables efficient bidirectional growth with asymptotic optimality and improved path quality.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=50.0, max_rewire_radius=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_rewire_radius = max_rewire_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        final_path = []\n\n        for iter in range(self.max_iter):\n            sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate trees for growth each iteration\n            if iter % 2 == 0:\n                new_node = self._extend_tree(tree_start, tree_goal, sample, obstacles, is_3d, nodes, edges, bounds)\n                if new_node:\n                    conn_node = self._connect_tree(tree_goal, new_node, obstacles, is_3d, nodes, edges, bounds)\n                    if conn_node:\n                        success = True\n                        path_start = new_node.path_from_root()\n                        path_goal = conn_node.path_from_root()\n                        if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                            path_goal = path_goal[:-1]\n                        merged_path = path_start + path_goal[::-1]\n                        final_path = self._shortcut_path(merged_path, obstacles, is_3d, bounds)\n                        break\n            else:\n                new_node = self._extend_tree(tree_goal, tree_start, sample, obstacles, is_3d, nodes, edges, bounds)\n                if new_node:\n                    conn_node = self._connect_tree(tree_start, new_node, obstacles, is_3d, nodes, edges, bounds)\n                    if conn_node:\n                        success = True\n                        path_goal = new_node.path_from_root()\n                        path_start = conn_node.path_from_root()\n                        if path_goal and path_start and path_goal[-1] == path_start[-1]:\n                            path_start = path_start[:-1]\n                        merged_path = path_goal + path_start[::-1]\n                        final_path = self._shortcut_path(merged_path, obstacles, is_3d, bounds)\n                        break\n\n        return PlannerResult(success, final_path, nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near(self, tree, point, bounds):\n        n = len(tree)\n        d = len(point)\n        if n == 0:\n            return []\n        r_ddl = self.gamma * ((math.log(n) / n) ** (1.0 / d)) if n > 1 else self.step_size * 2\n        radius = max(self.step_size * 2, min(self.max_rewire_radius, r_ddl))\n        near_nodes = [node for node in tree if self._dist(node.position, point) <= radius]\n        return near_nodes\n\n    def _extend_tree(self, tree_to_extend, other_tree, sample, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree_to_extend, sample)\n        new_pos = self._steer(nearest.position, sample)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        near_nodes = self._near(tree_to_extend, new_pos, bounds)\n\n        # Choose best parent among neighbors (including nearest) with minimal cost\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in near_nodes:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost_through_nb = nb.cost + self._dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree_to_extend.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new node if cheaper and collision-free edge\n        for nb in near_nodes:\n            if nb == best_parent:\n                continue\n            if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                cost_through_new = new_node.cost + self._dist(new_node.position, nb.position)\n                if cost_through_new + 1e-12 < nb.cost:\n                    # Reassign parent\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = cost_through_new\n                    edges.append((new_node, nb))\n\n        return new_node\n\n    def _connect_tree(self, tree_to_connect, target_node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree_to_connect, target_node.position)\n\n        new_pos = target_node.position\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        near_nodes = self._near(tree_to_connect, new_pos, bounds)\n\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in near_nodes:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost_through_nb = nb.cost + self._dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree_to_connect.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for nb in near_nodes:\n            if nb == best_parent:\n                continue\n            if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                cost_through_new = new_node.cost + self._dist(new_node.position, nb.position)\n                if cost_through_new + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = cost_through_new\n                    edges.append((new_node, nb))\n\n        return new_node\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path[:]\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened\n\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
            "objective": -16.5554,
            "time_improvement": -1.0,
            "length_improvement": 16.0,
            "smoothness_improvement": 1439.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.050579285621643065,
                    "num_nodes_avg": 106.8,
                    "path_length_avg": 164.2712937810431,
                    "smoothness_avg": 0.04226815816929853,
                    "success_improvement": 0.0,
                    "time_improvement": -108.27003598058127,
                    "length_improvement": 9.960300833383796,
                    "smoothness_improvement": 561.5884621240848,
                    "objective_score": -23.69688798352368
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.049871516227722165,
                    "num_nodes_avg": 224.9,
                    "path_length_avg": 237.86532514731707,
                    "smoothness_avg": 0.10161854011327172,
                    "success_improvement": 0.0,
                    "time_improvement": 69.11316081994654,
                    "length_improvement": 20.593707892059786,
                    "smoothness_improvement": 2514.7182299904466,
                    "objective_score": 45.66376413117207
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03152651786804199,
                    "num_nodes_avg": 152.6,
                    "path_length_avg": 123.96994519489405,
                    "smoothness_avg": 0.10533489541470797,
                    "success_improvement": 0.0,
                    "time_improvement": 36.33672757035219,
                    "length_improvement": 17.66506521597572,
                    "smoothness_improvement": 1239.8520946618717,
                    "objective_score": 27.699317874000446
                }
            ],
            "success_rate": 1.0
        },
        "objective": 358.59999999999997,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient nearest neighbor searches and rewiring operations performed via linear scans, leading to increased computational overhead.\n   - Incremental tree connection methods that add many intermediate nodes without effective path shortening or smoothing, resulting in longer and more complex paths.\n   - Limited or absent post-connection path optimization causing jagged and suboptimal trajectories with abrupt turns."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Implementation of adaptive rewiring radius and dynamic neighbor selection based on tree size and dimensionality, enhancing efficient local connectivity.\n   - Bidirectional tree growth with rewiring on both tree extension and connection steps, enabling continuous path cost improvements.\n   - Inclusion of post processing path shortcutting to remove unnecessary waypoints and smooth trajectories.\n2. Expected mechanism of impact:\n   - Adaptive neighbor radius reduces unnecessary collision checks and data structure manipulations, improving planning time efficiency.\n   - Rewiring both trees fosters improved path quality and reduces path complexity and length.\n   - Shortcutting efficiently smooths and shortens paths, significantly enhancing smoothness while preserving collision-free guarantees."
        }
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "An enhanced bidirectional RRT* variant that incorporates adaptive neighbor radius shrinking to concentrate rewiring efforts for local optimality, an efficient nearest-neighbor caching structure for faster lookups, and progressive informed sampling with dynamic ellipsoidal restriction. The planner prioritizes early discovery and incremental path improvement, applies a smooth path shortcutting post-processing step to reduce path length and curvature, and enforces robust termination criteria based on stagnation and solution quality thresholds to minimize planning time.",
                "planning_mechanism": "The planner grows two trees alternately with rewiring using an adaptive radius, restricts sampling progressively to a shrinking ellipsoid after finding a solution to focus on promising areas, connects the trees upon proximity, and applies a final shortcut smoothing pass to improve total path length and smoothness before returning the best feasible path found within iteration and time limits.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, n_near_const=35, \n                 max_no_improve=80, improve_tol=1e-6, shortcut_iters=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const  # base neighbor count for adaptive radius\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        # --- Local helper imports & definitions ---\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        dist = lambda a, b: math.dist(a, b)\n\n        # Node collections\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        # To reduce overhead of nearest neighbor search, cache all nodes' positions lists for faster processing\n        # We implement simple linear searches but with caching and limit radius dynamically to reduce checks\n\n        # Adaptive radius for near-node rewiring, shrinks with best_cost to focus local improvements\n        # r_n = min((gamma * (log(n)/n))^(1/d), max_radius) but approximate w/o logs for lightweight\n        def adaptive_radius(n_nodes, c_best):\n            # Use gamma ~ 30 (typical for 2D), avoid zero or undefined\n            gamma = self.n_near_const\n            if n_nodes == 0:\n                return self.step_size * 2.5\n            r = min((gamma * (math.log(n_nodes)/n_nodes))**(1/dim), self.step_size * 5)\n            # Shrink with c_best, stronger around best solution to focus rewiring\n            if c_best == float('inf'):\n                return r\n            shrink_factor = max(0.25, c_best / (c_min * 3))\n            return max(self.step_size*0.75, r * shrink_factor)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-10:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[j] + (t[j] - f[j]) * (i / steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        # Efficient nearest neighbor search (linear but with early exit)\n        def nearest(tree, p):\n            best = None\n            best_d = float('inf')\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 >= best_d*best_d:\n                        break\n                else:\n                    d = math.sqrt(d2)\n                    if d < best_d:\n                        best = n\n                        best_d = d\n            return best\n\n        # Near nodes within radius (adaptive radius)\n        def near_nodes(tree, p, radius):\n            r2 = radius*radius\n            result = []\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 > r2:\n                        break\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        # Extract path from start via parent chain\n        def extract_path(node_start_root):\n            return node_start_root.path_from_root()\n\n        # Extract full path from two connection nodes (start tree and goal tree)\n        def connect_path(n_start, n_goal):\n            path_start = extract_path(n_start)\n            path_goal_rev = extract_path(n_goal)\n            path_goal = path_goal_rev[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        # Ellipsoidal informed sampling centered between start and goal, focused progressively as c_best shrinks\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-12:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Orthonormal basis U with unit_a1 first vector\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0] * dim\n                base[(idx + 1) % dim] = 1\n                for u in U:\n                    proj = sum(base[j] * u[j] for j in range(dim))\n                    base = [base[j] - proj * u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-12:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0] * dim)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-12:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n                point_scaled = [radii[i] * point_ball[i] for i in range(dim)]\n\n                point_rotated = [0.0] * dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i] * U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        # Path shortcutting by attempting to connect non-adjacent nodes directly if collision free\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                changed = False\n                iter_count += 1\n                i = 0\n                while i < len(path) - 2:\n                    j = min(len(path) - 1, i + 2 + random.randint(0, 3))\n                    if j > i + 1 and not edge_obstacle(path[i], path[j]):\n                        # Shortcut feasible, remove intermediate nodes\n                        path = path[:i + 1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Add node to tree selecting best parent among near nodes\n        def add_node(tree, new_pos, nodes_all, edges, c_best):\n            nn = nearest(tree, new_pos)\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(nodes_all)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos_steered, radius)\n\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos_steered)\n            for near_node in near:\n                if near_node == nn:\n                    continue\n                cand_cost = near_node.cost + dist(near_node.position, new_pos_steered)\n                if cand_cost + self.improve_tol < best_cost and not edge_obstacle(near_node.position, new_pos_steered):\n                    best_parent = near_node\n                    best_cost = cand_cost\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if beneficial\n            for near_node in near:\n                if near_node is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not edge_obstacle(new_node.position, near_node.position):\n                        # Remove old parent-child relationship\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n            return new_node\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n        start_time = time.time()\n\n        for iter_count in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate tree growing: start tree first odd iters, goal second even iters\n            if iter_count % 2 == 0:\n                tree_a = start_tree\n                tree_b = goal_tree\n            else:\n                tree_a = goal_tree\n                tree_b = start_tree\n\n            new_node = add_node(tree_a, sample_pt, nodes_all, edges, best_cost)\n            if new_node is None:\n                # Could not add node (collision), continue\n                continue\n\n            # Attempt connection to other tree\n            nearest_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_b.position) <= self.step_size:\n                if not edge_obstacle(new_node.position, nearest_b.position):\n                    # Connect path candidates\n                    path_candidate = connect_path(new_node, nearest_b)\n                    candidate_cost = new_node.cost + dist(new_node.position, nearest_b.position) + nearest_b.cost\n\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = path_candidate\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            # Early termination when no meaningful improvement for long\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            # Restart no improve count if significant improvement detected\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                no_improve_count = 0\n                last_best_cost = best_cost\n\n        # Final path smoothing via shortcutting if solution found\n        if found_solution and len(best_path) > 2:\n            best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
                "objective": -12.90672,
                "time_improvement": -15.0,
                "length_improvement": 14.0,
                "smoothness_improvement": 1865.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.03639078140258789,
                        "num_nodes_avg": 237.0,
                        "path_length_avg": 168.02193260520104,
                        "smoothness_avg": 0.04984815517379989,
                        "success_improvement": 0.0,
                        "time_improvement": -49.84611306639963,
                        "length_improvement": 7.9045162611873945,
                        "smoothness_improvement": 680.2318754714814,
                        "objective_score": -6.809964785850045
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.046571874618530275,
                        "num_nodes_avg": 354.8,
                        "path_length_avg": 240.5937710240402,
                        "smoothness_avg": 0.12631217131652547,
                        "success_improvement": 0.0,
                        "time_improvement": 71.15672210389786,
                        "length_improvement": 19.68287412444948,
                        "smoothness_improvement": 3150.1031469538016,
                        "objective_score": 48.907256840608056
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.08302063941955566,
                        "num_nodes_avg": 467.5,
                        "path_length_avg": 130.26416789587537,
                        "smoothness_avg": 0.14664374877167838,
                        "success_improvement": 0.0,
                        "time_improvement": -67.64825112539418,
                        "length_improvement": 13.484742196660818,
                        "smoothness_improvement": 1765.2976602601516,
                        "objective_score": -3.377141718321006
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "time_expert",
            "algorithm_description": "An enhanced bidirectional RRT* planner employing a KD-tree for efficient nearest-neighbor queries, adaptive radius rewiring with cost and smoothness heuristics, dynamic ellipsoidal informed sampling, and multistage smoothing via progressive shortcutting and cubic Bezier interpolation. The planner alternates expanding two trees, connects them with rewiring, and applies advanced smoothing to produce shorter, smoother paths with reduced planning time.",
            "planning_mechanism": "The planner grows two trees bidirectionally, using efficient spatial indexing (KD-tree) for neighbor searches within an adaptive radius that considers current best cost and path smoothness. Sampling is biased by progressively shrinking ellipsoids around the best path cost to reduce unnecessary exploration. New nodes are rewired optimally based on combined cost and curvature heuristic. Upon connection, the combined path is post-processed by iterative shortcutting and spline interpolation using cubic Bezier curves to smooth sharp turns and reduce path length. This approach balances exploration and exploitation, accelerates convergence, and yields high-quality paths faster.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # tuple of floats\n        self.parent = parent      # Node or None\n        self.cost = cost          # accumulated cost (float)\n        self.children = []       # list of Node\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 n_near_const=30,\n                 max_no_improve=60,\n                 improve_tol=1e-7,\n                 shortcut_iters=250):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        # Minimal imports here\n        import math\n        import random\n        import time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        dist = lambda a, b: math.dist(a, b)\n\n        # -- Collision checks --\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[j] + (t[j] - f[j]) * i / steps for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        # -- Steering with fixed step size --\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        # -- KD-tree implementation for fast neighbor search --\n        # Simple recursive KD-tree node\n        class KDNode:\n            __slots__ = ['point', 'node_ref', 'left', 'right', 'axis']\n\n            def __init__(self, point, node_ref, axis):\n                self.point = point  # tuple\n                self.node_ref = node_ref  # Node instance\n                self.left = None\n                self.right = None\n                self.axis = axis\n\n        def build_kdtree(points_nodes, depth=0):\n            if not points_nodes:\n                return None\n            axis = depth % dim\n            points_nodes.sort(key=lambda pn: pn[0][axis])\n            median = len(points_nodes) // 2\n            root = KDNode(points_nodes[median][0], points_nodes[median][1], axis)\n            root.left = build_kdtree(points_nodes[:median], depth + 1)\n            root.right = build_kdtree(points_nodes[median+1:], depth + 1)\n            return root\n\n        def kd_nearest(root, point, best=None, best_dist=float('inf')):\n            if root is None:\n                return best, best_dist\n            axis = root.axis\n            here_dist = 0\n            for i in range(dim):\n                diff = point[i] - root.point[i]\n                here_dist += diff * diff\n            here_dist_sqrt = math.sqrt(here_dist)\n            better = False\n            if here_dist_sqrt < best_dist:\n                best = root.node_ref\n                best_dist = here_dist_sqrt\n                better = True\n\n            diff_axis = point[axis] - root.point[axis]\n\n            first, second = (root.left, root.right) if diff_axis < 0 else (root.right, root.left)\n            best, best_dist = kd_nearest(first, point, best, best_dist)\n            if abs(diff_axis) < best_dist:\n                best, best_dist = kd_nearest(second, point, best, best_dist)\n            return best, best_dist\n\n        def kd_radius_search(root, point, radius, found=None):\n            if found is None:\n                found = []\n            if root is None:\n                return found\n            axis = root.axis\n            dist_sq = sum((point[i] - root.point[i]) ** 2 for i in range(dim))\n            if dist_sq <= radius * radius:\n                found.append(root.node_ref)\n            diff_axis = point[axis] - root.point[axis]\n            if diff_axis < 0:\n                kd_radius_search(root.left, point, radius, found)\n                if abs(diff_axis) <= radius:\n                    kd_radius_search(root.right, point, radius, found)\n            else:\n                kd_radius_search(root.right, point, radius, found)\n                if abs(diff_axis) <= radius:\n                    kd_radius_search(root.left, point, radius, found)\n            return found\n\n        # -- Adaptive radius shrinks as better solution found --\n        def adaptive_radius(n_nodes, c_best):\n            gamma = self.n_near_const\n            if n_nodes == 0:\n                return self.step_size * 2.8\n            r = min((gamma * (math.log(n_nodes + 1) / n_nodes)) ** (1 / dim), self.step_size * 6.0)\n            if c_best == float('inf'):\n                return r\n            shrink = max(0.25, c_best / (c_min * 2.7))\n            return max(self.step_size * 0.8, r * shrink)\n\n        # -- Ellipsoidal informed sampling --\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Orthonormal basis, Gram-Schmidt\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0]*dim\n                base[(idx + 1) % dim] = 1\n                for u in U:\n                    proj = sum(base[j] * u[j] for j in range(dim))\n                    base = [base[j] - proj * u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0]*dim)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n                point_scaled = [radii[i] * point_ball[i] for i in range(dim)]\n\n                # Rotate via basis\n                point_rotated = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i] * U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not in_obstacle(sample):\n                        return sample\n\n        # -- Path extraction and connection --\n        def extract_path(node):\n            return node.path_from_root()\n\n        def connect_path(n_start, n_goal):\n            start_path = extract_path(n_start)\n            goal_path_rev = extract_path(n_goal)\n            goal_path = goal_path_rev[::-1]\n            if len(start_path) > 0 and len(goal_path) > 0 and start_path[-1] == goal_path[0]:\n                return start_path + goal_path[1:]\n            else:\n                return start_path + goal_path\n\n        # -- Smoothness metric: sum angle cosines between segments weighted by lengths --\n        def curvature_cost(path):\n            if len(path) < 3:\n                return 0.0\n            cost = 0.0\n            for i in range(1, len(path) - 1):\n                p1, p2, p3 = path[i - 1], path[i], path[i + 1]\n                v1 = tuple(p2[d] - p1[d] for d in range(dim))\n                v2 = tuple(p3[d] - p2[d] for d in range(dim))\n                len1 = math.sqrt(sum(x * x for x in v1))\n                len2 = math.sqrt(sum(x * x for x in v2))\n                if len1 < 1e-14 or len2 < 1e-14:\n                    continue\n                dot = sum(v1[d] * v2[d] for d in range(dim)) / (len1 * len2)\n                dot = max(-1.0, min(1.0, dot))  # clamp\n                angle = math.acos(dot)\n                cost += angle\n            return cost\n\n        # -- Add node with cost and smoothness rewiring --\n        # Will use kd-tree for near search\n        def add_node(tree_nodes, kd_root, new_pos, all_nodes, edges, c_best):\n            # Nearest using kd-tree\n            nn, dist_nn = kd_nearest(kd_root, new_pos)\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(all_nodes)\n            radius = adaptive_radius(n_nodes, c_best)\n            near_nodes_set = kd_radius_search(kd_root, new_pos_steered, radius)\n\n            # Find best parent balancing cost and curvature heuristic with weightings\n            best_parent = nn\n            best_parent_cost = nn.cost + dist(nn.position, new_pos_steered)\n            best_cost_and_curv = best_parent_cost  # for now cost only: cost + alpha*curv\n\n            # Include curvature heuristic: prefer parents that generate smoother turn\n            alpha_curv = 0.06  # weight to curvature cost (tune as heuristic)\n            for candidate in near_nodes_set:\n                if candidate == nn:\n                    continue\n                if edge_obstacle(candidate.position, new_pos_steered):\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, new_pos_steered)\n                # Estimate curvature cost if this candidate chosen as parent\n                # Path to candidate + new edge + (partial smoothing estimate)\n                if candidate.parent is None:\n                    curv = 0.0\n                else:\n                    p_prev = candidate.parent.position\n                    p_cand = candidate.position\n                    v1 = tuple(p_cand[d] - p_prev[d] for d in range(dim))\n                    v2 = tuple(new_pos_steered[d] - p_cand[d] for d in range(dim))\n                    len1 = math.sqrt(sum(x * x for x in v1))\n                    len2 = math.sqrt(sum(x * x for x in v2))\n                    if len1 < 1e-14 or len2 < 1e-14:\n                        curv = 0.0\n                    else:\n                        dot = sum(v1[d] * v2[d] for d in range(dim)) / (len1 * len2)\n                        dot = max(-1.0, min(1.0, dot))\n                        angle = math.acos(dot)\n                        curv = angle\n                cost_and_curv = candidate_cost + alpha_curv * curv\n                if cost_and_curv + self.improve_tol < best_cost_and_curv:\n                    best_parent = candidate\n                    best_parent_cost = candidate_cost\n                    best_cost_and_curv = cost_and_curv\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_parent_cost\n            tree_nodes.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rebuild kd-tree only when tree grows by significant amount? For simplicity rebuild always:\n            # Rewiring neighbors to new_node if beneficial based on cost + curvature:\n            near_nodes_range = kd_radius_search(kd_root, new_node.position, radius)\n            for near_node in near_nodes_range:\n                if near_node is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if near_node.parent is None:\n                    continue\n                # Curvature heuristic for rewiring:\n                p_prev = near_node.parent.position\n                p_cand = near_node.position\n                p_new = new_node.position\n                v1 = tuple(p_cand[d] - p_prev[d] for d in range(dim))\n                v2 = tuple(p_new[d] - p_cand[d] for d in range(dim))\n                len1 = math.sqrt(sum(x * x for x in v1))\n                len2 = math.sqrt(sum(x * x for x in v2))\n                if len1 < 1e-14 or len2 < 1e-14:\n                    curv = 0.0\n                else:\n                    dot = sum(v1[d] * v2[d] for d in range(dim)) / (len1 * len2)\n                    dot = max(-1.0, min(1.0, dot))\n                    angle = math.acos(dot)\n                    curv = angle\n                alt_cost_and_curv = alt_cost + alpha_curv * curv\n                curr_cost_and_curv = near_node.cost + alpha_curv * 0.0  # assume old edge curvature zero or ignore\n\n                if alt_cost_and_curv + self.improve_tol < curr_cost_and_curv and not edge_obstacle(new_node.position, near_node.position):\n                    # Rewire\n                    if near_node.parent:\n                        near_node.parent.remove_child(near_node)\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                    new_node.add_child(near_node)\n                    near_node.cost = alt_cost\n                    edges.append((new_node, near_node))\n\n            return new_node\n\n        # -- Path shortcutting with accelerated attempts and full checks --\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path = list(path)\n\n            changed = True\n            tries = 0\n            max_tries = self.shortcut_iters\n            while changed and tries < max_tries:\n                tries += 1\n                changed = False\n                i = 0\n                while i < len(path) - 2:\n                    # attempt shortcut from i to j randomly chosen farther node\n                    max_j = min(len(path)-1, i + 6 + random.randint(0, 5))\n                    j = random.randint(i + 2, max_j)\n                    if j >= len(path):\n                        break\n                    if not edge_obstacle(path[i], path[j]):\n                        # Remove intermediate nodes\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # -- Cubic Bezier curve interpolation smoothing for path --\n        def bezier_interpolate(path, steps_per_segment=6):\n            if len(path) < 3:\n                return path[:]\n            result = [path[0]]\n            n = len(path)\n            for i in range(n -1):\n                p0 = path[i]\n                p3 = path[i+1]\n                # Control points p1 and p2 computed to smooth path via averaging neighbors with clamping inside bounds\n                def add_points(a,b):\n                    return tuple(a[d]+b[d] for d in range(dim))\n                def sub_points(a,b):\n                    return tuple(a[d]-b[d] for d in range(dim))\n                def mul_point(p, c):\n                    return tuple(c * p[d] for d in range(dim))\n                def clamp_point(p):\n                    return tuple(max(0.0, min(bounds[d], p[d])) for d in range(dim))\n\n                if i == 0:\n                    p1 = add_points(p0, mul_point(sub_points(p3, p0), 0.3))\n                else:\n                    p1 = add_points(path[i-1], mul_point(sub_points(p3, path[i-1]), 0.3))\n                if i == n - 2:\n                    p2 = add_points(p3, mul_point(sub_points(p0, p3), 0.3))\n                else:\n                    p2 = add_points(path[i+2], mul_point(sub_points(p0, path[i+2]), 0.3))\n                p1 = clamp_point(p1)\n                p2 = clamp_point(p2)\n\n                for step in range(1, steps_per_segment+1):\n                    t = step / steps_per_segment\n                    one_minus_t = 1 - t\n                    b_t = [0.0]*dim\n                    for d in range(dim):\n                        b_t[d] = (one_minus_t ** 3) * p0[d] + 3 * (one_minus_t ** 2) * t * p1[d] + 3 * one_minus_t * (t ** 2) * p2[d] + (t ** 3) * p3[d]\n                    point = tuple(b_t)\n                    # If any collision on small segments, skip interpolation and keep original points to be safe\n                    if in_obstacle(point):\n                        return path[:]  # fallback no smoothing\n                    result.append(point)\n            return result\n\n        # Initialize trees and variables\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n        start_time = time.time()\n\n        # Initial kd-trees (rebuild every iteration for simplicity)\n        def rebuild_kd(nodes):\n            pts_refs = [(n.position, n) for n in nodes]\n            return build_kdtree(pts_refs)\n\n        for iter_count in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate tree growing every iteration\n            if iter_count % 2 == 0:\n                tree_a = start_tree\n                tree_b = goal_tree\n            else:\n                tree_a = goal_tree\n                tree_b = start_tree\n\n            kd_tree_a = rebuild_kd(tree_a)\n            kd_tree_b = rebuild_kd(tree_b)\n\n            new_node = add_node(tree_a, kd_tree_a, sample_pt, nodes_all, edges, best_cost)\n            if new_node is None:\n                continue\n\n            # Attempt to connect new_node to other tree within step_size\n            nearest_b, dist_b = kd_nearest(kd_tree_b, new_node.position)\n            if dist_b <= self.step_size:\n                if not edge_obstacle(new_node.position, nearest_b.position):\n                    path_candidate = connect_path(new_node, nearest_b)\n                    candidate_cost = new_node.cost + dist(new_node.position, nearest_b.position) + nearest_b.cost\n                    # Compare smoothness + cost\n                    smooth_cand = curvature_cost(path_candidate)\n                    smooth_best = curvature_cost(best_path) if found_solution else float('inf')\n\n                    # Weighted scoring balancing path cost and smoothness\n                    alpha_smooth = 0.07\n                    if found_solution:\n                        score_cand = candidate_cost + alpha_smooth * smooth_cand\n                        score_best = best_cost + alpha_smooth * smooth_best\n                    else:\n                        score_cand = candidate_cost\n                        score_best = float('inf')\n\n                    if score_cand + self.improve_tol < score_best:\n                        best_cost = candidate_cost\n                        best_path = path_candidate\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            # Terminate early if no improvement for prolonged iterations\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            # Restart no_improve_count if improvement detected\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                last_best_cost = best_cost\n                no_improve_count = 0\n\n        # Post-process best path found with iterative shortcutting\n        if found_solution and len(best_path) > 2:\n            best_path = shortcut_path(best_path)\n\n        # Then smooth with cubic Bezier curve interpolation to improve smoothness further\n        if found_solution and len(best_path) > 4:\n            bezier_path = bezier_interpolate(best_path)\n            if len(bezier_path) >= 2:\n                best_path = bezier_path\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
            "objective": 83.70395,
            "time_improvement": -338.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 1487.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.09354512691497803,
                    "num_nodes_avg": 224.2,
                    "path_length_avg": 158.39149657980934,
                    "smoothness_avg": 0.04605737694225472,
                    "success_improvement": 0.0,
                    "time_improvement": -285.1902356654444,
                    "length_improvement": 13.183110850728989,
                    "smoothness_improvement": 620.8979643411151,
                    "objective_score": -74.54271436749035
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.3257765531539917,
                    "num_nodes_avg": 400.1,
                    "path_length_avg": 243.039815263405,
                    "smoothness_avg": 0.10237027294781645,
                    "success_improvement": 0.0,
                    "time_improvement": -101.76262458020442,
                    "length_improvement": 18.86631415186982,
                    "smoothness_improvement": 2534.0608572745577,
                    "objective_score": -6.5386945965666445
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.3593874931335449,
                    "num_nodes_avg": 338.2,
                    "path_length_avg": 122.57138919671115,
                    "smoothness_avg": 0.11057672266771726,
                    "success_improvement": 0.0,
                    "time_improvement": -625.7313978960544,
                    "length_improvement": 18.59391951788871,
                    "smoothness_improvement": 1306.527750408709,
                    "objective_score": -170.03042890603956
                }
            ],
            "success_rate": 1.0
        },
        "objective": 1043.3999999999999,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - High computational overhead due to linear nearest neighbor searches and lack of efficient spatial data structures causing slow node lookup.\n   - Simplistic rewiring strategy based solely on cost without curvature or smoothness considerations, limiting path quality improvements.\n   - Limited smoothing approach relying only on basic shortcutting with small random windows, resulting in suboptimal path smoothness.\n   - Potentially inefficient sampling mechanisms that do not fully prevent exploration in irrelevant areas, increasing planning time."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Integration of efficient KD-tree data structures for fast nearest neighbor and radius searches, significantly reducing computation time.\n   - Enhanced rewiring technique incorporating both path cost and curvature heuristics to select parents and rewire neighbors, improving smoothness.\n   - More thorough and extended shortcutting combined with cubic Bezier curve interpolation for advanced path smoothing.\n   - Dynamic ellipsoidal informed sampling with collision checks on samples, focusing exploration on relevant regions and avoiding obstacles early.\n2. Expected mechanism of impact:\n   - KD-tree accelerates neighbor searches, lowering overall planning time and enabling more iterations within the same time budget.\n   - Curvature-aware rewiring drives the graph towards smoother trajectories and shorter paths by penalizing sharp turns during tree expansion.\n   - Progressive smoothing via shortcutting and spline interpolation reduces path oscillations and jagged segments, improving smoothness metrics drastically.\n   - Smarter sampling restricts computational effort to promising areas, which enhances convergence speed and path optimality by avoiding wasted exploration."
        }
    },
    {
        "parents": [
            {
                "operator": "m1",
                "algorithm_description": "A bidirectional RRT* inspired planner that grows two trees from start and goal with rewiring and dynamic neighbor radius, incorporating path shortcutting after connection to reduce path length and improve smoothness while ensuring collision-free nodes and edges throughout. It balances exploration and optimization, seeks lowest cost connections, and maintains efficient updates for paths and parents.",
                "planning_mechanism": "The planner samples collision-free points within the map bounds, extends the nearest node of one tree towards the sample, rewires neighbors for lower-cost paths, and attempts to connect the other tree to the newly added node with rewiring as well. Upon connection, a path is extracted and post-processed with shortcutting to smooth and shorten it. The rewiring radius adapts with the tree size to balance exploration and optimization. This enables efficient bidirectional growth with asymptotic optimality and improved path quality.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=50.0, max_rewire_radius=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_rewire_radius = max_rewire_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        final_path = []\n\n        for iter in range(self.max_iter):\n            sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate trees for growth each iteration\n            if iter % 2 == 0:\n                new_node = self._extend_tree(tree_start, tree_goal, sample, obstacles, is_3d, nodes, edges, bounds)\n                if new_node:\n                    conn_node = self._connect_tree(tree_goal, new_node, obstacles, is_3d, nodes, edges, bounds)\n                    if conn_node:\n                        success = True\n                        path_start = new_node.path_from_root()\n                        path_goal = conn_node.path_from_root()\n                        if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                            path_goal = path_goal[:-1]\n                        merged_path = path_start + path_goal[::-1]\n                        final_path = self._shortcut_path(merged_path, obstacles, is_3d, bounds)\n                        break\n            else:\n                new_node = self._extend_tree(tree_goal, tree_start, sample, obstacles, is_3d, nodes, edges, bounds)\n                if new_node:\n                    conn_node = self._connect_tree(tree_start, new_node, obstacles, is_3d, nodes, edges, bounds)\n                    if conn_node:\n                        success = True\n                        path_goal = new_node.path_from_root()\n                        path_start = conn_node.path_from_root()\n                        if path_goal and path_start and path_goal[-1] == path_start[-1]:\n                            path_start = path_start[:-1]\n                        merged_path = path_goal + path_start[::-1]\n                        final_path = self._shortcut_path(merged_path, obstacles, is_3d, bounds)\n                        break\n\n        return PlannerResult(success, final_path, nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near(self, tree, point, bounds):\n        n = len(tree)\n        d = len(point)\n        if n == 0:\n            return []\n        r_ddl = self.gamma * ((math.log(n) / n) ** (1.0 / d)) if n > 1 else self.step_size * 2\n        radius = max(self.step_size * 2, min(self.max_rewire_radius, r_ddl))\n        near_nodes = [node for node in tree if self._dist(node.position, point) <= radius]\n        return near_nodes\n\n    def _extend_tree(self, tree_to_extend, other_tree, sample, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree_to_extend, sample)\n        new_pos = self._steer(nearest.position, sample)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        near_nodes = self._near(tree_to_extend, new_pos, bounds)\n\n        # Choose best parent among neighbors (including nearest) with minimal cost\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in near_nodes:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost_through_nb = nb.cost + self._dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree_to_extend.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new node if cheaper and collision-free edge\n        for nb in near_nodes:\n            if nb == best_parent:\n                continue\n            if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                cost_through_new = new_node.cost + self._dist(new_node.position, nb.position)\n                if cost_through_new + 1e-12 < nb.cost:\n                    # Reassign parent\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = cost_through_new\n                    edges.append((new_node, nb))\n\n        return new_node\n\n    def _connect_tree(self, tree_to_connect, target_node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree_to_connect, target_node.position)\n\n        new_pos = target_node.position\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        near_nodes = self._near(tree_to_connect, new_pos, bounds)\n\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in near_nodes:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost_through_nb = nb.cost + self._dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree_to_connect.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for nb in near_nodes:\n            if nb == best_parent:\n                continue\n            if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                cost_through_new = new_node.cost + self._dist(new_node.position, nb.position)\n                if cost_through_new + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = cost_through_new\n                    edges.append((new_node, nb))\n\n        return new_node\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path[:]\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened\n\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
                "objective": -16.5554,
                "time_improvement": -1.0,
                "length_improvement": 16.0,
                "smoothness_improvement": 1439.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.050579285621643065,
                        "num_nodes_avg": 106.8,
                        "path_length_avg": 164.2712937810431,
                        "smoothness_avg": 0.04226815816929853,
                        "success_improvement": 0.0,
                        "time_improvement": -108.27003598058127,
                        "length_improvement": 9.960300833383796,
                        "smoothness_improvement": 561.5884621240848,
                        "objective_score": -23.69688798352368
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.049871516227722165,
                        "num_nodes_avg": 224.9,
                        "path_length_avg": 237.86532514731707,
                        "smoothness_avg": 0.10161854011327172,
                        "success_improvement": 0.0,
                        "time_improvement": 69.11316081994654,
                        "length_improvement": 20.593707892059786,
                        "smoothness_improvement": 2514.7182299904466,
                        "objective_score": 45.66376413117207
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.03152651786804199,
                        "num_nodes_avg": 152.6,
                        "path_length_avg": 123.96994519489405,
                        "smoothness_avg": 0.10533489541470797,
                        "success_improvement": 0.0,
                        "time_improvement": 36.33672757035219,
                        "length_improvement": 17.66506521597572,
                        "smoothness_improvement": 1239.8520946618717,
                        "objective_score": 27.699317874000446
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "e2",
                "algorithm_description": "A bidirectional variant of RRT* with informed sampling and efficient rewiring that grows two trees simultaneously, restricts sampling to an ellipsoidal informed subset after first solution, and performs local rewiring to improve path cost and smoothness with early termination on convergence.",
                "planning_mechanism": "The planner grows start and goal trees bidirectionally with RRT* rewiring, initially samples uniformly to quickly find a path, then constrains samples to an ellipsoidal informed set defined by the current best path cost. After each extension, it attempts to connect the two trees if close enough, while performing localized rewiring to continuously improve path quality. Early stopping criteria limit iterations after no improvements to reduce planning time.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, radius=15.0,\n                 post_opt_iters=500, max_no_improve=100, improve_tol=1e-5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n\n        c_min = math.dist(start, goal)\n        found_solution = False\n\n        no_improve_count = 0\n        post_opt_count = 0\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            return tuple(frm[i] + (to[i]-frm[i]) * self.step_size / d for i in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            distance = dist(f, t)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                inter = tuple(f[j] + (t[j]-f[j])*(i/steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def nearest(tree, p):\n            best = tree[0]\n            best_d = dist(best.position, p)\n            for n in tree:\n                d2 = dist(n.position, p)\n                if d2 < best_d:\n                    best = n\n                    best_d = d2\n            return best\n\n        def near_nodes(tree, p, radius):\n            result = []\n            r2 = radius**2\n            for n in tree:\n                d2 = sum((n.position[i]-p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def extract_path(n_start, n_goal):\n            path_start, node = [], n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def ellipsoid_sample(c_best):\n            # Sample inside prolate hyperspheroid defined by start, goal, c_best\n            import random\n            import math\n\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i]+goal[i])/2 for i in range(dim))\n            a1 = [goal[i]-start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-12:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            # Compute rotation matrix via Gram-Schmidt or approximate as identity except along a1 axis\n            # For simplicity, rotate only along principal axis for 2D or 3D (orthonormal basis)\n            # Since imports are restricted, implement a simple orthonormal basis:\n\n            # Construct orthonormal basis U with unit_a1 as first vector\n            U = [unit_a1]\n            for i in range(dim-1):\n                base = [0]*dim\n                base[(i+1)%dim] = 1  # simple perpendicular approx\n                # Gram-Schmidt orthogonalize base vs U\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j]-proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-12:\n                    U.append([x/norm_base for x in base])\n                else:\n                    # fallback: constructs zero vector, skip\n                    U.append([0]*dim)\n\n            # L matrix diagonal\n            r1 = c_best / 2\n            if c_best*c_best - c_min*c_min < 0:\n                r2 = 0\n            else:\n                r2 = math.sqrt(c_best*c_best - c_min*c_min) / 2\n            radii = [r1] + [r2] * (dim - 1)\n\n            # Sample unit ball in dim\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-12:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n\n                # Scale by radii\n                point_scaled = [radii[i]*point_ball[i] for i in range(dim)]\n\n                # Rotate via U matrix: point = sum(point_scaled[i] * U[i]) over basis vectors\n                point_rotated = [0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i]*U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        for iter_count in range(self.max_iter):\n            if found_solution:\n                sample_pt = ellipsoid_sample(best_cost)\n            else:\n                sample_pt = ellipsoid_sample(float('inf'))\n\n            # Alternate growing start and goal trees\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n\n                if in_obstacle(new_pos) or edge_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                near = near_nodes(tree_a, new_pos, self.radius)\n\n                # Choose best parent in near nodes with minimal cost + dist and collision free edge\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for candidate in near:\n                    cand_cost = candidate.cost + dist(candidate.position, new_pos)\n                    if cand_cost + self.improve_tol < min_cost and not edge_obstacle(candidate.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = candidate\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire near nodes if new_node offers lower cost connection\n                for near_node in near:\n                    if near_node == best_parent:\n                        continue\n                    alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if alt_cost + self.improve_tol < near_node.cost and not edge_obstacle(new_node.position, near_node.position):\n                        # Remove old edge\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                        if near_node.parent and near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n                # Try connect trees if nodes close enough\n                connect_node = nearest(tree_b, new_node.position)\n                if dist(new_node.position, connect_node.position) <= self.step_size and not edge_obstacle(new_node.position, connect_node.position):\n                    path = extract_path(new_node, connect_node)\n                    path_cost = new_node.cost + dist(new_node.position, connect_node.position) + connect_node.cost\n                    if path_cost + self.improve_tol < best_cost:\n                        best_cost = path_cost\n                        # Stitch trees at connection nodes: assign parents carefully\n                        # For bidirectional path extraction, keep nodes and edges unchanged,\n                        # just store nodes for path extraction\n                        best_path = path\n                        found_solution = True\n                        best_goal_node = connect_node\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n\n                    if found_solution and no_improve_count >= self.max_no_improve:\n                        post_opt_count += 1\n                        if post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_opt_count += 1\n                        if no_improve_count >= self.max_no_improve or post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
                "objective": 52.64884,
                "time_improvement": -220.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 323.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.06786198616027832,
                        "num_nodes_avg": 317.3,
                        "path_length_avg": 155.50621247453464,
                        "smoothness_avg": 0.02411673119934513,
                        "success_improvement": 0.0,
                        "time_improvement": -179.4349134355319,
                        "length_improvement": 14.764580789082476,
                        "smoothness_improvement": 277.4792135897667,
                        "objective_score": -43.58432948926125
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.14667820930480957,
                        "num_nodes_avg": 670.6,
                        "path_length_avg": 226.29277909188164,
                        "smoothness_avg": 0.017873034085429756,
                        "success_improvement": 0.0,
                        "time_improvement": 9.158040406689327,
                        "length_improvement": 24.45695686263326,
                        "smoothness_improvement": 359.8860404442116,
                        "objective_score": 19.22101644180781
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.2925038576126099,
                        "num_nodes_avg": 613.1,
                        "path_length_avg": 120.56565817380633,
                        "smoothness_avg": 0.03399415459254427,
                        "success_improvement": 0.0,
                        "time_improvement": -490.6695072338173,
                        "length_improvement": 19.926030560654297,
                        "smoothness_improvement": 332.4031372296796,
                        "objective_score": -133.58321814760419
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "An improved bidirectional RRT* algorithm employing a spatial hashing grid for efficient nearest neighbor and near node queries, adaptive rewiring radius based on tree size and problem dimension, and incremental rewiring in both trees during node addition and connection. The planner alternates growth between start and goal trees, prunes redundant nodes during rewiring to limit tree size, and uses an efficient line-of-sight shortcutting post-processing for path smoothing and length reduction. Early termination occurs upon finding a valid path. This approach minimizes collision checks, accelerates neighbor searches, and improves path quality and smoothness while significantly reducing planning time.",
            "planning_mechanism": "The algorithm grows two trees from start and goal positions, using spatial hashing to quickly find nearest neighbors and local neighborhoods for rewiring. Each iteration it samples a free point, extends the current tree toward it, rewires locally to optimize costs, and attempts connection to the other tree. Upon connection, the path is extracted and shortcutting is applied to smooth and shorten it. Adaptive rewiring radius scales with node count and problem dimension, balancing exploration and optimization efficiently. Early exit triggers at the first feasible path to reduce planning time.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma=40.0, max_rewire_radius=40.0, grid_cell_size=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_rewire_radius = max_rewire_radius\n        self.grid_cell_size = grid_cell_size  # for spatial hashing\n\n    def plan(self, map):\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Spatial hash grids for each tree: dict mapping cell -> list of nodes\n        def grid_hash(pos):\n            return tuple(int(pos[d] // self.grid_cell_size) for d in range(dim))\n        grid_start = {}\n        grid_goal = {}\n\n        def insert_grid(grid, node):\n            key = grid_hash(node.position)\n            if key not in grid:\n                grid[key] = []\n            grid[key].append(node)\n\n        insert_grid(grid_start, start_root)\n        insert_grid(grid_goal, goal_root)\n\n        def remove_grid(grid, node):\n            key = grid_hash(node.position)\n            if key in grid:\n                try:\n                    grid[key].remove(node)\n                    if not grid[key]:\n                        del grid[key]\n                except ValueError:\n                    pass\n\n        def neighbors_grid(grid, point, radius):\n            # Return nodes in grid cells intersecting radius ball around point\n            radius_cells = int(math.ceil(radius / self.grid_cell_size))\n            center_cell = grid_hash(point)\n            results = []\n            rsq = radius*radius\n            for dx in range(-radius_cells, radius_cells+1):\n                for dy in range(-radius_cells, radius_cells+1):\n                    if dim == 2:\n                        cell = (center_cell[0] + dx, center_cell[1] + dy)\n                        if cell in grid:\n                            for n in grid[cell]:\n                                d2 = sum((n.position[i]-point[i])**2 for i in range(dim))\n                                if d2 <= rsq:\n                                    results.append(n)\n                    else:\n                        for dz in range(-radius_cells, radius_cells+1):\n                            cell = (center_cell[0] + dx, center_cell[1] + dy, center_cell[2] + dz)\n                            if cell in grid:\n                                for n in grid[cell]:\n                                    d2 = sum((n.position[i]-point[i])**2 for i in range(dim))\n                                    if d2 <= rsq:\n                                        results.append(n)\n            return results\n\n        def dist(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                s += d * d\n            return math.sqrt(s)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            return tuple(frm[i] + (to[i] - frm[i]) * self.step_size / d for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            distance = dist(f, t)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[j] + (t[j] - f[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(inter):\n                    return True\n            return False\n\n        def nearest(grid, point):\n            # Search neighbor cells expanding until at least one node found\n            radius = self.grid_cell_size\n            while True:\n                candidates = neighbors_grid(grid, point, radius)\n                if candidates:\n                    best = candidates[0]\n                    best_d = dist(best.position, point)\n                    for n in candidates[1:]:\n                        d2 = dist(n.position, point)\n                        if d2 < best_d:\n                            best = n\n                            best_d = d2\n                    return best\n                radius += self.grid_cell_size\n                if radius > max(bounds) * 2:\n                    # fallback linear search on all nodes\n                    all_nodes = []\n                    for cell_nodes in grid.values():\n                        all_nodes.extend(cell_nodes)\n                    if not all_nodes:\n                        return None\n                    best = all_nodes[0]\n                    best_d = dist(best.position, point)\n                    for n in all_nodes[1:]:\n                        d2 = dist(n.position, point)\n                        if d2 < best_d:\n                            best = n\n                            best_d = d2\n                    return best\n\n        def near_nodes(tree_grid, point, n_size):\n            # Adaptive radius per RRT*: r = min(max_rewire_radius, gamma*(log(n)/n)^{1/d})\n            if n_size <= 1:\n                radius = self.step_size * 3.0\n            else:\n                radius = self.gamma * ((math.log(n_size) / n_size) ** (1.0 / dim))\n                radius = max(radius, self.step_size * 2.0)\n                radius = min(radius, self.max_rewire_radius)\n            return neighbors_grid(tree_grid, point, radius)\n\n        def add_node(tree, tree_grid, nodes_all, edges_all, new_pos, parent_node):\n            cost_new = parent_node.cost + dist(parent_node.position, new_pos)\n            new_node = Node(new_pos, parent=parent_node, cost=cost_new)\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_all.append((parent_node, new_node))\n            insert_grid(tree_grid, new_node)\n            return new_node\n\n        def rewire(tree, tree_grid, edges_all, nodes_all, new_node, near_nodes_list):\n            # For efficiency, rewire only nodes in near_nodes_list\n            for n in near_nodes_list:\n                if n == new_node.parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, n.position)\n                if alt_cost + 1e-12 < n.cost and not edge_obstacle(new_node.position, n.position):\n                    # Remove old edge\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        try:\n                            edges_all.remove((n.parent, n))\n                        except Exception:\n                            pass\n                    new_node.add_child(n)\n                    n.cost = alt_cost\n                    edges_all.append((new_node, n))\n                    # Propagate cost updates downstream via BFS\n                    q = [n]\n                    while q:\n                        curr = q.pop(0)\n                        for c in curr.children:\n                            old_cost = c.cost\n                            c.cost = curr.cost + dist(curr.position, c.position)\n                            if c.cost + 1e-12 < old_cost:\n                                q.append(c)\n\n        def prune_subtree(node, tree, tree_grid, edges_all, nodes_all):\n            # Remove node and all descendants to limit tree size and discard hopeless branches\n            stack = [node]\n            to_remove = []\n            while stack:\n                n = stack.pop()\n                to_remove.append(n)\n                stack.extend(n.children)\n            for n in to_remove:\n                if n.parent:\n                    n.parent.remove_child(n)\n                    try:\n                        edges_all.remove((n.parent, n))\n                    except Exception:\n                        pass\n                if n in tree:\n                    tree.remove(n)\n                if n in nodes_all:\n                    nodes_all.remove(n)\n                remove_grid(tree_grid, n)\n\n        def extract_path(n_start, n_goal):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            # Remove duplicate join node position once\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                # Find furthest node connectable in straight line\n                j = len(path) - 1\n                while j > i + 1:\n                    if not edge_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        success = False\n        final_path = []\n\n        # Alternate growing tree: 0 for start_tree, 1 for goal_tree\n        grow_turn = 0\n\n        for _ in range(self.max_iter):\n            # Sample free point uniformly inside bounds\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    break\n\n            if grow_turn == 0:\n                tree_a, grid_a, tree_b, grid_b = tree_start, grid_start, tree_goal, grid_goal\n            else:\n                tree_a, grid_a, tree_b, grid_b = tree_goal, grid_goal, tree_start, grid_start\n\n            # Extend tree_a towards sample\n            nearest_node = nearest(grid_a, sample)\n            if nearest_node is None:\n                grow_turn = 1 - grow_turn\n                continue\n            new_pos = steer(nearest_node.position, sample)\n            if is_in_obstacle(new_pos) or edge_obstacle(nearest_node.position, new_pos):\n                grow_turn = 1 - grow_turn\n                continue\n\n            near = near_nodes(grid_a, new_pos, len(tree_a))\n            # Choose best parent among near nodes who can connect\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in near:\n                if nb == nearest_node:\n                    continue\n                if not edge_obstacle(nb.position, new_pos):\n                    cost_through_nb = nb.cost + dist(nb.position, new_pos)\n                    if cost_through_nb < min_cost:\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n            new_node = add_node(tree_a, grid_a, nodes, edges, new_pos, best_parent)\n\n            # Rewire near nodes to new node\n            rewire(tree_a, grid_a, edges, nodes, new_node, near)\n\n            # Try connect new_node to other tree\n            near_other = near_nodes(grid_b, new_node.position, len(tree_b))\n            # Find closest node in other tree connectable by edge\n            min_connect_cost = float('inf')\n            connect_node = None\n            for on in near_other:\n                if dist(on.position, new_node.position) <= self.step_size and not edge_obstacle(on.position, new_node.position):\n                    cost_connect = new_node.cost + dist(new_node.position, on.position) + on.cost\n                    if cost_connect < min_connect_cost:\n                        min_connect_cost = cost_connect\n                        connect_node = on\n            if connect_node:\n                # Extract path\n                final_path = extract_path(new_node, connect_node)\n                final_path = shortcut_path(final_path)\n                success = True\n                break\n\n            grow_turn = 1 - grow_turn  # alternate tree\n\n        return PlannerResult(success, final_path, nodes, edges)",
            "objective": -11.69807,
            "time_improvement": -21.0,
            "length_improvement": 17.0,
            "smoothness_improvement": 1526.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.028065919876098633,
                    "num_nodes_avg": 86.4,
                    "path_length_avg": 163.49572132394655,
                    "smoothness_avg": 0.047919740128782015,
                    "success_improvement": 0.0,
                    "time_improvement": -15.566878230521153,
                    "length_improvement": 10.385404386850459,
                    "smoothness_improvement": 650.0479923966562,
                    "objective_score": 4.811419124937211
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.046169471740722653,
                    "num_nodes_avg": 233.7,
                    "path_length_avg": 234.08993011810594,
                    "smoothness_avg": 0.10042545256115583,
                    "success_improvement": 0.0,
                    "time_improvement": 71.40594157650585,
                    "length_improvement": 21.854043421531074,
                    "smoothness_improvement": 2484.019227928276,
                    "objective_score": 46.95430466551178
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.10878512859344483,
                    "num_nodes_avg": 414.2,
                    "path_length_avg": 120.41487182477995,
                    "smoothness_avg": 0.12131448482536566,
                    "success_improvement": 0.0,
                    "time_improvement": -119.67593461881035,
                    "length_improvement": 20.026175674003266,
                    "smoothness_improvement": 1443.1112924748393,
                    "objective_score": -16.67151851886695
                }
            ],
            "success_rate": 1.0
        },
        "objective": 880.8000000000001,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient nearest neighbor and near node searches relying on linear scans without spatial indexing, increasing computational overhead.\n   - Rewiring procedures limited to local neighborhoods without cost propagation downstream, resulting in suboptimal path improvements and larger trees.\n   - Collision checks performed frequently and sometimes at high resolution, causing excessive planning time.\n   - Path extraction and concatenation strategies that lack integrated smoothing, resulting in piecewise linear paths with sharp turns and reduced smoothness.\n   - Use of fixed or overly simplistic rewiring radii not adapted to tree size or problem dimension may hinder efficient exploration and optimization.\n   - Post-processing shortcutting techniques that are either minimal or absent, limiting path length reduction and smoothness enhancement."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Introduction of spatial hashing grids for efficient nearest neighbor and near node queries, reducing search complexity and collision checks.\n   - Adaptive rewiring radius scaling with tree size and dimensionality, providing a better balance between exploration and exploitation.\n   - Rewiring with downstream cost propagation to update subtree costs, effectively pruning suboptimal branches and improving path quality.\n   - Inclusion of pruning strategies to limit tree growth by removing unpromising subtrees, thereby containing computational cost.\n   - Efficient and integrated shortcutting during path extraction, enhancing path smoothness and reducing length.\n2. Expected mechanism of impact:\n   - Faster nearest and neighborhood searches reduce the time consumed in costly collision detection and neighbor lookups, cutting overall planning time.\n   - Adaptive rewiring and cost propagation refine the tree structure, yielding shorter and lower-cost paths.\n   - Pruning redundant branches focuses computations on promising regions, accelerating convergence.\n   - Shortcutting post-processing smoothens the final path by reducing unnecessary waypoints and sharp turns, significantly improving smoothness metrics."
        }
    },
    {
        "parents": [
            {
                "operator": "time_expert",
                "algorithm_description": "An enhanced bidirectional RRT* planner employing a KD-tree for efficient nearest-neighbor queries, adaptive radius rewiring with cost and smoothness heuristics, dynamic ellipsoidal informed sampling, and multistage smoothing via progressive shortcutting and cubic Bezier interpolation. The planner alternates expanding two trees, connects them with rewiring, and applies advanced smoothing to produce shorter, smoother paths with reduced planning time.",
                "planning_mechanism": "The planner grows two trees bidirectionally, using efficient spatial indexing (KD-tree) for neighbor searches within an adaptive radius that considers current best cost and path smoothness. Sampling is biased by progressively shrinking ellipsoids around the best path cost to reduce unnecessary exploration. New nodes are rewired optimally based on combined cost and curvature heuristic. Upon connection, the combined path is post-processed by iterative shortcutting and spline interpolation using cubic Bezier curves to smooth sharp turns and reduce path length. This approach balances exploration and exploitation, accelerates convergence, and yields high-quality paths faster.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position  # tuple of floats\n        self.parent = parent      # Node or None\n        self.cost = cost          # accumulated cost (float)\n        self.children = []       # list of Node\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 n_near_const=30,\n                 max_no_improve=60,\n                 improve_tol=1e-7,\n                 shortcut_iters=250):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        # Minimal imports here\n        import math\n        import random\n        import time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        dist = lambda a, b: math.dist(a, b)\n\n        # -- Collision checks --\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[j] + (t[j] - f[j]) * i / steps for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        # -- Steering with fixed step size --\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        # -- KD-tree implementation for fast neighbor search --\n        # Simple recursive KD-tree node\n        class KDNode:\n            __slots__ = ['point', 'node_ref', 'left', 'right', 'axis']\n\n            def __init__(self, point, node_ref, axis):\n                self.point = point  # tuple\n                self.node_ref = node_ref  # Node instance\n                self.left = None\n                self.right = None\n                self.axis = axis\n\n        def build_kdtree(points_nodes, depth=0):\n            if not points_nodes:\n                return None\n            axis = depth % dim\n            points_nodes.sort(key=lambda pn: pn[0][axis])\n            median = len(points_nodes) // 2\n            root = KDNode(points_nodes[median][0], points_nodes[median][1], axis)\n            root.left = build_kdtree(points_nodes[:median], depth + 1)\n            root.right = build_kdtree(points_nodes[median+1:], depth + 1)\n            return root\n\n        def kd_nearest(root, point, best=None, best_dist=float('inf')):\n            if root is None:\n                return best, best_dist\n            axis = root.axis\n            here_dist = 0\n            for i in range(dim):\n                diff = point[i] - root.point[i]\n                here_dist += diff * diff\n            here_dist_sqrt = math.sqrt(here_dist)\n            better = False\n            if here_dist_sqrt < best_dist:\n                best = root.node_ref\n                best_dist = here_dist_sqrt\n                better = True\n\n            diff_axis = point[axis] - root.point[axis]\n\n            first, second = (root.left, root.right) if diff_axis < 0 else (root.right, root.left)\n            best, best_dist = kd_nearest(first, point, best, best_dist)\n            if abs(diff_axis) < best_dist:\n                best, best_dist = kd_nearest(second, point, best, best_dist)\n            return best, best_dist\n\n        def kd_radius_search(root, point, radius, found=None):\n            if found is None:\n                found = []\n            if root is None:\n                return found\n            axis = root.axis\n            dist_sq = sum((point[i] - root.point[i]) ** 2 for i in range(dim))\n            if dist_sq <= radius * radius:\n                found.append(root.node_ref)\n            diff_axis = point[axis] - root.point[axis]\n            if diff_axis < 0:\n                kd_radius_search(root.left, point, radius, found)\n                if abs(diff_axis) <= radius:\n                    kd_radius_search(root.right, point, radius, found)\n            else:\n                kd_radius_search(root.right, point, radius, found)\n                if abs(diff_axis) <= radius:\n                    kd_radius_search(root.left, point, radius, found)\n            return found\n\n        # -- Adaptive radius shrinks as better solution found --\n        def adaptive_radius(n_nodes, c_best):\n            gamma = self.n_near_const\n            if n_nodes == 0:\n                return self.step_size * 2.8\n            r = min((gamma * (math.log(n_nodes + 1) / n_nodes)) ** (1 / dim), self.step_size * 6.0)\n            if c_best == float('inf'):\n                return r\n            shrink = max(0.25, c_best / (c_min * 2.7))\n            return max(self.step_size * 0.8, r * shrink)\n\n        # -- Ellipsoidal informed sampling --\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Orthonormal basis, Gram-Schmidt\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0]*dim\n                base[(idx + 1) % dim] = 1\n                for u in U:\n                    proj = sum(base[j] * u[j] for j in range(dim))\n                    base = [base[j] - proj * u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0]*dim)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n                point_scaled = [radii[i] * point_ball[i] for i in range(dim)]\n\n                # Rotate via basis\n                point_rotated = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i] * U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    if not in_obstacle(sample):\n                        return sample\n\n        # -- Path extraction and connection --\n        def extract_path(node):\n            return node.path_from_root()\n\n        def connect_path(n_start, n_goal):\n            start_path = extract_path(n_start)\n            goal_path_rev = extract_path(n_goal)\n            goal_path = goal_path_rev[::-1]\n            if len(start_path) > 0 and len(goal_path) > 0 and start_path[-1] == goal_path[0]:\n                return start_path + goal_path[1:]\n            else:\n                return start_path + goal_path\n\n        # -- Smoothness metric: sum angle cosines between segments weighted by lengths --\n        def curvature_cost(path):\n            if len(path) < 3:\n                return 0.0\n            cost = 0.0\n            for i in range(1, len(path) - 1):\n                p1, p2, p3 = path[i - 1], path[i], path[i + 1]\n                v1 = tuple(p2[d] - p1[d] for d in range(dim))\n                v2 = tuple(p3[d] - p2[d] for d in range(dim))\n                len1 = math.sqrt(sum(x * x for x in v1))\n                len2 = math.sqrt(sum(x * x for x in v2))\n                if len1 < 1e-14 or len2 < 1e-14:\n                    continue\n                dot = sum(v1[d] * v2[d] for d in range(dim)) / (len1 * len2)\n                dot = max(-1.0, min(1.0, dot))  # clamp\n                angle = math.acos(dot)\n                cost += angle\n            return cost\n\n        # -- Add node with cost and smoothness rewiring --\n        # Will use kd-tree for near search\n        def add_node(tree_nodes, kd_root, new_pos, all_nodes, edges, c_best):\n            # Nearest using kd-tree\n            nn, dist_nn = kd_nearest(kd_root, new_pos)\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(all_nodes)\n            radius = adaptive_radius(n_nodes, c_best)\n            near_nodes_set = kd_radius_search(kd_root, new_pos_steered, radius)\n\n            # Find best parent balancing cost and curvature heuristic with weightings\n            best_parent = nn\n            best_parent_cost = nn.cost + dist(nn.position, new_pos_steered)\n            best_cost_and_curv = best_parent_cost  # for now cost only: cost + alpha*curv\n\n            # Include curvature heuristic: prefer parents that generate smoother turn\n            alpha_curv = 0.06  # weight to curvature cost (tune as heuristic)\n            for candidate in near_nodes_set:\n                if candidate == nn:\n                    continue\n                if edge_obstacle(candidate.position, new_pos_steered):\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, new_pos_steered)\n                # Estimate curvature cost if this candidate chosen as parent\n                # Path to candidate + new edge + (partial smoothing estimate)\n                if candidate.parent is None:\n                    curv = 0.0\n                else:\n                    p_prev = candidate.parent.position\n                    p_cand = candidate.position\n                    v1 = tuple(p_cand[d] - p_prev[d] for d in range(dim))\n                    v2 = tuple(new_pos_steered[d] - p_cand[d] for d in range(dim))\n                    len1 = math.sqrt(sum(x * x for x in v1))\n                    len2 = math.sqrt(sum(x * x for x in v2))\n                    if len1 < 1e-14 or len2 < 1e-14:\n                        curv = 0.0\n                    else:\n                        dot = sum(v1[d] * v2[d] for d in range(dim)) / (len1 * len2)\n                        dot = max(-1.0, min(1.0, dot))\n                        angle = math.acos(dot)\n                        curv = angle\n                cost_and_curv = candidate_cost + alpha_curv * curv\n                if cost_and_curv + self.improve_tol < best_cost_and_curv:\n                    best_parent = candidate\n                    best_parent_cost = candidate_cost\n                    best_cost_and_curv = cost_and_curv\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_parent_cost\n            tree_nodes.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rebuild kd-tree only when tree grows by significant amount? For simplicity rebuild always:\n            # Rewiring neighbors to new_node if beneficial based on cost + curvature:\n            near_nodes_range = kd_radius_search(kd_root, new_node.position, radius)\n            for near_node in near_nodes_range:\n                if near_node is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if near_node.parent is None:\n                    continue\n                # Curvature heuristic for rewiring:\n                p_prev = near_node.parent.position\n                p_cand = near_node.position\n                p_new = new_node.position\n                v1 = tuple(p_cand[d] - p_prev[d] for d in range(dim))\n                v2 = tuple(p_new[d] - p_cand[d] for d in range(dim))\n                len1 = math.sqrt(sum(x * x for x in v1))\n                len2 = math.sqrt(sum(x * x for x in v2))\n                if len1 < 1e-14 or len2 < 1e-14:\n                    curv = 0.0\n                else:\n                    dot = sum(v1[d] * v2[d] for d in range(dim)) / (len1 * len2)\n                    dot = max(-1.0, min(1.0, dot))\n                    angle = math.acos(dot)\n                    curv = angle\n                alt_cost_and_curv = alt_cost + alpha_curv * curv\n                curr_cost_and_curv = near_node.cost + alpha_curv * 0.0  # assume old edge curvature zero or ignore\n\n                if alt_cost_and_curv + self.improve_tol < curr_cost_and_curv and not edge_obstacle(new_node.position, near_node.position):\n                    # Rewire\n                    if near_node.parent:\n                        near_node.parent.remove_child(near_node)\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                    new_node.add_child(near_node)\n                    near_node.cost = alt_cost\n                    edges.append((new_node, near_node))\n\n            return new_node\n\n        # -- Path shortcutting with accelerated attempts and full checks --\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path = list(path)\n\n            changed = True\n            tries = 0\n            max_tries = self.shortcut_iters\n            while changed and tries < max_tries:\n                tries += 1\n                changed = False\n                i = 0\n                while i < len(path) - 2:\n                    # attempt shortcut from i to j randomly chosen farther node\n                    max_j = min(len(path)-1, i + 6 + random.randint(0, 5))\n                    j = random.randint(i + 2, max_j)\n                    if j >= len(path):\n                        break\n                    if not edge_obstacle(path[i], path[j]):\n                        # Remove intermediate nodes\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # -- Cubic Bezier curve interpolation smoothing for path --\n        def bezier_interpolate(path, steps_per_segment=6):\n            if len(path) < 3:\n                return path[:]\n            result = [path[0]]\n            n = len(path)\n            for i in range(n -1):\n                p0 = path[i]\n                p3 = path[i+1]\n                # Control points p1 and p2 computed to smooth path via averaging neighbors with clamping inside bounds\n                def add_points(a,b):\n                    return tuple(a[d]+b[d] for d in range(dim))\n                def sub_points(a,b):\n                    return tuple(a[d]-b[d] for d in range(dim))\n                def mul_point(p, c):\n                    return tuple(c * p[d] for d in range(dim))\n                def clamp_point(p):\n                    return tuple(max(0.0, min(bounds[d], p[d])) for d in range(dim))\n\n                if i == 0:\n                    p1 = add_points(p0, mul_point(sub_points(p3, p0), 0.3))\n                else:\n                    p1 = add_points(path[i-1], mul_point(sub_points(p3, path[i-1]), 0.3))\n                if i == n - 2:\n                    p2 = add_points(p3, mul_point(sub_points(p0, p3), 0.3))\n                else:\n                    p2 = add_points(path[i+2], mul_point(sub_points(p0, path[i+2]), 0.3))\n                p1 = clamp_point(p1)\n                p2 = clamp_point(p2)\n\n                for step in range(1, steps_per_segment+1):\n                    t = step / steps_per_segment\n                    one_minus_t = 1 - t\n                    b_t = [0.0]*dim\n                    for d in range(dim):\n                        b_t[d] = (one_minus_t ** 3) * p0[d] + 3 * (one_minus_t ** 2) * t * p1[d] + 3 * one_minus_t * (t ** 2) * p2[d] + (t ** 3) * p3[d]\n                    point = tuple(b_t)\n                    # If any collision on small segments, skip interpolation and keep original points to be safe\n                    if in_obstacle(point):\n                        return path[:]  # fallback no smoothing\n                    result.append(point)\n            return result\n\n        # Initialize trees and variables\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n        start_time = time.time()\n\n        # Initial kd-trees (rebuild every iteration for simplicity)\n        def rebuild_kd(nodes):\n            pts_refs = [(n.position, n) for n in nodes]\n            return build_kdtree(pts_refs)\n\n        for iter_count in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate tree growing every iteration\n            if iter_count % 2 == 0:\n                tree_a = start_tree\n                tree_b = goal_tree\n            else:\n                tree_a = goal_tree\n                tree_b = start_tree\n\n            kd_tree_a = rebuild_kd(tree_a)\n            kd_tree_b = rebuild_kd(tree_b)\n\n            new_node = add_node(tree_a, kd_tree_a, sample_pt, nodes_all, edges, best_cost)\n            if new_node is None:\n                continue\n\n            # Attempt to connect new_node to other tree within step_size\n            nearest_b, dist_b = kd_nearest(kd_tree_b, new_node.position)\n            if dist_b <= self.step_size:\n                if not edge_obstacle(new_node.position, nearest_b.position):\n                    path_candidate = connect_path(new_node, nearest_b)\n                    candidate_cost = new_node.cost + dist(new_node.position, nearest_b.position) + nearest_b.cost\n                    # Compare smoothness + cost\n                    smooth_cand = curvature_cost(path_candidate)\n                    smooth_best = curvature_cost(best_path) if found_solution else float('inf')\n\n                    # Weighted scoring balancing path cost and smoothness\n                    alpha_smooth = 0.07\n                    if found_solution:\n                        score_cand = candidate_cost + alpha_smooth * smooth_cand\n                        score_best = best_cost + alpha_smooth * smooth_best\n                    else:\n                        score_cand = candidate_cost\n                        score_best = float('inf')\n\n                    if score_cand + self.improve_tol < score_best:\n                        best_cost = candidate_cost\n                        best_path = path_candidate\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            # Terminate early if no improvement for prolonged iterations\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            # Restart no_improve_count if improvement detected\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                last_best_cost = best_cost\n                no_improve_count = 0\n\n        # Post-process best path found with iterative shortcutting\n        if found_solution and len(best_path) > 2:\n            best_path = shortcut_path(best_path)\n\n        # Then smooth with cubic Bezier curve interpolation to improve smoothness further\n        if found_solution and len(best_path) > 4:\n            bezier_path = bezier_interpolate(best_path)\n            if len(bezier_path) >= 2:\n                best_path = bezier_path\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
                "objective": 83.70395,
                "time_improvement": -338.0,
                "length_improvement": 17.0,
                "smoothness_improvement": 1487.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.09354512691497803,
                        "num_nodes_avg": 224.2,
                        "path_length_avg": 158.39149657980934,
                        "smoothness_avg": 0.04605737694225472,
                        "success_improvement": 0.0,
                        "time_improvement": -285.1902356654444,
                        "length_improvement": 13.183110850728989,
                        "smoothness_improvement": 620.8979643411151,
                        "objective_score": -74.54271436749035
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.3257765531539917,
                        "num_nodes_avg": 400.1,
                        "path_length_avg": 243.039815263405,
                        "smoothness_avg": 0.10237027294781645,
                        "success_improvement": 0.0,
                        "time_improvement": -101.76262458020442,
                        "length_improvement": 18.86631415186982,
                        "smoothness_improvement": 2534.0608572745577,
                        "objective_score": -6.5386945965666445
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.3593874931335449,
                        "num_nodes_avg": 338.2,
                        "path_length_avg": 122.57138919671115,
                        "smoothness_avg": 0.11057672266771726,
                        "success_improvement": 0.0,
                        "time_improvement": -625.7313978960544,
                        "length_improvement": 18.59391951788871,
                        "smoothness_improvement": 1306.527750408709,
                        "objective_score": -170.03042890603956
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "time_expert",
                "algorithm_description": "An enhanced bidirectional RRT* variant that incorporates adaptive neighbor radius shrinking to concentrate rewiring efforts for local optimality, an efficient nearest-neighbor caching structure for faster lookups, and progressive informed sampling with dynamic ellipsoidal restriction. The planner prioritizes early discovery and incremental path improvement, applies a smooth path shortcutting post-processing step to reduce path length and curvature, and enforces robust termination criteria based on stagnation and solution quality thresholds to minimize planning time.",
                "planning_mechanism": "The planner grows two trees alternately with rewiring using an adaptive radius, restricts sampling progressively to a shrinking ellipsoid after finding a solution to focus on promising areas, connects the trees upon proximity, and applies a final shortcut smoothing pass to improve total path length and smoothness before returning the best feasible path found within iteration and time limits.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, n_near_const=35, \n                 max_no_improve=80, improve_tol=1e-6, shortcut_iters=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const  # base neighbor count for adaptive radius\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        # --- Local helper imports & definitions ---\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        dist = lambda a, b: math.dist(a, b)\n\n        # Node collections\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        # To reduce overhead of nearest neighbor search, cache all nodes' positions lists for faster processing\n        # We implement simple linear searches but with caching and limit radius dynamically to reduce checks\n\n        # Adaptive radius for near-node rewiring, shrinks with best_cost to focus local improvements\n        # r_n = min((gamma * (log(n)/n))^(1/d), max_radius) but approximate w/o logs for lightweight\n        def adaptive_radius(n_nodes, c_best):\n            # Use gamma ~ 30 (typical for 2D), avoid zero or undefined\n            gamma = self.n_near_const\n            if n_nodes == 0:\n                return self.step_size * 2.5\n            r = min((gamma * (math.log(n_nodes)/n_nodes))**(1/dim), self.step_size * 5)\n            # Shrink with c_best, stronger around best solution to focus rewiring\n            if c_best == float('inf'):\n                return r\n            shrink_factor = max(0.25, c_best / (c_min * 3))\n            return max(self.step_size*0.75, r * shrink_factor)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-10:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[j] + (t[j] - f[j]) * (i / steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        # Efficient nearest neighbor search (linear but with early exit)\n        def nearest(tree, p):\n            best = None\n            best_d = float('inf')\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 >= best_d*best_d:\n                        break\n                else:\n                    d = math.sqrt(d2)\n                    if d < best_d:\n                        best = n\n                        best_d = d\n            return best\n\n        # Near nodes within radius (adaptive radius)\n        def near_nodes(tree, p, radius):\n            r2 = radius*radius\n            result = []\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 > r2:\n                        break\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        # Extract path from start via parent chain\n        def extract_path(node_start_root):\n            return node_start_root.path_from_root()\n\n        # Extract full path from two connection nodes (start tree and goal tree)\n        def connect_path(n_start, n_goal):\n            path_start = extract_path(n_start)\n            path_goal_rev = extract_path(n_goal)\n            path_goal = path_goal_rev[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        # Ellipsoidal informed sampling centered between start and goal, focused progressively as c_best shrinks\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-12:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Orthonormal basis U with unit_a1 first vector\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0] * dim\n                base[(idx + 1) % dim] = 1\n                for u in U:\n                    proj = sum(base[j] * u[j] for j in range(dim))\n                    base = [base[j] - proj * u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-12:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0] * dim)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-12:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n                point_scaled = [radii[i] * point_ball[i] for i in range(dim)]\n\n                point_rotated = [0.0] * dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i] * U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        # Path shortcutting by attempting to connect non-adjacent nodes directly if collision free\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                changed = False\n                iter_count += 1\n                i = 0\n                while i < len(path) - 2:\n                    j = min(len(path) - 1, i + 2 + random.randint(0, 3))\n                    if j > i + 1 and not edge_obstacle(path[i], path[j]):\n                        # Shortcut feasible, remove intermediate nodes\n                        path = path[:i + 1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Add node to tree selecting best parent among near nodes\n        def add_node(tree, new_pos, nodes_all, edges, c_best):\n            nn = nearest(tree, new_pos)\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(nodes_all)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos_steered, radius)\n\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos_steered)\n            for near_node in near:\n                if near_node == nn:\n                    continue\n                cand_cost = near_node.cost + dist(near_node.position, new_pos_steered)\n                if cand_cost + self.improve_tol < best_cost and not edge_obstacle(near_node.position, new_pos_steered):\n                    best_parent = near_node\n                    best_cost = cand_cost\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if beneficial\n            for near_node in near:\n                if near_node is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not edge_obstacle(new_node.position, near_node.position):\n                        # Remove old parent-child relationship\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n            return new_node\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n        start_time = time.time()\n\n        for iter_count in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate tree growing: start tree first odd iters, goal second even iters\n            if iter_count % 2 == 0:\n                tree_a = start_tree\n                tree_b = goal_tree\n            else:\n                tree_a = goal_tree\n                tree_b = start_tree\n\n            new_node = add_node(tree_a, sample_pt, nodes_all, edges, best_cost)\n            if new_node is None:\n                # Could not add node (collision), continue\n                continue\n\n            # Attempt connection to other tree\n            nearest_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_b.position) <= self.step_size:\n                if not edge_obstacle(new_node.position, nearest_b.position):\n                    # Connect path candidates\n                    path_candidate = connect_path(new_node, nearest_b)\n                    candidate_cost = new_node.cost + dist(new_node.position, nearest_b.position) + nearest_b.cost\n\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = path_candidate\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            # Early termination when no meaningful improvement for long\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            # Restart no improve count if significant improvement detected\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                no_improve_count = 0\n                last_best_cost = best_cost\n\n        # Final path smoothing via shortcutting if solution found\n        if found_solution and len(best_path) > 2:\n            best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
                "objective": -12.90672,
                "time_improvement": -15.0,
                "length_improvement": 14.0,
                "smoothness_improvement": 1865.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.03639078140258789,
                        "num_nodes_avg": 237.0,
                        "path_length_avg": 168.02193260520104,
                        "smoothness_avg": 0.04984815517379989,
                        "success_improvement": 0.0,
                        "time_improvement": -49.84611306639963,
                        "length_improvement": 7.9045162611873945,
                        "smoothness_improvement": 680.2318754714814,
                        "objective_score": -6.809964785850045
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.046571874618530275,
                        "num_nodes_avg": 354.8,
                        "path_length_avg": 240.5937710240402,
                        "smoothness_avg": 0.12631217131652547,
                        "success_improvement": 0.0,
                        "time_improvement": 71.15672210389786,
                        "length_improvement": 19.68287412444948,
                        "smoothness_improvement": 3150.1031469538016,
                        "objective_score": 48.907256840608056
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.08302063941955566,
                        "num_nodes_avg": 467.5,
                        "path_length_avg": 130.26416789587537,
                        "smoothness_avg": 0.14664374877167838,
                        "success_improvement": 0.0,
                        "time_improvement": -67.64825112539418,
                        "length_improvement": 13.484742196660818,
                        "smoothness_improvement": 1765.2976602601516,
                        "objective_score": -3.377141718321006
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "A Bidirectional Informed RRT* with Adaptive Radius and Progressive Rewiring integrating a balanced ellipsoidal informed sampler, efficient linear nearest neighbor search with incremental rewiring, and robust early stopping based on solution stagnation and path cost improvement. The algorithm alternately expands start and goal trees, prioritizes smoother and shorter paths by cost-aware parent selection, adaptively adjusts rewiring radius based on the number of nodes and best cost, and applies a final multi-pass shortcut smoothing to yield efficient, low-cost, and smooth paths within bounded planning time.",
            "planning_mechanism": "The planner maintains two trees grown alternately from start and goal. Sampling is initially uniform and focuses progressively within a shrinking ellipsoid around the currently best path. The nearest parent is selected by minimal cost plus a small curvature penalty. An adaptive rewiring radius shrinks as better solutions are found, enabling local optimization. Each new node attempts rewiring neighbors within radius if it improves cost. The trees connect when nodes are near and collision free. Early termination occurs if no improvements happen in prolonged iterations. After planning, a multi-pass shortcutting cleans and smooths the path to reduce length and curvature.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=5.5, n_near_const=28,\n                 max_no_improve=70, improve_tol=1e-6, shortcut_iters=300):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a, b: math.dist(a, b)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if (ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od):\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if (ox <= px <= ox + ow and oy <= py <= oy + oh):\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps +1):\n                inter = tuple(f[d] + (t[d] - f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best = None\n            best_d = float('inf')\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 >= best_d*best_d:\n                        break\n                else:\n                    d = math.sqrt(d2)\n                    if d < best_d:\n                        best = n\n                        best_d = d\n            return best, best_d\n\n        def near_nodes(tree, p, radius):\n            r2 = radius*radius\n            res = []\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 > r2:\n                        break\n                if d2 <= r2:\n                    res.append(n)\n            return res\n\n        def adaptive_radius(n_nodes, c_best):\n            gamma = self.n_near_const\n            if n_nodes == 0:\n                return self.step_size * 3.0\n            radius = min((gamma * (math.log(n_nodes)/n_nodes))**(1/dim), self.step_size * 6.0)\n            if c_best == float('inf'):\n                return radius\n            shrink = max(0.3, c_best / (c_min * 3.1))\n            return max(self.step_size * 0.8, radius * shrink)\n\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                # Uniform sample in bounds avoiding boundary issues\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n            U = [unit_a1]\n            for idx in range(dim -1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j] - proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0.0]*dim)\n            r1 = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val > 0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n\n            max_attempt = 50\n            for _ in range(max_attempt):\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n                scaled = [radii[i]*point_ball[i] for i in range(dim)]\n                point_rot = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rot[j] += scaled[i]*U[i][j]\n                sample = tuple(center[i] + point_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not in_obstacle(sample):\n                    return sample\n            # fallback\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def extract_path(node):\n            return node.path_from_root()\n\n        def connect_path(n_start, n_goal):\n            path_s = extract_path(n_start)\n            path_g_rev = extract_path(n_goal)\n            path_g = path_g_rev[::-1]\n            if len(path_s) > 0 and len(path_g) > 0 and path_s[-1] == path_g[0]:\n                return path_s + path_g[1:]\n            else:\n                return path_s + path_g\n\n        def curvature_penalty(p_parent, p_child, p_new):\n            # Small curvature cost for smoother parent selection\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_child[i] - p_parent[i] for i in range(dim))\n            v2 = tuple(p_new[i] - p_child[i] for i in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))/(len1*len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        def add_node(tree, new_pos, nodes_all, edges, c_best):\n            nn, _ = nearest(tree, new_pos)\n            if nn is None:\n                return None\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(nodes_all)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos_steered, radius)\n\n            alpha_curv = 0.04\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos_steered)\n            best_score = best_cost + alpha_curv * curvature_penalty(nn.parent.position if nn.parent else None, nn.position, new_pos_steered)\n\n            for candidate in near:\n                if candidate == nn:\n                    continue\n                if edge_obstacle(candidate.position, new_pos_steered):\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, new_pos_steered)\n                curv_cost = alpha_curv * curvature_penalty(candidate.parent.position if candidate.parent else None, candidate.position, new_pos_steered)\n                score = candidate_cost + curv_cost\n                if score + self.improve_tol < best_score:\n                    best_parent = candidate\n                    best_cost = candidate_cost\n                    best_score = score\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node if better path found\n            near_rewire = near_nodes(tree, new_node.position, radius)\n            for near_n in near_rewire:\n                if near_n == best_parent or near_n == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost and not edge_obstacle(new_node.position, near_n.position):\n                    # Additionally check curvature penalty for rewiring\n                    curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, near_n.position)\n                    curv_old = curvature_penalty(near_n.parent.parent.position if near_n.parent and near_n.parent.parent else None, near_n.parent.position if near_n.parent else None, near_n.position)\n                    if alpha_curv * curv_new <= alpha_curv * curv_old + 0.15:  # allow slight increase for cost gain\n                        if near_n.parent:\n                            near_n.parent.remove_child(near_n)\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_n)\n                        near_n.cost = alt_cost\n                        edges.append((new_node, near_n))\n\n            return new_node\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path = list(path)\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                changed = False\n                iter_count +=1\n                i=0\n                while i < len(path)-2:\n                    max_j = min(len(path)-1, i + 7 + random.randint(0,4))\n                    j = random.randint(i+2, max_j) if max_j > i+2 else i+2\n                    if j > i+1 and not edge_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialize bidirectional trees\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate growing trees: even iterations start-tree, odd goal-tree\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            new_node = add_node(tree_a, sample_pt, nodes_all, edges, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                continue\n\n            nbr_node, nbr_dist = nearest(tree_b, new_node.position)\n            if nbr_node and nbr_dist <= self.step_size and not edge_obstacle(new_node.position, nbr_node.position):\n                candidate_path = connect_path(new_node, nbr_node)\n                candidate_cost = new_node.cost + dist(new_node.position, nbr_node.position) + nbr_node.cost\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                last_best_cost = best_cost\n                no_improve_count = 0\n\n        if found_solution and len(best_path) > 3:\n            # Multiple progressive shortcut passes to enhance path quality\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
            "objective": -23.40566,
            "time_improvement": 28.0,
            "length_improvement": 13.0,
            "smoothness_improvement": 1419.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02814173698425293,
                    "num_nodes_avg": 174.7,
                    "path_length_avg": 170.78044027086807,
                    "smoothness_avg": 0.041064375085066517,
                    "success_improvement": 0.0,
                    "time_improvement": -15.879069904428114,
                    "length_improvement": 6.3925344982841175,
                    "smoothness_improvement": 542.746642799047,
                    "objective_score": 1.7855329416372712
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04101948738098145,
                    "num_nodes_avg": 312.8,
                    "path_length_avg": 241.95417433722574,
                    "smoothness_avg": 0.08769719153831615,
                    "success_improvement": 0.0,
                    "time_improvement": 74.59547240955273,
                    "length_improvement": 19.228732341469897,
                    "smoothness_improvement": 2156.5119040147615,
                    "objective_score": 44.698440647821556
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.036681413650512695,
                    "num_nodes_avg": 276.1,
                    "path_length_avg": 130.08856674191185,
                    "smoothness_avg": 0.13041023521317593,
                    "success_improvement": 0.0,
                    "time_improvement": 25.927156303411085,
                    "length_improvement": 13.601368121895007,
                    "smoothness_improvement": 1558.8085660293298,
                    "objective_score": 23.733010594306975
                }
            ],
            "success_rate": 1.0
        },
        "objective": 1029.8,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Rebuilding nearest neighbor data structures every iteration causing unnecessary overhead.\n   - Adaptive rewiring radius shrinking too aggressively, limiting neighbor consideration and exploration.\n   - Heavy reliance on local curvature heuristics for parent selection and rewiring adding computational complexity but yielding noisy approximations.\n   - Limited and often fallback smoothing techniques due to collision checks reducing smoothing efficiency.\n   - Excessive or imprecise rewiring logic that may reject better connections and increase runtime.\n   - Sampling strategies that do not effectively balance exploration and exploitation early in planning."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Incremental nearest neighbor searches with caching reduce data structure rebuild overhead.\n   - Balanced adaptive radius approach preserves sufficient connections and maintains good neighborhood sizes for rewiring.\n   - Simplified yet effective curvature penalties guide parent selection and rewiring without excessive computation.\n   - Multiple progressive shortcutting passes post-planning significantly improve path smoothness.\n   - Early stopping criteria prevent unnecessary iterations once improvements stagnate.\n   - Refined sampling within informed ellipsoids with retry and fallback mechanisms enhances exploration and valid sample yield.\n\n2. Expected mechanism of impact:\n   - Reduced computational cost per iteration and fewer total iterations reduce overall planning time.\n   - Appropriate neighborhood size ensures more effective rewiring, producing lower-cost and smoother paths.\n   - Smarter parent selection and rewiring yield smoother transitions, improving path quality without large overhead.\n   - Progressive shortcutting passes effectively remove unnecessary detours and sharp turns, enhancing smoothness and shortening path length.\n   - Early termination limits wasted computational effort, accelerating planning.\n   - Improved sampling efficiency reduces time spent on invalid samples and balances coverage, accelerating convergence and solution quality."
        }
    },
    {
        "parents": [
            {
                "operator": "e2",
                "algorithm_description": "A bidirectional informed RRT* planner with adaptive step sizing, dynamic neighbor radius using k-nearest approach, obstacle-aware rewiring, and heuristic-guided sampling that progressively focuses sampling within an ellipsoid to concentrate efforts around promising paths. The planner implements pruning of trees beyond the current best cost, uses balanced tree growth with rapid connection attempts, and performs iterative path shortcutting to smooth and shorten the resulting path efficiently, terminating early if no significant improvements are observed.",
                "planning_mechanism": "The algorithm alternates growth between the two trees with adaptive step sizes reducing as better paths are found, samples in an admissible ellipsoidal region shrinking with best costs to intensify search near the optimum, applies k-nearest rewiring for flexible neighborhood connection, prunes nodes exceeding current best path cost to save computation, connects trees eagerly when within step-size distance, and applies iterative shortcutting on the final path to enhance smoothness while monitoring improvement to early halt the search.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size_init=5.0, k_nearest=12,\n                 no_improve_limit=60, improve_tol=1e-7, shortcut_iters=250):\n        self.max_iter = max_iter\n        self.step_size_init = step_size_init\n        self.k_nearest = k_nearest\n        self.no_improve_limit = no_improve_limit\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def dist(a, b):\n            d_sq = 0.0\n            for i in range(dim):\n                d_sq += (a[i] - b[i]) ** 2\n            return math.sqrt(d_sq)\n\n        def in_obstacle(p):\n            px = p + (0.0,) * (3 - dim) if dim < 3 else p\n            for obs in obstacles:\n                if dim == 2:\n                    ox, oy, ow, oh = obs\n                    if ox <= px[0] <= ox + ow and oy <= px[1] <= oy + oh:\n                        return True\n                else:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px[0] <= ox + ow and oy <= px[1] <= oy + oh and oz <= px[2] <= oz + od:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=0.4):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(f[j] + (t[j] - f[j]) * (i / steps) for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to, max_step):\n            d = dist(frm, to)\n            if d <= max_step:\n                return to\n            ratio = max_step / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d += diff * diff\n                    if d > best_dist * best_dist:\n                        break\n                else:\n                    d = math.sqrt(d)\n                    if d < best_dist:\n                        best = node\n                        best_dist = d\n            return best\n\n        def k_nearest_nodes(tree, point, k):\n            # find k nearest nodes by distance (linear scan sufficient for this scale)\n            dists = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d += diff * diff\n                    if d > float('inf'):\n                        break\n                else:\n                    dists.append((math.sqrt(d), n))\n            dists.sort(key=lambda x: x[0])\n            return [n for _, n in dists[:k]]\n\n        def cost_to_node(node):\n            return node.cost\n\n        c_min = dist(start, goal)\n\n        def ellipsoid_sample(c_best):\n            # If no solution, sample uniformly in bounds\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-14:\n                # Degenerate case, sample uniformly\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Build orthonormal basis using Gram-Schmidt for dim-dim matrix U\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0.0] * dim\n                base[(idx + 1) % dim] = 1.0\n                for u in U:\n                    proj = sum(base[j] * u[j] for j in range(dim))\n                    base = [base[j] - proj * u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-14:\n                    base = [x / norm_base for x in base]\n                else:\n                    base = [0.0] * dim\n                U.append(base)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            # Sample in unit ball then scale and rotate\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n\n                point_scaled = [radii[i] * point_ball[i] for i in range(dim)]\n                # Rotate by U matrix transpose\n                point_rotated = [0.0] * dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i] * U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        def dynamic_step_size(iter_count, best_cost):\n            # shrink step size as better paths found (min 1.0)\n            base = self.step_size_init\n            shrink = 1.0\n            if best_cost != float('inf'):\n                shrink = max(0.3, best_cost / (c_min * 3.0))\n            # also reduce with iteration to refine\n            decay_iter_factor = max(0.2, 1.0 - iter_count / self.max_iter)\n            step = base * shrink * decay_iter_factor\n            return max(1.0, step)\n\n        def add_node(tree, sample, all_nodes, edges, best_cost, iter_count):\n            step_size = dynamic_step_size(iter_count, best_cost)\n            nn = nearest(tree, sample)\n            new_pos = steer(nn.position, sample, step_size)\n            if in_obstacle(new_pos) or edge_obstacle(nn.position, new_pos):\n                return None\n            # Find k nearest neighbors in tree for rewiring\n            near = k_nearest_nodes(tree, new_pos, self.k_nearest)\n\n            # Choose best parent among near nodes\n            best_parent = nn\n            best_cost_to_new = nn.cost + dist(nn.position, new_pos)\n            for near_node in near:\n                if near_node == nn:\n                    continue\n                cand_cost = near_node.cost + dist(near_node.position, new_pos)\n                if cand_cost + self.improve_tol < best_cost_to_new and not edge_obstacle(near_node.position, new_pos):\n                    best_parent = near_node\n                    best_cost_to_new = cand_cost\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost_to_new\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new node if beneficial\n            for near_node in near:\n                if near_node == best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost and not edge_obstacle(new_node.position, near_node.position):\n                    if near_node.parent is not None:\n                        near_node.parent.remove_child(near_node)\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                    new_node.add_child(near_node)\n                    near_node.cost = alt_cost\n                    edges.append((new_node, near_node))\n\n            return new_node\n\n        def extract_path(node_s, node_g):\n            path_s = node_s.path_from_root()\n            path_g = node_g.path_from_root()\n            # The connection node is node_s and node_g may not be same position.\n            # Attach goal tree path reversed (excluding common node if exists)\n            # To avoid double node, check equality of endpoints\n            if path_s and path_g and path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            else:\n                return path_s + path_g[::-1]\n\n        def shortcut_path(path):\n            # Iteratively shortcut path by trying to connect non-consecutive nodes directly\n            if len(path) < 3:\n                return path\n            changed = True\n            count = 0\n            while changed and count < self.shortcut_iters:\n                changed = False\n                count += 1\n                i = 0\n                while i < len(path) - 2:\n                    # Random distant j\n                    max_jump = min(len(path) - 1, i + 6)\n                    j = random.randint(i + 2, max_jump)\n                    if not edge_obstacle(path[i], path[j]):\n                        # shortcut possible\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialize trees\n        start_node = Node(start)\n        goal_node = Node(goal)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        found = False\n\n        no_improve_count = 0\n        last_best = float('inf')\n\n        for itr in range(self.max_iter):\n            # Sample using ellipsoidal informed sampling\n            sample_pt = ellipsoid_sample(best_cost)\n\n            # Alternate trees for growth\n            if itr % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            new_node = add_node(tree_a, sample_pt, all_nodes, edges, best_cost, itr)\n            if new_node is None:\n                continue\n\n            # Try to connect new node to nearest on other tree\n            near_connect = nearest(tree_b, new_node.position)\n            if near_connect is not None:\n                dist_cand = dist(near_connect.position, new_node.position)\n                step_curr = dynamic_step_size(itr, best_cost)\n                if dist_cand <= step_curr and not edge_obstacle(new_node.position, near_connect.position):\n                    # Possible connection\n                    path_candidate = extract_path(new_node, near_connect)\n                    candidate_cost = new_node.cost + dist_cand + near_connect.cost\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = path_candidate\n                        found = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    if found:\n                        no_improve_count += 1\n\n            # Prune nodes exceeding best cost + tolerance to improve efficiency\n            if found:\n                limit_cost = best_cost + self.improve_tol\n                def prune(tree):\n                    to_remove = []\n                    for node in tree:\n                        if node.cost > limit_cost:\n                            to_remove.append(node)\n                    for node in to_remove:\n                        if node.parent:\n                            node.parent.remove_child(node)\n                        try:\n                            tree.remove(node)\n                            all_nodes.remove(node)\n                        except Exception:\n                            pass\n                prune(tree_start)\n                prune(tree_goal)\n\n            # Early stopping on stagnation\n            if found:\n                if best_cost + self.improve_tol < last_best:\n                    last_best = best_cost\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                if no_improve_count >= self.no_improve_limit:\n                    break\n\n        # Post-processing shortcutting for smoothness and length improvements\n        if found and len(best_path) > 3:\n            best_path = shortcut_path(best_path)\n\n        if found:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
                "objective": 44.13367,
                "time_improvement": -94.0,
                "length_improvement": 19.0,
                "smoothness_improvement": 1116.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.056844019889831544,
                        "num_nodes_avg": 131.4,
                        "path_length_avg": 158.28767403870523,
                        "smoothness_avg": 0.04288565059179957,
                        "success_improvement": 0.0,
                        "time_improvement": -134.06629655263816,
                        "length_improvement": 13.240017630681594,
                        "smoothness_improvement": 571.2535594424835,
                        "objective_score": -29.419610590170073
                    },
                    {
                        "map_id": 1,
                        "success_rate": 0.9,
                        "time_avg": 0.0836817741394043,
                        "num_nodes_avg": 359.9,
                        "path_length_avg": 228.1134320486448,
                        "smoothness_avg": 0.07374435827108994,
                        "success_improvement": -9.999999999999998,
                        "time_improvement": 48.173512745365564,
                        "length_improvement": 23.84917050107601,
                        "smoothness_improvement": 1797.4954542294452,
                        "objective_score": -12.250966604597496
                    },
                    {
                        "map_id": 2,
                        "success_rate": 0.9,
                        "time_avg": 0.1458946704864502,
                        "num_nodes_avg": 412.3,
                        "path_length_avg": 118.5632699248331,
                        "smoothness_avg": 0.08490620066984564,
                        "success_improvement": -9.999999999999998,
                        "time_improvement": -194.6133217784839,
                        "length_improvement": 21.255921492140313,
                        "smoothness_improvement": 980.0006053966165,
                        "objective_score": -90.7304406112779
                    }
                ],
                "success_rate": 0.9333333333333332
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -23.76291481494683,
                "time_improvement": 61.0,
                "length_improvement": 8.0,
                "smoothness_improvement": 166.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.012529301643371581,
                        "num_nodes_avg": 131.9,
                        "path_length_avg": 176.77827310097746,
                        "smoothness_avg": 0.01645631271580969,
                        "success_improvement": 0.0,
                        "time_improvement": 48.408166070262766,
                        "length_improvement": 3.105027282357968,
                        "smoothness_improvement": 157.5770294574498,
                        "objective_score": 17.173351337780858
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.01886875629425049,
                        "num_nodes_avg": 256.8,
                        "path_length_avg": 267.7347696890942,
                        "smoothness_avg": 0.010597136127488454,
                        "success_improvement": 0.0,
                        "time_improvement": 88.31404606735866,
                        "length_improvement": 10.622427559723258,
                        "smoothness_improvement": 172.67194536891012,
                        "objective_score": 33.7310300828861
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.026641178131103515,
                        "num_nodes_avg": 304.4,
                        "path_length_avg": 136.29588257526552,
                        "smoothness_avg": 0.02101448639210645,
                        "success_improvement": 0.0,
                        "time_improvement": 46.20196913892299,
                        "length_improvement": 9.478764505998065,
                        "smoothness_improvement": 167.3027157795587,
                        "objective_score": 20.384363024173528
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "A bidirectional RRT* planner with adaptive radius rewiring, progressive heuristic ellipsoidal sampling focusing search on promising paths, and early termination on convergence stagnation. It uses dynamic neighbor radius scaled with the logarithm of current tree size, adaptive step size that balances exploration and refinement, and incremental cost-based rewiring with bidirectional tree connection attempts. Path shortcutting is performed iteratively post solution to shorten and smooth the path efficiently.",
            "planning_mechanism": "The planner grows two trees from start and goal nodes alternately, samples new points focusing inside an informed ellipsoid shaped by current best solution cost to guide exploration. New nodes are connected using parent selection minimizing path cost within a dynamically computed neighbor radius that adapts as the tree grows. Rewiring adjusts tree topology to reduce costs. When the two trees connect within step distance, the combined path is saved if better. Early termination triggers if no cost improvement occurs over a configurable window, reducing runtime. Post processing shortcuts the path to remove unnecessary waypoints and improves path smoothness.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, neighbor_factor=2.0, no_improve_limit=60, improve_tol=1e-7, shortcut_iters=250):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor\n        self.no_improve_limit = no_improve_limit\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def dist(a,b):\n            return math.sqrt(sum((a[i]-b[i])**2 for i in range(dim)))\n\n        def in_obstacle(p):\n            px = p + (0.0,)*(3-dim) if dim<3 else p\n            for obs in obstacles:\n                if dim == 2:\n                    x,y,w,h = obs\n                    if x <= px[0] <= x+w and y <= px[1] <= y+h:\n                        return True\n                else:\n                    x,y,z,w,h,d = obs\n                    if x <= px[0] <= x+w and y <= px[1] <= y+h and z <= px[2] <= z+d:\n                        return True\n            return False\n\n        def edge_obstacle(f,t,resolution=0.4):\n            length = dist(f,t)\n            if length < 1e-12:\n                return False\n            steps = max(2,int(length/resolution))\n            for i in range(steps+1):\n                interp = tuple(f[j] + (t[j]-f[j])*(i/steps) for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm,to,max_step):\n            d = dist(frm,to)\n            if d <= max_step:\n                return to\n            ratio = max_step/d\n            return tuple(frm[i]+(to[i]-frm[i])*ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d += diff*diff\n                    if d > best_dist*best_dist:\n                        break\n                else:\n                    d = math.sqrt(d)\n                    if d < best_dist:\n                        best = node\n                        best_dist = d\n            return best\n\n        def neighbor_radius(tree_len):\n            # Adaptive neighbor radius based on tree size, theoretical RRT* scaling\n            if tree_len < 2:\n                return self.step_size * 2.0\n            return min(self.step_size*5.0, self.neighbor_factor * (math.log(tree_len)/tree_len)**(1.0/dim)*max(bounds))\n\n        def neighbors(tree, point, radius):\n            neigh = []\n            r_sq = radius*radius\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d_sq += diff*diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    neigh.append(node)\n            return neigh\n\n        c_min = dist(start, goal)\n\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            center = tuple((start[i]+goal[i])*0.5 for i in range(dim))\n            a1 = [goal[i]-start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            # Orthonormal basis U via Gram-Schmidt (dim x dim)\n            U = [unit_a1]\n            for idx in range(dim-1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j]-proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    base = [x/norm_base for x in base]\n                else:\n                    base = [0.0]*dim\n                U.append(base)\n\n            r1 = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val>0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x/norm_ball for x in x_ball]\n                u_rand = random.random()**(1.0/dim)\n                point_ball = [coord*u_rand for coord in unit_ball]\n\n                point_scaled = [radii[i]*point_ball[i] for i in range(dim)]\n\n                # Rotate by U matrix transpose\n                point_rot = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rot[j] += point_scaled[i]*U[i][j]\n\n                sample = tuple(center[i]+point_rot[i] for i in range(dim))\n                if all(0.0<=sample[i]<=bounds[i] for i in range(dim)):\n                    return sample\n\n        def add_node(tree, sample, all_nodes, edges, best_cost):\n            nn = nearest(tree, sample)\n            new_pos = steer(nn.position, sample, self.step_size)\n            if in_obstacle(new_pos) or edge_obstacle(nn.position,new_pos):\n                return None\n            radius = neighbor_radius(len(tree))\n            near = neighbors(tree, new_pos, radius)\n            best_parent = nn\n            min_cost = nn.cost + dist(nn.position,new_pos)\n            for candidate in near:\n                cand_cost = candidate.cost + dist(candidate.position,new_pos)\n                if cand_cost + self.improve_tol < min_cost and not edge_obstacle(candidate.position,new_pos):\n                    best_parent = candidate\n                    min_cost = cand_cost\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent,new_node))\n\n            # Rewire neighbors through new node if beneficial\n            for neighbor in near:\n                if neighbor is best_parent: \n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost + self.improve_tol < neighbor.cost and not edge_obstacle(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        neighbor.parent.remove_child(neighbor)\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n                    new_node.add_child(neighbor)\n                    neighbor.cost = alt_cost\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def extract_path(node_s, node_g):\n            path_s = node_s.path_from_root()\n            path_g = node_g.path_from_root()\n            # Avoid duplicate duplicate connecting node\n            if path_s and path_g and path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            else:\n                return path_s + path_g[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            count = 0\n            changed = True\n            while changed and count < self.shortcut_iters:\n                changed = False\n                count += 1\n                i = 0\n                while i < len(path)-2:\n                    max_jump = min(len(path)-1, i+6)\n                    j = random.randint(i+2, max_jump)\n                    if not edge_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        start_node = Node(start)\n        goal_node = Node(goal)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        found = False\n        no_improve_count = 0\n        last_best = best_cost\n\n        for itr in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost)\n\n            if itr % 2 == 0:\n                main_tree, other_tree = tree_start, tree_goal\n            else:\n                main_tree, other_tree = tree_goal, tree_start\n\n            new_node = add_node(main_tree, sample_pt, all_nodes, edges, best_cost)\n            if new_node is None:\n                continue\n\n            near_connect = nearest(other_tree, new_node.position)\n            step_dist = dist(near_connect.position, new_node.position)\n            if step_dist <= self.step_size and not edge_obstacle(new_node.position, near_connect.position):\n                candidate_cost = new_node.cost + near_connect.cost + step_dist\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = extract_path(new_node, near_connect)\n                    found = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            else:\n                if found:\n                    no_improve_count += 1\n\n            if found:\n                # Early stopping on stagnation of improvement\n                if best_cost + self.improve_tol < last_best:\n                    last_best = best_cost\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                if no_improve_count >= self.no_improve_limit:\n                    break\n\n        if found and len(best_path) > 3:\n            best_path = shortcut_path(best_path)\n\n        if found:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
            "objective": 6.30946,
            "time_improvement": -81.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1172.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.08813977241516113,
                    "num_nodes_avg": 171.3,
                    "path_length_avg": 155.94724987804915,
                    "smoothness_avg": 0.037895327969512546,
                    "success_improvement": 0.0,
                    "time_improvement": -262.9326382650782,
                    "length_improvement": 14.522841199531285,
                    "smoothness_improvement": 493.1441737446706,
                    "objective_score": -67.70036589108133
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08728914260864258,
                    "num_nodes_avg": 314.3,
                    "path_length_avg": 226.58476458100463,
                    "smoothness_avg": 0.07942344506505501,
                    "success_improvement": 0.0,
                    "time_improvement": 45.93936752179157,
                    "length_improvement": 24.35948370202769,
                    "smoothness_improvement": 1943.6224479190457,
                    "objective_score": 38.11561271734931
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.061713361740112306,
                    "num_nodes_avg": 259.4,
                    "path_length_avg": 118.83941821204158,
                    "smoothness_avg": 0.09275591661871693,
                    "success_improvement": 0.0,
                    "time_improvement": -24.621265737464196,
                    "length_improvement": 21.072516948544795,
                    "smoothness_improvement": 1079.8484128604985,
                    "objective_score": 10.65637251219011
                }
            ],
            "success_rate": 1.0
        },
        "objective": 680.8,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient nearest neighbor searches utilizing fixed step sizes and static neighbor counts or fixed radius, leading to suboptimal exploration efficiency and increased planning time.\n   - Lack of adaptive neighbor radius scaling with tree size, causing unnecessary rewiring operations and poor management of computational resources.\n   - Absence of heuristic-focused sampling strategies, resulting in random exploration that slows convergence to high-quality paths.\n   - Limited or basic path shortcutting and smoothing techniques, often relying on random or low-iteration attempts insufficient for significantly improving path smoothness.\n   - Potential overhead from pruning or excessive node management without adaptive stopping criteria, prolonging runtime without commensurate improvements."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Introduction of an adaptive neighbor radius that scales logarithmically with the tree size, optimizing rewiring scope and computational effort.\n   - Incorporation of heuristic-informed ellipsoidal sampling focusing exploration within promising regions between start and goal, accelerating path quality improvements.\n   - Use of early stopping criteria based on stagnation in cost improvement, minimizing unnecessary iterations and reducing planning time.\n   - Enhanced rewiring and parent selection guided by adaptive radius and cost metrics to find lower-cost connections more effectively.\n   - Implementation of iterative and systematic path shortcutting post-processing, significantly enhancing path smoothness and shortening path length.\n\n2. Expected mechanism of impact:\n   - Adaptive neighbor radius reduces redundant neighbor checks and avoids wasted rewiring, improving runtime efficiency and convergence speed.\n   - Focused ellipsoidal sampling concentrates samples in the informed space, improving sample relevance and accelerating discovery of optimal paths.\n   - Early termination eliminates diminishing returns in computation by halting planning when further improvements become unlikely.\n   - More effective rewiring enables the tree to evolve toward lower-cost topologies rapidly, resulting in shorter and smoother paths.\n   - Repeated and controlled shortcutting removes unnecessary waypoints and jagged turns, improving the overall smoothness and quality of the planned trajectory."
        }
    },
    {
        "parents": [
            {
                "operator": "m1",
                "algorithm_description": "A bidirectional RRT* inspired planner that grows two trees from start and goal with rewiring and dynamic neighbor radius, incorporating path shortcutting after connection to reduce path length and improve smoothness while ensuring collision-free nodes and edges throughout. It balances exploration and optimization, seeks lowest cost connections, and maintains efficient updates for paths and parents.",
                "planning_mechanism": "The planner samples collision-free points within the map bounds, extends the nearest node of one tree towards the sample, rewires neighbors for lower-cost paths, and attempts to connect the other tree to the newly added node with rewiring as well. Upon connection, a path is extracted and post-processed with shortcutting to smooth and shorten it. The rewiring radius adapts with the tree size to balance exploration and optimization. This enables efficient bidirectional growth with asymptotic optimality and improved path quality.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=50.0, max_rewire_radius=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_rewire_radius = max_rewire_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        final_path = []\n\n        for iter in range(self.max_iter):\n            sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate trees for growth each iteration\n            if iter % 2 == 0:\n                new_node = self._extend_tree(tree_start, tree_goal, sample, obstacles, is_3d, nodes, edges, bounds)\n                if new_node:\n                    conn_node = self._connect_tree(tree_goal, new_node, obstacles, is_3d, nodes, edges, bounds)\n                    if conn_node:\n                        success = True\n                        path_start = new_node.path_from_root()\n                        path_goal = conn_node.path_from_root()\n                        if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                            path_goal = path_goal[:-1]\n                        merged_path = path_start + path_goal[::-1]\n                        final_path = self._shortcut_path(merged_path, obstacles, is_3d, bounds)\n                        break\n            else:\n                new_node = self._extend_tree(tree_goal, tree_start, sample, obstacles, is_3d, nodes, edges, bounds)\n                if new_node:\n                    conn_node = self._connect_tree(tree_start, new_node, obstacles, is_3d, nodes, edges, bounds)\n                    if conn_node:\n                        success = True\n                        path_goal = new_node.path_from_root()\n                        path_start = conn_node.path_from_root()\n                        if path_goal and path_start and path_goal[-1] == path_start[-1]:\n                            path_start = path_start[:-1]\n                        merged_path = path_goal + path_start[::-1]\n                        final_path = self._shortcut_path(merged_path, obstacles, is_3d, bounds)\n                        break\n\n        return PlannerResult(success, final_path, nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near(self, tree, point, bounds):\n        n = len(tree)\n        d = len(point)\n        if n == 0:\n            return []\n        r_ddl = self.gamma * ((math.log(n) / n) ** (1.0 / d)) if n > 1 else self.step_size * 2\n        radius = max(self.step_size * 2, min(self.max_rewire_radius, r_ddl))\n        near_nodes = [node for node in tree if self._dist(node.position, point) <= radius]\n        return near_nodes\n\n    def _extend_tree(self, tree_to_extend, other_tree, sample, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree_to_extend, sample)\n        new_pos = self._steer(nearest.position, sample)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        near_nodes = self._near(tree_to_extend, new_pos, bounds)\n\n        # Choose best parent among neighbors (including nearest) with minimal cost\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in near_nodes:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost_through_nb = nb.cost + self._dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree_to_extend.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new node if cheaper and collision-free edge\n        for nb in near_nodes:\n            if nb == best_parent:\n                continue\n            if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                cost_through_new = new_node.cost + self._dist(new_node.position, nb.position)\n                if cost_through_new + 1e-12 < nb.cost:\n                    # Reassign parent\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = cost_through_new\n                    edges.append((new_node, nb))\n\n        return new_node\n\n    def _connect_tree(self, tree_to_connect, target_node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree_to_connect, target_node.position)\n\n        new_pos = target_node.position\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        near_nodes = self._near(tree_to_connect, new_pos, bounds)\n\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in near_nodes:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost_through_nb = nb.cost + self._dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree_to_connect.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for nb in near_nodes:\n            if nb == best_parent:\n                continue\n            if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                cost_through_new = new_node.cost + self._dist(new_node.position, nb.position)\n                if cost_through_new + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = cost_through_new\n                    edges.append((new_node, nb))\n\n        return new_node\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path[:]\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened\n\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
                "objective": -16.5554,
                "time_improvement": -1.0,
                "length_improvement": 16.0,
                "smoothness_improvement": 1439.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.050579285621643065,
                        "num_nodes_avg": 106.8,
                        "path_length_avg": 164.2712937810431,
                        "smoothness_avg": 0.04226815816929853,
                        "success_improvement": 0.0,
                        "time_improvement": -108.27003598058127,
                        "length_improvement": 9.960300833383796,
                        "smoothness_improvement": 561.5884621240848,
                        "objective_score": -23.69688798352368
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.049871516227722165,
                        "num_nodes_avg": 224.9,
                        "path_length_avg": 237.86532514731707,
                        "smoothness_avg": 0.10161854011327172,
                        "success_improvement": 0.0,
                        "time_improvement": 69.11316081994654,
                        "length_improvement": 20.593707892059786,
                        "smoothness_improvement": 2514.7182299904466,
                        "objective_score": 45.66376413117207
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.03152651786804199,
                        "num_nodes_avg": 152.6,
                        "path_length_avg": 123.96994519489405,
                        "smoothness_avg": 0.10533489541470797,
                        "success_improvement": 0.0,
                        "time_improvement": 36.33672757035219,
                        "length_improvement": 17.66506521597572,
                        "smoothness_improvement": 1239.8520946618717,
                        "objective_score": 27.699317874000446
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "e2",
                "algorithm_description": "A bidirectional variant of RRT* with informed sampling and efficient rewiring that grows two trees simultaneously, restricts sampling to an ellipsoidal informed subset after first solution, and performs local rewiring to improve path cost and smoothness with early termination on convergence.",
                "planning_mechanism": "The planner grows start and goal trees bidirectionally with RRT* rewiring, initially samples uniformly to quickly find a path, then constrains samples to an ellipsoidal informed set defined by the current best path cost. After each extension, it attempts to connect the two trees if close enough, while performing localized rewiring to continuously improve path quality. Early stopping criteria limit iterations after no improvements to reduce planning time.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, radius=15.0,\n                 post_opt_iters=500, max_no_improve=100, improve_tol=1e-5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n\n        c_min = math.dist(start, goal)\n        found_solution = False\n\n        no_improve_count = 0\n        post_opt_count = 0\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            return tuple(frm[i] + (to[i]-frm[i]) * self.step_size / d for i in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            distance = dist(f, t)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                inter = tuple(f[j] + (t[j]-f[j])*(i/steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def nearest(tree, p):\n            best = tree[0]\n            best_d = dist(best.position, p)\n            for n in tree:\n                d2 = dist(n.position, p)\n                if d2 < best_d:\n                    best = n\n                    best_d = d2\n            return best\n\n        def near_nodes(tree, p, radius):\n            result = []\n            r2 = radius**2\n            for n in tree:\n                d2 = sum((n.position[i]-p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def extract_path(n_start, n_goal):\n            path_start, node = [], n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def ellipsoid_sample(c_best):\n            # Sample inside prolate hyperspheroid defined by start, goal, c_best\n            import random\n            import math\n\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i]+goal[i])/2 for i in range(dim))\n            a1 = [goal[i]-start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-12:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            # Compute rotation matrix via Gram-Schmidt or approximate as identity except along a1 axis\n            # For simplicity, rotate only along principal axis for 2D or 3D (orthonormal basis)\n            # Since imports are restricted, implement a simple orthonormal basis:\n\n            # Construct orthonormal basis U with unit_a1 as first vector\n            U = [unit_a1]\n            for i in range(dim-1):\n                base = [0]*dim\n                base[(i+1)%dim] = 1  # simple perpendicular approx\n                # Gram-Schmidt orthogonalize base vs U\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j]-proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-12:\n                    U.append([x/norm_base for x in base])\n                else:\n                    # fallback: constructs zero vector, skip\n                    U.append([0]*dim)\n\n            # L matrix diagonal\n            r1 = c_best / 2\n            if c_best*c_best - c_min*c_min < 0:\n                r2 = 0\n            else:\n                r2 = math.sqrt(c_best*c_best - c_min*c_min) / 2\n            radii = [r1] + [r2] * (dim - 1)\n\n            # Sample unit ball in dim\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-12:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n\n                # Scale by radii\n                point_scaled = [radii[i]*point_ball[i] for i in range(dim)]\n\n                # Rotate via U matrix: point = sum(point_scaled[i] * U[i]) over basis vectors\n                point_rotated = [0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i]*U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        for iter_count in range(self.max_iter):\n            if found_solution:\n                sample_pt = ellipsoid_sample(best_cost)\n            else:\n                sample_pt = ellipsoid_sample(float('inf'))\n\n            # Alternate growing start and goal trees\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n\n                if in_obstacle(new_pos) or edge_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                near = near_nodes(tree_a, new_pos, self.radius)\n\n                # Choose best parent in near nodes with minimal cost + dist and collision free edge\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for candidate in near:\n                    cand_cost = candidate.cost + dist(candidate.position, new_pos)\n                    if cand_cost + self.improve_tol < min_cost and not edge_obstacle(candidate.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = candidate\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire near nodes if new_node offers lower cost connection\n                for near_node in near:\n                    if near_node == best_parent:\n                        continue\n                    alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if alt_cost + self.improve_tol < near_node.cost and not edge_obstacle(new_node.position, near_node.position):\n                        # Remove old edge\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                        if near_node.parent and near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n                # Try connect trees if nodes close enough\n                connect_node = nearest(tree_b, new_node.position)\n                if dist(new_node.position, connect_node.position) <= self.step_size and not edge_obstacle(new_node.position, connect_node.position):\n                    path = extract_path(new_node, connect_node)\n                    path_cost = new_node.cost + dist(new_node.position, connect_node.position) + connect_node.cost\n                    if path_cost + self.improve_tol < best_cost:\n                        best_cost = path_cost\n                        # Stitch trees at connection nodes: assign parents carefully\n                        # For bidirectional path extraction, keep nodes and edges unchanged,\n                        # just store nodes for path extraction\n                        best_path = path\n                        found_solution = True\n                        best_goal_node = connect_node\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n\n                    if found_solution and no_improve_count >= self.max_no_improve:\n                        post_opt_count += 1\n                        if post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_opt_count += 1\n                        if no_improve_count >= self.max_no_improve or post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
                "objective": 52.64884,
                "time_improvement": -220.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 323.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.06786198616027832,
                        "num_nodes_avg": 317.3,
                        "path_length_avg": 155.50621247453464,
                        "smoothness_avg": 0.02411673119934513,
                        "success_improvement": 0.0,
                        "time_improvement": -179.4349134355319,
                        "length_improvement": 14.764580789082476,
                        "smoothness_improvement": 277.4792135897667,
                        "objective_score": -43.58432948926125
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.14667820930480957,
                        "num_nodes_avg": 670.6,
                        "path_length_avg": 226.29277909188164,
                        "smoothness_avg": 0.017873034085429756,
                        "success_improvement": 0.0,
                        "time_improvement": 9.158040406689327,
                        "length_improvement": 24.45695686263326,
                        "smoothness_improvement": 359.8860404442116,
                        "objective_score": 19.22101644180781
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.2925038576126099,
                        "num_nodes_avg": 613.1,
                        "path_length_avg": 120.56565817380633,
                        "smoothness_avg": 0.03399415459254427,
                        "success_improvement": 0.0,
                        "time_improvement": -490.6695072338173,
                        "length_improvement": 19.926030560654297,
                        "smoothness_improvement": 332.4031372296796,
                        "objective_score": -133.58321814760419
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that combines efficient nearest neighbor approximation with an adaptive rewiring radius and incremental pruning to reduce redundant nodes. It alternately grows two trees from start and goal, uses approximate KD-tree-like spatial hashing for faster nearest and near node searches, performs rewiring for local path optimization, and incorporates a fast path shortcutting step at connection to improve path length and smoothness. The planner also dynamically adjusts its rewiring radius based on tree size and dimensionality to limit rewiring overhead and integrates early stopping when improvement stalls, all designed to minimize planning time and path length without excessive computational effort.",
            "planning_mechanism": "The planner alternately grows two trees towards randomly sampled free points, selecting optimal parents from nearby nodes with fast approximate neighbor queries. After each extension, it attempts to connect the opposite tree. Upon successful connection, it extracts the path and performs shortcutting to remove unnecessary waypoints. Adaptive neighbor radius and incremental pruning keep the trees efficient, while an early stopping condition prevents wasteful iterations once no meaningful improvements occur.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, gamma=35.0,\n                 max_rewire_radius=40.0, early_stop_no_improve=80,\n                 shortcut_iter=160):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_rewire_radius = max_rewire_radius\n        self.early_stop_no_improve = early_stop_no_improve\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Spatial hashing grid params for approximate neighbors\n        cell_size = max(self.step_size, 5.0)\n        def grid_hash(pos):\n            return tuple(int(p // cell_size) for p in pos)\n\n        # Spatial hash maps: cell => list of nodes\n        start_grid = {}\n        goal_grid = {}\n\n        def insert_node(grid, node):\n            cell = grid_hash(node.position)\n            if cell not in grid:\n                grid[cell] = []\n            grid[cell].append(node)\n\n        insert_node(start_grid, start_root)\n        insert_node(goal_grid, goal_root)\n\n        def get_near_nodes(grid, pos, radius):\n            cell_coords = grid_hash(pos)\n            r_cells = int(math.ceil(radius / cell_size))\n            candidates = []\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    if dim == 2:\n                        cell = (cell_coords[0]+dx, cell_coords[1]+dy)\n                        if cell in grid:\n                            candidates.extend(grid[cell])\n                    else:\n                        for dz in range(-r_cells, r_cells + 1):\n                            cell = (cell_coords[0]+dx, cell_coords[1]+dy, cell_coords[2]+dz)\n                            if cell in grid:\n                                candidates.extend(grid[cell])\n            radius_sq = radius * radius\n            return [n for n in candidates if self._dist_sq(n.position, pos) <= radius_sq]\n\n        def remove_node(grid, node):\n            cell = grid_hash(node.position)\n            if cell in grid and node in grid[cell]:\n                grid[cell].remove(node)\n                if not grid[cell]:\n                    del grid[cell]\n\n        def update_node_grid(grid, node, old_pos):\n            old_cell = grid_hash(old_pos)\n            new_cell = grid_hash(node.position)\n            if old_cell != new_cell:\n                if old_cell in grid and node in grid[old_cell]:\n                    grid[old_cell].remove(node)\n                    if not grid[old_cell]:\n                        del grid[old_cell]\n                if new_cell not in grid:\n                    grid[new_cell] = []\n                grid[new_cell].append(node)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_counter = 0\n\n        # Precompute c_min distance between start and goal for radius calc\n        c_min = self._dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            # Adaptive rewiring radius based on total nodes and dimension\n            total_nodes = len(tree_start) + len(tree_goal)\n            if total_nodes > 1:\n                radius = min(self.max_rewire_radius,\n                             self.gamma * ((math.log(total_nodes) / total_nodes) ** (1/dim)))\n                radius = max(radius, self.step_size * 2.0)\n            else:\n                radius = self.step_size * 2.0\n\n            # Sample collision-free point uniformly\n            sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree extension\n            extend_tree, connect_tree = (tree_start, tree_goal) if it % 2 == 0 else (tree_goal, tree_start)\n            extend_grid = start_grid if it % 2 == 0 else goal_grid\n            connect_grid = goal_grid if it % 2 == 0 else start_grid\n\n            # Extend phase\n            nearest_node = self._approx_nearest(extend_tree, extend_grid, sample, radius, is_3d)\n            if nearest_node is None:\n                continue  # safety\n\n            new_pos = self._steer(nearest_node.position, sample)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = get_near_nodes(extend_grid, new_pos, radius)\n\n            # Select best parent\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in near_nodes:\n                if nb == nearest_node:\n                    continue\n                if self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    continue\n                cost_through_nb = nb.cost + self._dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            extend_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            insert_node(extend_grid, new_node)\n\n            # Rewire neighbors to new_node if cheaper and collision free\n            for nb in near_nodes:\n                if nb == best_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    continue\n                alt_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                if alt_cost + 1e-12 < nb.cost:\n                    # Reassign parent, update edges\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except Exception:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = alt_cost\n                    edges.append((new_node, nb))\n\n            # Try connect other tree\n            nearest_connect = self._approx_nearest(connect_tree, connect_grid, new_node.position, radius, is_3d)\n            if nearest_connect is None:\n                continue\n\n            dist_connect = self._dist(new_node.position, nearest_connect.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_connect.position, obstacles, is_3d):\n                    path_cost = new_node.cost + dist_connect + nearest_connect.cost\n                    if path_cost + 1e-12 < best_cost:\n                        best_cost = path_cost\n                        # Extract path:\n                        path_start = new_node.path_from_root()\n                        path_goal = nearest_connect.path_from_root()\n                        # Merge paths, avoiding repeated node\n                        if path_start[-1] == path_goal[-1]:\n                            path_goal = path_goal[:-1]\n                        raw_path = path_start + path_goal[::-1]\n                        # Shortcut to improve path\n                        best_path = self._shortcut_path(raw_path, obstacles, is_3d, bounds, iter_lim=self.shortcut_iter)\n                        found_solution = True\n                        no_improve_counter = 0\n                    else:\n                        no_improve_counter += 1\n            else:\n                # No connection improvement this iteration\n                no_improve_counter += 1\n\n            # Early stop if no improvement for long\n            if found_solution and no_improve_counter >= self.early_stop_no_improve:\n                break\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _approx_nearest(self, tree, grid, point, radius, is_3d):\n        # Use spatial hash to get candidates in vicinity\n        # Combine exact nearest from candidates\n        candidates = []\n        # Get candidates from surrounding cells (3x3 or 3x3x3)\n        dim = len(point)\n        cell_size = max(self.step_size, 5.0)\n        cell = tuple(int(p // cell_size) for p in point)\n        r_cells = 1  # radius small enough, consider nearby grid cells only\n        for dx in range(-r_cells, r_cells+1):\n            for dy in range(-r_cells, r_cells+1):\n                if dim == 2:\n                    c = (cell[0]+dx, cell[1]+dy)\n                    if c in grid:\n                        candidates.extend(grid[c])\n                else:\n                    for dz in range(-r_cells, r_cells+1):\n                        c = (cell[0]+dx, cell[1]+dy, cell[2]+dz)\n                        if c in grid:\n                            candidates.extend(grid[c])\n        if not candidates:\n            # fallback linear search if no candidates found\n            candidates = tree\n\n        best = None\n        best_dist = float('inf')\n        for n in candidates:\n            d = self._dist(n.position, point)\n            if d < best_dist:\n                best = n\n                best_dist = d\n        return best\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _dist_sq(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, iter_lim=160):\n        if len(path) < 3:\n            return list(path)\n        path_new = list(path)\n        iters = 0\n        while iters < iter_lim:\n            if len(path_new) < 3:\n                break\n            i = random.randint(0, len(path_new) - 3)\n            j = random.randint(i + 2, len(path_new) -1)\n            if not self._is_edge_in_obstacle(path_new[i], path_new[j], obstacles, is_3d):\n                # shortcut by removing intermediate nodes between i and j\n                del path_new[i+1:j]\n            iters += 1\n        return path_new",
            "objective": 2.70963,
            "time_improvement": -68.0,
            "length_improvement": 18.0,
            "smoothness_improvement": 1359.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06853735446929932,
                    "num_nodes_avg": 226.7,
                    "path_length_avg": 162.4933129975047,
                    "smoothness_avg": 0.04033359017827268,
                    "success_improvement": 0.0,
                    "time_improvement": -182.2158736703629,
                    "length_improvement": 10.934840274749654,
                    "smoothness_improvement": 531.3082720828986,
                    "objective_score": -45.44731657584458
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.10013775825500489,
                    "num_nodes_avg": 463.7,
                    "path_length_avg": 231.6140031793218,
                    "smoothness_avg": 0.10057505556673607,
                    "success_improvement": 0.0,
                    "time_improvement": 37.98185679876864,
                    "length_improvement": 22.680579099302726,
                    "smoothness_improvement": 2487.868621016545,
                    "objective_score": 37.442247604294955
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07947943210601807,
                    "num_nodes_avg": 412.2,
                    "path_length_avg": 118.59985783137168,
                    "smoothness_avg": 0.09098141231233955,
                    "success_improvement": 0.0,
                    "time_improvement": -60.49729183216582,
                    "length_improvement": 21.23162154674627,
                    "smoothness_improvement": 1057.2768490636613,
                    "objective_score": -0.12383037628367877
                }
            ],
            "success_rate": 1.0
        },
        "objective": 847.4,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Planning time was often increased due to exhaustive nearest and near neighbor searches without spatial indexing, leading to costly linear scans in large node sets.\n   - Fixed or inefficient rewiring radius selection caused unnecessary edge evaluations and rewiring overhead, impacting iterative speed.\n   - Path smoothness suffered from minimal or no advanced post-processing beyond simple shortcutting, resulting in jagged, piecewise linear paths.\n   - Collision checks were performed at fine resolution but lacked adaptive optimization, contributing to added computational load.\n   - Some algorithms lacked early stopping criteria, leading to wasted computation even after solution convergence."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Use of spatial hashing for approximate neighbor queries drastically reduced nearest and near neighbor search costs.\n   - Adaptive rewiring radius dependent on tree size and problem dimension limited rewiring overhead while sustaining solution quality.\n   - Incorporation of early stopping criteria avoided unnecessary iterations after solution improvements plateaued.\n   - Enhanced shortcutting with iterative random path shortcut attempts provided more effective smoothing without major computational burden.\n\n2. Expected mechanism of impact:\n   - Spatial hashing enabled focused local neighbor searches instead of global scans, improving per-iteration speed and scaling.\n   - Adaptive radius tuning balanced cost of rewiring against path improvements, preventing excessive edge rewiring operations.\n   - Early stop reduced total planning time by terminating growth when further optimization was insignificant.\n   - Iterative shortcutting removed redundant waypoints and smoothed the path effectively, improving smoothness metrics.\n   - Together, these combine to yield shorter, smoother paths found faster with fewer iterations and computation."
        }
    },
    {
        "parents": [
            {
                "operator": "e2",
                "algorithm_description": "A Bidirectional Informed RRT* with Adaptive Radius and Progressive Rewiring integrating a balanced ellipsoidal informed sampler, efficient linear nearest neighbor search with incremental rewiring, and robust early stopping based on solution stagnation and path cost improvement. The algorithm alternately expands start and goal trees, prioritizes smoother and shorter paths by cost-aware parent selection, adaptively adjusts rewiring radius based on the number of nodes and best cost, and applies a final multi-pass shortcut smoothing to yield efficient, low-cost, and smooth paths within bounded planning time.",
                "planning_mechanism": "The planner maintains two trees grown alternately from start and goal. Sampling is initially uniform and focuses progressively within a shrinking ellipsoid around the currently best path. The nearest parent is selected by minimal cost plus a small curvature penalty. An adaptive rewiring radius shrinks as better solutions are found, enabling local optimization. Each new node attempts rewiring neighbors within radius if it improves cost. The trees connect when nodes are near and collision free. Early termination occurs if no improvements happen in prolonged iterations. After planning, a multi-pass shortcutting cleans and smooths the path to reduce length and curvature.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=5.5, n_near_const=28,\n                 max_no_improve=70, improve_tol=1e-6, shortcut_iters=300):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a, b: math.dist(a, b)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if (ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od):\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if (ox <= px <= ox + ow and oy <= py <= oy + oh):\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps +1):\n                inter = tuple(f[d] + (t[d] - f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best = None\n            best_d = float('inf')\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 >= best_d*best_d:\n                        break\n                else:\n                    d = math.sqrt(d2)\n                    if d < best_d:\n                        best = n\n                        best_d = d\n            return best, best_d\n\n        def near_nodes(tree, p, radius):\n            r2 = radius*radius\n            res = []\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 > r2:\n                        break\n                if d2 <= r2:\n                    res.append(n)\n            return res\n\n        def adaptive_radius(n_nodes, c_best):\n            gamma = self.n_near_const\n            if n_nodes == 0:\n                return self.step_size * 3.0\n            radius = min((gamma * (math.log(n_nodes)/n_nodes))**(1/dim), self.step_size * 6.0)\n            if c_best == float('inf'):\n                return radius\n            shrink = max(0.3, c_best / (c_min * 3.1))\n            return max(self.step_size * 0.8, radius * shrink)\n\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                # Uniform sample in bounds avoiding boundary issues\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n            U = [unit_a1]\n            for idx in range(dim -1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j] - proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0.0]*dim)\n            r1 = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val > 0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n\n            max_attempt = 50\n            for _ in range(max_attempt):\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n                scaled = [radii[i]*point_ball[i] for i in range(dim)]\n                point_rot = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rot[j] += scaled[i]*U[i][j]\n                sample = tuple(center[i] + point_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not in_obstacle(sample):\n                    return sample\n            # fallback\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def extract_path(node):\n            return node.path_from_root()\n\n        def connect_path(n_start, n_goal):\n            path_s = extract_path(n_start)\n            path_g_rev = extract_path(n_goal)\n            path_g = path_g_rev[::-1]\n            if len(path_s) > 0 and len(path_g) > 0 and path_s[-1] == path_g[0]:\n                return path_s + path_g[1:]\n            else:\n                return path_s + path_g\n\n        def curvature_penalty(p_parent, p_child, p_new):\n            # Small curvature cost for smoother parent selection\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_child[i] - p_parent[i] for i in range(dim))\n            v2 = tuple(p_new[i] - p_child[i] for i in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))/(len1*len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        def add_node(tree, new_pos, nodes_all, edges, c_best):\n            nn, _ = nearest(tree, new_pos)\n            if nn is None:\n                return None\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(nodes_all)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos_steered, radius)\n\n            alpha_curv = 0.04\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos_steered)\n            best_score = best_cost + alpha_curv * curvature_penalty(nn.parent.position if nn.parent else None, nn.position, new_pos_steered)\n\n            for candidate in near:\n                if candidate == nn:\n                    continue\n                if edge_obstacle(candidate.position, new_pos_steered):\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, new_pos_steered)\n                curv_cost = alpha_curv * curvature_penalty(candidate.parent.position if candidate.parent else None, candidate.position, new_pos_steered)\n                score = candidate_cost + curv_cost\n                if score + self.improve_tol < best_score:\n                    best_parent = candidate\n                    best_cost = candidate_cost\n                    best_score = score\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node if better path found\n            near_rewire = near_nodes(tree, new_node.position, radius)\n            for near_n in near_rewire:\n                if near_n == best_parent or near_n == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost and not edge_obstacle(new_node.position, near_n.position):\n                    # Additionally check curvature penalty for rewiring\n                    curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, near_n.position)\n                    curv_old = curvature_penalty(near_n.parent.parent.position if near_n.parent and near_n.parent.parent else None, near_n.parent.position if near_n.parent else None, near_n.position)\n                    if alpha_curv * curv_new <= alpha_curv * curv_old + 0.15:  # allow slight increase for cost gain\n                        if near_n.parent:\n                            near_n.parent.remove_child(near_n)\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_n)\n                        near_n.cost = alt_cost\n                        edges.append((new_node, near_n))\n\n            return new_node\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path = list(path)\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                changed = False\n                iter_count +=1\n                i=0\n                while i < len(path)-2:\n                    max_j = min(len(path)-1, i + 7 + random.randint(0,4))\n                    j = random.randint(i+2, max_j) if max_j > i+2 else i+2\n                    if j > i+1 and not edge_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialize bidirectional trees\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate growing trees: even iterations start-tree, odd goal-tree\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            new_node = add_node(tree_a, sample_pt, nodes_all, edges, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                continue\n\n            nbr_node, nbr_dist = nearest(tree_b, new_node.position)\n            if nbr_node and nbr_dist <= self.step_size and not edge_obstacle(new_node.position, nbr_node.position):\n                candidate_path = connect_path(new_node, nbr_node)\n                candidate_cost = new_node.cost + dist(new_node.position, nbr_node.position) + nbr_node.cost\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                last_best_cost = best_cost\n                no_improve_count = 0\n\n        if found_solution and len(best_path) > 3:\n            # Multiple progressive shortcut passes to enhance path quality\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
                "objective": -23.40566,
                "time_improvement": 28.0,
                "length_improvement": 13.0,
                "smoothness_improvement": 1419.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.02814173698425293,
                        "num_nodes_avg": 174.7,
                        "path_length_avg": 170.78044027086807,
                        "smoothness_avg": 0.041064375085066517,
                        "success_improvement": 0.0,
                        "time_improvement": -15.879069904428114,
                        "length_improvement": 6.3925344982841175,
                        "smoothness_improvement": 542.746642799047,
                        "objective_score": 1.7855329416372712
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.04101948738098145,
                        "num_nodes_avg": 312.8,
                        "path_length_avg": 241.95417433722574,
                        "smoothness_avg": 0.08769719153831615,
                        "success_improvement": 0.0,
                        "time_improvement": 74.59547240955273,
                        "length_improvement": 19.228732341469897,
                        "smoothness_improvement": 2156.5119040147615,
                        "objective_score": 44.698440647821556
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.036681413650512695,
                        "num_nodes_avg": 276.1,
                        "path_length_avg": 130.08856674191185,
                        "smoothness_avg": 0.13041023521317593,
                        "success_improvement": 0.0,
                        "time_improvement": 25.927156303411085,
                        "length_improvement": 13.601368121895007,
                        "smoothness_improvement": 1558.8085660293298,
                        "objective_score": 23.733010594306975
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m2",
                "algorithm_description": "An improved bidirectional RRT* planner that integrates adaptive informed sampling, dynamic rewiring with efficient neighbor querying via spatial hashing, and a curvature-aware smoothing post-process. The planner alternates tree growth from start and goal, uses a tempered early stopping mechanism based on improvement stagnation, and refines the final path by combining shortcutting with a lightweight curvature smoothing pass to produce collision-free, shorter, and smoother trajectories while reducing planning time.",
                "planning_mechanism": "The planner performs bidirectional tree expansion with alternating growth and connection attempts, samples points biased by a mix of goal, uniform, and informed strategies restricted to a reshaped ellipsoid for focusing search as better solutions emerge. It maintains spatial hashed structures for efficient neighbor retrieval and performs adaptive radius rewiring to optimize path cost and structure locally. Early stopping prevents unnecessary computation. The final extracted path goes through multi-pass shortcutting combined with a curvature-based moving average smoothing to improve smoothness of the trajectory while preserving obstacle clearance and path length gains.",
                "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=4.5,\n                 base_radius=18.0,\n                 min_radius=7.5,\n                 time_limit=15.0,\n                 no_improve_limit=40,\n                 shortcut_passes=6,\n                 shortcut_attempts=600,\n                 uniform_sample_chance=0.12,\n                 goal_sample_chance=0.07,\n                 grid_cell_size=12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_chance = uniform_sample_chance\n        self.goal_sample_chance = goal_sample_chance\n        self.grid_cell_size = grid_cell_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import time\n        import random\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,) * (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,res=1.0):\n            dist = math.dist(a,b)\n            if dist < 1e-12:\n                return False\n            steps = max(2,int(dist/res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm,to):\n            dist = math.dist(frm,to)\n            if dist <= self.step_size:\n                return to\n            r = self.step_size/dist\n            return tuple(frm[d] + (to[d]-frm[d])*r for d in range(dim))\n\n        class SpatialGrid:\n            __slots__ = ('cell_size','dim','grid')\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self,pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self,node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self,node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self,pos,radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                result = []\n                rng = range(-cr,cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx,base[1]+dy)\n                            if cell in self.grid:\n                                result.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx,base[1]+dy,base[2]+dz)\n                                if cell in self.grid:\n                                    result.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for node in result:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        dist_sq += (node.position[d]-pos[d])**2\n                    if dist_sq <= r2:\n                        filtered.append(node)\n                return filtered\n            def nearest(self,pos):\n                base = self._hash(pos)\n                search_range = 0\n                candidates = []\n                max_search = 7\n                while not candidates and search_range <= max_search:\n                    rng = range(-search_range, search_range+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        candidates.extend(self.grid[cell])\n                    search_range += 1\n                if not candidates:\n                    return None\n                nearest_node = min(candidates,key=lambda n:math.dist(n.position,pos))\n                return nearest_node\n\n        # Sampling strategies\n        def sample_uniform():\n            for _ in range(30):\n                p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n            center = tuple(0.5*(start_pos[d]+goal_pos[d]) for d in range(dim))\n            a1 = [(goal_pos[d]-start_pos[d])/c_min for d in range(dim)]\n            # Radii of ellipse axes:\n            r1 = c_best*0.5\n            squared = max(0.0, c_best*c_best - c_min*c_min)\n            r_others = math.sqrt(squared)*0.5 if dim > 1 else 0\n            radii = [r1] + [r_others]*(dim-1)\n            # Build orthonormal basis with a1 as first vector\n            basis = []\n            basis.append(a1)\n            for i in range(1,dim):\n                v = [0.0]*dim\n                v[i] = 1.0\n                # Gram-Schmidt\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j] - proj*b[j] for j in range(dim)]\n                norm_v = math.sqrt(sum(x*x for x in v))\n                if norm_v > 1e-10:\n                    v = [x/norm_v for x in v]\n                else:\n                    v = [0.0]*dim\n                basis.append(v)\n            for _ in range(40):\n                vec = [random.gauss(0,1) for _ in range(dim)]\n                norm_vec = math.sqrt(sum(x*x for x in vec))\n                if norm_vec < 1e-10:\n                    continue\n                unit_vec = [x/norm_vec for x in vec]\n                r = random.random()**(1/dim)\n                scale = [radii[i]*unit_vec[i]*r for i in range(dim)]\n                p = [center[j] + sum(basis[i][j]*scale[i] for i in range(dim)) for j in range(dim)]\n                clamped = tuple(max(0.0,min(bounds[d],p[d])) for d in range(dim))\n                if not in_obstacle(clamped):\n                    return clamped\n            return sample_uniform()\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def adaptive_radius(n_nodes):\n            if n_nodes < 2:\n                return self.base_radius\n            val = self.base_radius * (math.log(n_nodes+1)/(n_nodes+1))**(1/dim)\n            return max(self.min_radius, min(val, self.base_radius))\n\n        def choose_parent(nodes, grid, pos, radius):\n            neighbors = grid.query_radius(pos, radius)\n            candidates = [n for n in neighbors if n and not edge_in_obstacle(n.position, pos)]\n            if not candidates:\n                nearest = grid.nearest(pos)\n                if nearest is None or edge_in_obstacle(nearest.position, pos) or in_obstacle(pos):\n                    return None, []\n                candidates = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in candidates:\n                c = nb.cost + math.dist(nb.position, pos)\n                if c < best_cost:\n                    best_cost = c\n                    best_parent = nb\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, candidates\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(new_node.position, nb.position):\n                        continue\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    stack = [nb]\n                    while stack:\n                        curr = stack.pop()\n                        for ch in curr.children:\n                            new_ch_cost = curr.cost + math.dist(curr.position, ch.position)\n                            if new_ch_cost + 1e-12 < ch.cost:\n                                ch.cost = new_ch_cost\n                                ch.parent = curr\n                                stack.append(ch)\n\n        def try_connect(tree_nodes, tree_grid, other_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_grid.nearest(other_node.position)\n            if nearest is None:\n                return None\n            dist = math.dist(nearest.position, other_node.position)\n            if dist <= self.step_size:\n                if edge_in_obstacle(nearest.position, other_node.position) or in_obstacle(other_node.position):\n                    return None\n                new_node = Node(other_node.position, parent=nearest, cost=nearest.cost+dist)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                return new_node\n            current = nearest\n            max_steps = int(math.ceil(dist/self.step_size))\n            for _ in range(max_steps):\n                new_pos = steer(current.position, other_node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos) or \n                    edge_in_obstacle(current.position, new_pos)):\n                    return None\n                d = math.dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=current.cost+d)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, other_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, other_node.position) or in_obstacle(other_node.position):\n                        return None\n                    final_node = Node(other_node.position, parent=current, cost=current.cost + math.dist(current.position, other_node.position))\n                    tree_nodes.append(final_node)\n                    tree_grid.insert(final_node)\n                    return final_node\n            return None\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _pass in range(self.shortcut_passes):\n                changed = True\n                attempt = 0\n                while changed and attempt < self.shortcut_attempts:\n                    changed = False\n                    attempt += 1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path) - 3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1, p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        def smooth_path(path):\n            # Curvature-aware lightweight smoothing by iterative averaging without entering obstacles\n            if len(path) < 4:\n                return path[:]\n            smoothed = list(path)\n            alpha = 0.15  # blending factor\n            for _ in range(7):\n                for i in range(1, len(smoothed)-1):\n                    prev_p = smoothed[i-1]\n                    curr_p = smoothed[i]\n                    next_p = smoothed[i+1]\n                    new_pt = tuple(\n                        curr_p[d] + alpha * (prev_p[d] + next_p[d] - 2 * curr_p[d])\n                        for d in range(dim)\n                    )\n                    # Clamp to bounds\n                    clamped = tuple(max(0.0, min(bounds[d], new_pt[d])) for d in range(dim))\n                    if (not in_obstacle(clamped) and\n                        not edge_in_obstacle(smoothed[i-1], clamped) and\n                        not edge_in_obstacle(clamped, smoothed[i+1])):\n                        smoothed[i] = clamped\n            return smoothed\n\n        # Initialize trees and grids\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found = False\n        no_improve_count = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n\n            r = random.random()\n            if r < self.goal_sample_chance:\n                sample_pt = sample_goal()\n            elif found and r < self.goal_sample_chance + (1 - self.goal_sample_chance) * (1 - self.uniform_sample_chance):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid_a.nearest(sample_pt)\n            if nearest is None:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if (not in_bounds(new_pos) or in_obstacle(new_pos) or \n                edge_in_obstacle(nearest.position, new_pos)):\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            new_node, neighbors = choose_parent(tree_a, grid_a, new_pos, radius)\n            if new_node is None:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid_a)\n\n            connect_node = try_connect(tree_b, grid_b, new_node)\n            if connect_node is not None:\n                if it % 2 == 0:\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = connect_node.path_from_root()\n                else:\n                    path_from_start = connect_node.path_from_root()\n                    path_from_goal = new_node.path_from_root()\n\n                if path_from_start and path_from_goal and (path_from_start[-1] == path_from_goal[0]):\n                    merged = path_from_start + path_from_goal[1:]\n                else:\n                    merged = path_from_start + path_from_goal[::-1]\n\n                # Calculate cost\n                total_cost = 0.0\n                for i in range(len(merged)-1):\n                    total_cost += math.dist(merged[i], merged[i+1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = merged\n                    found = True\n                    no_improve_count = 0\n                else:\n                    if found:\n                        no_improve_count += 1\n                        if no_improve_count >= self.no_improve_limit:\n                            break\n            else:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n        if found and len(best_path) > 3:\n            best_path = shortcut_path(best_path)\n            best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found, path=best_path,\n                             nodes=start_tree + goal_tree,\n                             edges=[])",
                "objective": -22.47355,
                "time_improvement": 31.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 210.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.02435743808746338,
                        "num_nodes_avg": 134.9,
                        "path_length_avg": 150.0151772566704,
                        "smoothness_avg": 0.011776657899457267,
                        "success_improvement": 0.0,
                        "time_improvement": -0.2964839167292523,
                        "length_improvement": 17.77430420301498,
                        "smoothness_improvement": 84.3302695484517,
                        "objective_score": 10.997288694532472
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.034082865715026854,
                        "num_nodes_avg": 318.3,
                        "path_length_avg": 236.9473194012731,
                        "smoothness_avg": 0.010060586508523858,
                        "success_improvement": 0.0,
                        "time_improvement": 78.89151820994326,
                        "length_improvement": 20.900164633419585,
                        "smoothness_improvement": 158.8661372118814,
                        "objective_score": 37.00188492909413
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.0427628755569458,
                        "num_nodes_avg": 416.9,
                        "path_length_avg": 116.96333679077054,
                        "smoothness_avg": 0.038308683773727,
                        "success_improvement": 0.0,
                        "time_improvement": 13.64651789798031,
                        "length_improvement": 22.318520899155825,
                        "smoothness_improvement": 387.283629948907,
                        "objective_score": 19.421486058632123
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "A Bidirectional Adaptive Informed RRT* planner integrating spatial hashing for accelerated nearest neighbor search, dynamic adaptive rewiring with curvature-aware cost propagation, integrated pruning of suboptimal nodes to constrain tree size, and an enhanced multi-pass shortcutting and curvature-aware smoothing during planning and post-processing. The planner balances exploration and informed focused sampling within ellipsoidal regions shrinking with best path cost, alternates tree expansions from start and goal, and aggressively optimizes path length and smoothness while controlling computational cost via pruning and efficient collision checks.",
            "planning_mechanism": "The planner maintains two trees grown alternately from start and goal positions. Sampling shifts from uniform to ellipsoidal informed sampling focused around the current best solution, with fallback uniform sampling. Spatial hashing accelerates nearest and neighbor searches allowing efficient adaptive rewiring within a radius that diminishes with tree size and best path cost. New nodes integrate curvature penalties directly into cost evaluation to favor smooth transitions. Rewiring triggers downstream cost propagation and curvature checks to enhance smoothness. Suboptimal branches exceeding cost and curvature thresholds are pruned dynamically to reduce overhead. Finally, multi-pass shortcutting and curvature-aware smoothing\u2014executed both during planning and after termination\u2014refine the extracted path into a shorter, smoother trajectory while ensuring collision-free continuity. Early stopping occurs based on improvement stagnation or time limit, resulting in robust, efficient planning with high-quality paths.",
            "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 base_radius=20.0,\n                 min_radius=5.0,\n                 time_limit=15.0,\n                 no_improve_limit=60,\n                 shortcut_passes=5,\n                 shortcut_attempts=400,\n                 uniform_sample_prob=0.1,\n                 goal_sample_prob=0.08,\n                 grid_cell_size=15.0,\n                 curvature_w=0.06,\n                 max_curvature_increase=0.12,\n                 prune_cost_factor=1.8):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_prob = uniform_sample_prob\n        self.goal_sample_prob = goal_sample_prob\n        self.grid_cell_size = grid_cell_size\n        self.curvature_w = curvature_w\n        self.max_curvature_increase = max_curvature_increase\n        self.prune_cost_factor = prune_cost_factor\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,) * (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a,b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_f_t = math.dist(frm, to)\n            if dist_f_t <= self.step_size:\n                return to\n            r = self.step_size / dist_f_t\n            return tuple(frm[d] + (to[d] - frm[d]) * r for d in range(dim))\n\n        # Curvature penalty: angle between vectors (parent->current) and (current->new)\n        def curvature_penalty(p_parent, p_curr, p_new):\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_curr[d] - p_parent[d] for d in range(dim))\n            v2 = tuple(p_new[d] - p_curr[d] for d in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[d]*v2[d] for d in range(dim)) / (len1 * len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        # Spatial hashing for fast neighbor queries\n        class SpatialGrid:\n            __slots__ = ('cell_size', 'dim', 'grid')\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self, pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self, node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self, node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self, pos, radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                result = []\n                rng = range(-cr, cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx, base[1]+dy)\n                            if cell in self.grid:\n                                result.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                if cell in self.grid:\n                                    result.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for node in result:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        diff = node.position[d] - pos[d]\n                        dist_sq += diff*diff\n                        if dist_sq > r2:\n                            break\n                    else:\n                        filtered.append(node)\n                return filtered\n            def nearest(self, pos):\n                base = self._hash(pos)\n                search_range = 0\n                candidates = []\n                max_search = 8\n                while not candidates and search_range <= max_search:\n                    rng = range(-search_range, search_range+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        candidates.extend(self.grid[cell])\n                    search_range += 1\n                if not candidates:\n                    return None\n                nearest_node = min(candidates, key=lambda n: math.dist(n.position,pos))\n                return nearest_node\n\n        # Sampling methods\n        def sample_uniform():\n            for _ in range(30):\n                p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d]+goal_pos[d])*0.5 for d in range(dim))\n            # Unit vector from start to goal:\n            dvec = [(goal_pos[d]-start_pos[d]) / c_min for d in range(dim)]\n            # Build orthonormal basis\n            basis = [dvec]\n            for i in range(1, dim):\n                v = [0.0]*dim\n                v[i] = 1.0\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j]-proj*b[j] for j in range(dim)]\n                normv = math.sqrt(sum(x*x for x in v))\n                basis.append([x/normv if normv>1e-14 else 0.0 for x in v])\n            r_long = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r_short = math.sqrt(max(0.0,val))*0.5 if dim > 1 else 0.0\n            radii = [r_long] + [r_short]*(dim-1)\n            for _ in range(40):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                unit_x = [x / norm_x for x in x_ball]\n                u = random.random()**(1/dim)\n                scaled = [radii[i]*unit_x[i]*u for i in range(dim)]\n                sample = [center[d] + sum(basis[i][d]*scaled[i] for i in range(dim)) for d in range(dim)]\n                sample = tuple(max(0.0, min(bounds[d], sample[d])) for d in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes < 2:\n                return self.base_radius\n            val = self.base_radius * (math.log(n_nodes+1) / (n_nodes+1))**(1/dim)\n            radius = max(self.min_radius, min(val, self.base_radius))\n            if c_best == float('inf'):\n                return radius\n            # Shrink radius with best solution cost to focus rewiring locally\n            shrink_factor = c_best / (math.dist(start_pos, goal_pos) * 2.8)\n            return max(self.min_radius, radius * max(0.4, shrink_factor))\n\n        def choose_parent(nodes, grid, pos, radius, c_best):\n            neighbors = grid.query_radius(pos, radius)\n            candidates = []\n            for nb in neighbors:\n                if in_obstacle(pos) or edge_in_obstacle(nb.position, pos):\n                    continue\n                candidates.append(nb)\n            if not candidates:\n                nearest = grid.nearest(pos)\n                if nearest is None or in_obstacle(pos) or edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                candidates = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in candidates:\n                c = nb.cost + math.dist(nb.position, pos)\n                curv = curvature_penalty(nb.parent.position if nb.parent else None, nb.position, pos)\n                score = c + self.curvature_w * curv\n                if score < best_cost:\n                    best_cost = score\n                    best_parent = nb\n            if best_parent is None:\n                return None, []\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, candidates\n\n        def propagate_costs(node, grid):\n            # DFS propagate improved costs downstream\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for ch in curr.children[:]:\n                    new_cost = curr.cost + math.dist(curr.position, ch.position)\n                    curv = curvature_penalty(curr.parent.position if curr.parent else None, curr.position, ch.position)\n                    new_score = new_cost + self.curvature_w * curv\n                    old_score = ch.cost + (self.curvature_w * curvature_penalty(ch.parent.parent.position if ch.parent and ch.parent.parent else None, ch.parent.position if ch.parent else None, ch.position) if ch.parent else 0)\n                    if new_score + 1e-10 < old_score:\n                        if edge_in_obstacle(curr.position, ch.position):\n                            continue\n                        ch.cost = new_cost\n                        ch.parent.remove_child(ch)\n                        curr.add_child(ch)\n                        stack.append(ch)\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                dist_new_nb = math.dist(new_node.position, nb.position)\n                new_cost = new_node.cost + dist_new_nb\n                if new_cost + 1e-12 >= nb.cost:\n                    continue\n                if edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                # Curvature penalty with parent-child relation check\n                curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, nb.position)\n                curv_old = curvature_penalty(nb.parent.parent.position if nb.parent and nb.parent.parent else None,\n                                            nb.parent.position if nb.parent else None, nb.position)\n                if self.curvature_w * curv_new > self.curvature_w * curv_old + self.max_curvature_increase:\n                    continue\n                if nb.parent is not None:\n                    nb.parent.remove_child(nb)\n                new_node.add_child(nb)\n                nb.cost = new_cost\n                propagate_costs(nb, grid)\n\n        def try_connect(tree_nodes, tree_grid, other_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_grid.nearest(other_node.position)\n            if nearest is None:\n                return None\n            dist_n_o = math.dist(nearest.position, other_node.position)\n            if dist_n_o <= self.step_size:\n                if edge_in_obstacle(nearest.position, other_node.position) or in_obstacle(other_node.position):\n                    return None\n                new_node = Node(other_node.position, parent=nearest, cost=nearest.cost+dist_n_o)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                return new_node\n            current = nearest\n            max_steps = int(math.ceil(dist_n_o / self.step_size))\n            for _ in range(max_steps):\n                new_pos = steer(current.position, other_node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos)):\n                    return None\n                dist_c_np = math.dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=current.cost+dist_c_np)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, other_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, other_node.position) or in_obstacle(other_node.position):\n                        return None\n                    final_node = Node(other_node.position, parent=current, cost=current.cost + math.dist(current.position, other_node.position))\n                    tree_nodes.append(final_node)\n                    tree_grid.insert(final_node)\n                    return final_node\n            return None\n\n        # Prune nodes that are far above best_path cost to keep tree small\n        def prune_tree(nodes, grid, cost_limit):\n            remove_nodes = []\n            for n in nodes:\n                if n.cost > cost_limit:\n                    remove_nodes.append(n)\n            for n in remove_nodes:\n                # Remove from parent's children list\n                if n.parent:\n                    n.parent.remove_child(n)\n                # Remove from grid and nodes list\n                grid.remove(n)\n                if n in nodes:\n                    nodes.remove(n)\n                # Post removal descendants are unreachable, no direct deletion here (could be improved)\n            return len(remove_nodes)\n\n        # Shortcutting path by removing intermediate nodes with collision-free chords\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _pass in range(self.shortcut_passes):\n                changed = True\n                attempts = 0\n                while changed and attempts < self.shortcut_attempts:\n                    changed = False\n                    attempts +=1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path)-3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1, p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        # Curvature-aware smoothing by iterative averaging during and after planning\n        def smooth_path(path):\n            if len(path) < 4:\n                return list(path)\n            smoothed = list(path)\n            alpha = 0.17\n            for _ in range(9):\n                for i in range(1, len(smoothed)-1):\n                    prev_p, curr_p, next_p = smoothed[i-1], smoothed[i], smoothed[i+1]\n                    new_pt = tuple(curr_p[d] + alpha*(prev_p[d] + next_p[d] - 2*curr_p[d]) for d in range(dim))\n                    # Clamp and collision check\n                    new_pt = tuple(max(0.0, min(bounds[d], new_pt[d])) for d in range(dim))\n                    if (not in_obstacle(new_pt) and not edge_in_obstacle(smoothed[i-1], new_pt) and not edge_in_obstacle(new_pt, smoothed[i+1])):\n                        smoothed[i] = new_pt\n            return smoothed\n\n        # Extract combined path from start_node to goal_node by reversing one branch and concatenating\n        def combine_paths(start_node, goal_node, reverse_start):\n            path_start = start_node.path_from_root()\n            path_goal = goal_node.path_from_root()\n            if reverse_start:\n                # path_start reversed, so goal_node tree is forward\n                path_start.reverse()\n                full_path = path_goal + path_start[1:]\n            else:\n                # start_node forward, goal_node reversed\n                path_goal.reverse()\n                full_path = path_start + path_goal[1:]\n            return full_path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n        start_time = time.time()\n        c_min = math.dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n                reverse_start = False\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n                reverse_start = True\n\n            r = random.random()\n            if r < self.goal_sample_prob:\n                sample_pt = sample_goal()\n            elif found_solution and r < self.goal_sample_prob + (1 - self.goal_sample_prob - self.uniform_sample_prob):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid_a.nearest(sample_pt)\n            if nearest is None:\n                if found_solution:\n                    no_improve_count +=1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            radius = adaptive_radius(len(tree_a), best_cost)\n            new_node, neighbors = choose_parent(tree_a, grid_a, new_pos, radius, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid_a)\n\n            connect_node = try_connect(tree_b, grid_b, new_node)\n            if connect_node:\n                candidate_path = combine_paths(new_node, connect_node, reverse_start)\n                total_cost = 0.0\n                for i in range(len(candidate_path) -1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i+1])\n                if total_cost + 1e-10 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                    # Prune both trees aggressively to trim nodes far away from best cost\n                    cost_limit = best_cost * self.prune_cost_factor\n                    prune_tree(start_tree, start_grid, cost_limit)\n                    prune_tree(goal_tree, goal_grid, cost_limit)\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count +=1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n            # Early abort if improvement stagnates heavily\n            if found_solution and no_improve_count >= self.no_improve_limit:\n                break\n\n        if found_solution and len(best_path) > 3:\n            # Multi-pass shortcutting and smoothing post-planning\n            for _ in range(2):\n                best_path = shortcut_path(best_path)\n                best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path,\n                             nodes=start_tree + goal_tree,\n                             edges=[])",
            "objective": -21.94032,
            "time_improvement": 27.0,
            "length_improvement": 21.0,
            "smoothness_improvement": 218.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.033988142013549806,
                    "num_nodes_avg": 152.2,
                    "path_length_avg": 155.0029124627248,
                    "smoothness_avg": 0.013386992872664144,
                    "success_improvement": 0.0,
                    "time_improvement": -39.95277855498452,
                    "length_improvement": 15.040447500854501,
                    "smoothness_improvement": 109.53550877750344,
                    "objective_score": -2.413887522095137
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03955721855163574,
                    "num_nodes_avg": 342.0,
                    "path_length_avg": 225.80758202741654,
                    "smoothness_avg": 0.014658329875318548,
                    "success_improvement": 0.0,
                    "time_improvement": 75.50109681374721,
                    "length_improvement": 24.618929608374863,
                    "smoothness_improvement": 277.16938566019917,
                    "objective_score": 38.80753373745007
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.027274346351623534,
                    "num_nodes_avg": 269.3,
                    "path_length_avg": 113.89325843043791,
                    "smoothness_avg": 0.02886494217452123,
                    "success_improvement": 0.0,
                    "time_improvement": 44.923376904744714,
                    "length_improvement": 24.357520764667115,
                    "smoothness_improvement": 267.15993387150496,
                    "objective_score": 29.427325199581208
                }
            ],
            "success_rate": 1.0
        },
        "objective": 611.2,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient nearest neighbor and radius search implementations caused slower planning as tree sizes increased.\n   - Limited or rudimentary handling of curvature in edge cost and rewiring permitted jagged or less smooth paths.\n   - Lack of pruning mechanisms allowed the growth of large trees with many suboptimal nodes, increasing computational overhead.\n   - Sampling strategies were less adaptive, often relying on uniform or simplistic informed sampling, reducing focused exploration.\n   - Shortcutting and smoothing were applied only after planning or with minimal passes, limiting improvements in path smoothness."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Introduction of spatial hashing significantly accelerated nearest neighbor and radius queries, enabling more efficient rewiring and exploration.\n   - Integration of curvature-aware cost functions directly into parent selection and rewiring encouraged smoother path construction.\n   - Dynamic pruning of nodes with costs substantially above the current best solution reduced tree size and computational burden.\n   - Adaptive adjustment of rewiring radius based on best path cost focused optimization locally, improving convergence speed and path quality.\n   - Enhanced multi-pass shortcutting combined with curvature-sensitive smoothing applied during and after planning refined paths effectively.\n2. Expected mechanism of impact:\n   - Faster neighbor searches allowed more iterations and rewiring within limited time, improving path optimality.\n   - Considering curvature penalties prevented sharp turns and jagged connections, resulting in smoother trajectories.\n   - Pruning removed costly and unlikely-to-improve regions of the tree, focusing computational resources on promising areas.\n   - Adaptive sampling and radius shrinkage concentrated efforts near the current best path, enhancing optimization efficiency.\n   - Progressive smoothing techniques removed small suboptimal detours and straightened the path while respecting collision constraints, significantly improving path smoothness."
        }
    }
]