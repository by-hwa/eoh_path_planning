[
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -23.76291481494683,
                "time_improvement": 61.0,
                "length_improvement": 8.0,
                "smoothness_improvement": 166.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.012529301643371581,
                        "num_nodes_avg": 131.9,
                        "path_length_avg": 176.77827310097746,
                        "smoothness_avg": 0.01645631271580969,
                        "success_improvement": 0.0,
                        "time_improvement": 48.408166070262766,
                        "length_improvement": 3.105027282357968,
                        "smoothness_improvement": 157.5770294574498,
                        "objective_score": 17.173351337780858
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.01886875629425049,
                        "num_nodes_avg": 256.8,
                        "path_length_avg": 267.7347696890942,
                        "smoothness_avg": 0.010597136127488454,
                        "success_improvement": 0.0,
                        "time_improvement": 88.31404606735866,
                        "length_improvement": 10.622427559723258,
                        "smoothness_improvement": 172.67194536891012,
                        "objective_score": 33.7310300828861
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.026641178131103515,
                        "num_nodes_avg": 304.4,
                        "path_length_avg": 136.29588257526552,
                        "smoothness_avg": 0.02101448639210645,
                        "success_improvement": 0.0,
                        "time_improvement": 46.20196913892299,
                        "length_improvement": 9.478764505998065,
                        "smoothness_improvement": 167.3027157795587,
                        "objective_score": 20.384363024173528
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm with post-optimization: a single-tree, asymptotically optimal sampler that, after the first feasible path, restricts sampling to a start\u2013goal prolate hyperspheroid to accelerate convergence while continuing local rewiring to reduce path cost.",
                "planning_mechanism": "Mechanism: (1) Grow one tree from the start using uniform sampling; (2) when a goal-connecting edge is found, record the best cost and switch to informed sampling inside the ellipsoid defined by start, goal, and current best path length; (3) for each sample, steer a step from the nearest node, then select the lowest-cost parent among nearby nodes and rewire neighbors if the new node offers cheaper paths; (4) whenever the new node lies within one step of the goal and the edge is collision-free, connect and update the best path; (5) after the first solution, continue only a limited number of additional iterations or until no further improvements occur; (6) every candidate node and edge is validated against obstacle occupancy and line-segment collisions, and results include the best path found within the iteration budget.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 post_opt_iters: int = 500, max_no_improve: int = 150,\n                 improve_tol: float = 1e-6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        goal_node = Node(goal)\n        nodes.append(root)\n        tree = [root]\n\n        best_cost = float(\"inf\")\n        best_goal_node = None\n        c_min = math.dist(start, goal)\n\n        found_first_solution = False\n        post_iter_count = 0\n        no_improve_streak = 0\n\n        for _ in range(self.max_iter):\n            x_rand = self._sample(start, goal, best_cost, c_min, is_3d, bounds)\n\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n            x_new_pos = self._steer(x_nearest.position, x_rand)\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n                continue\n\n            x_new = Node(x_new_pos)\n            near_nodes = [n for n in tree if math.dist(n.position, x_new_pos) <= 20.0]\n\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near_nodes:\n                new_cost = n.cost + math.dist(n.position, x_new_pos)\n                if new_cost < min_cost and not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                    best_parent = n\n                    min_cost = new_cost\n\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            x_new.parent = best_parent\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            for n in near_nodes:\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost + 1e-12 < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                        if n in n.parent.children:\n                            n.parent.children.remove(n)\n                    n.parent = x_new\n                    n.cost = alt_cost\n                    x_new.add_child(n)\n                    edges.append((x_new, n))\n\n            if math.dist(x_new.position, goal) < self.step_size and                not self._is_edge_in_obstacle(x_new.position, goal, obstacles, is_3d):\n                # \uc0c8 \ud574 \ud6c4\ubcf4\n                goal_node = Node(goal)  # \ubaa9\ud45c \ub178\ub4dc\ub294 \uc0c8\ub85c \ub9cc\ub4e4\uc5b4 \uba85\ud655\ud788 \uc5f0\uacb0\n                goal_node.parent = x_new\n                goal_node.cost = x_new.cost + math.dist(x_new.position, goal)\n                nodes.append(goal_node)\n                edges.append((x_new, goal_node))\n\n                if goal_node.cost + self.improve_tol < best_cost:\n                    best_cost = goal_node.cost\n                    best_goal_node = goal_node\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    no_improve_streak = 0  \n                else:\n                    no_improve_streak += 1\n\n                if not found_first_solution:\n                    found_first_solution = True\n                    post_iter_count = 0  \n                else:\n                    post_iter_count += 1\n\n                if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                    break\n            else:\n                if found_first_solution:\n                    post_iter_count += 1\n                    no_improve_streak += 1\n                    if post_iter_count >= self.post_opt_iters or no_improve_streak >= self.max_no_improve:\n                        break\n\n        if success_state and best_goal_node is not None:\n            extracted_path = best_goal_node.path_from_root()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample(self, start, goal, c_best, c_min, is_3d, bounds):\n        import numpy as np\n        import math, random\n\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        dim = len(start)\n        L = np.diag([c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1))\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        I = np.eye(dim)\n        M = np.outer(a1, I[:, 0])\n        U, _, Vt = np.linalg.svd(M)\n        C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm = np.linalg.norm(x_ball)\n            if norm > 1e-6:\n                x_ball = x_ball / norm * random.random() ** (1.0 / dim)\n            x_rand = np.dot(C, np.dot(L, x_ball)) + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    \n",
                "objective": 254.21494524343552,
                "time_improvement": -899.0,
                "length_improvement": 22.0,
                "smoothness_improvement": 414.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.35683939456939695,
                        "num_nodes_avg": 772.1,
                        "path_length_avg": 150.94653533720216,
                        "smoothness_avg": 0.030245912861543284,
                        "success_improvement": 0.0,
                        "time_improvement": -1369.3555401750432,
                        "length_improvement": 17.263812080762307,
                        "smoothness_improvement": 373.41421633417696,
                        "objective_score": -398.5813037223847
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.6798739194869995,
                        "num_nodes_avg": 1185.7,
                        "path_length_avg": 222.10813211370723,
                        "smoothness_avg": 0.021429118285859527,
                        "success_improvement": 0.0,
                        "time_improvement": -321.06512900112574,
                        "length_improvement": 25.853912472332702,
                        "smoothness_improvement": 451.3866482651889,
                        "objective_score": -78.55025797561215
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.5478150129318238,
                        "num_nodes_avg": 1082.6,
                        "path_length_avg": 114.7698430835218,
                        "smoothness_avg": 0.040749199207674086,
                        "success_improvement": 0.0,
                        "time_improvement": -1006.2336968296382,
                        "length_improvement": 23.77533497656441,
                        "smoothness_improvement": 418.326806128603,
                        "objective_score": -285.51327403230977
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "A bidirectional variant of RRT* with informed sampling and efficient rewiring that grows two trees simultaneously, restricts sampling to an ellipsoidal informed subset after first solution, and performs local rewiring to improve path cost and smoothness with early termination on convergence.",
            "planning_mechanism": "The planner grows start and goal trees bidirectionally with RRT* rewiring, initially samples uniformly to quickly find a path, then constrains samples to an ellipsoidal informed set defined by the current best path cost. After each extension, it attempts to connect the two trees if close enough, while performing localized rewiring to continuously improve path quality. Early stopping criteria limit iterations after no improvements to reduce planning time.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, radius=15.0,\n                 post_opt_iters=500, max_no_improve=100, improve_tol=1e-5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n\n        c_min = math.dist(start, goal)\n        found_solution = False\n\n        no_improve_count = 0\n        post_opt_count = 0\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            return tuple(frm[i] + (to[i]-frm[i]) * self.step_size / d for i in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            distance = dist(f, t)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                inter = tuple(f[j] + (t[j]-f[j])*(i/steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def nearest(tree, p):\n            best = tree[0]\n            best_d = dist(best.position, p)\n            for n in tree:\n                d2 = dist(n.position, p)\n                if d2 < best_d:\n                    best = n\n                    best_d = d2\n            return best\n\n        def near_nodes(tree, p, radius):\n            result = []\n            r2 = radius**2\n            for n in tree:\n                d2 = sum((n.position[i]-p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def extract_path(n_start, n_goal):\n            path_start, node = [], n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def ellipsoid_sample(c_best):\n            # Sample inside prolate hyperspheroid defined by start, goal, c_best\n            import random\n            import math\n\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i]+goal[i])/2 for i in range(dim))\n            a1 = [goal[i]-start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-12:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            # Compute rotation matrix via Gram-Schmidt or approximate as identity except along a1 axis\n            # For simplicity, rotate only along principal axis for 2D or 3D (orthonormal basis)\n            # Since imports are restricted, implement a simple orthonormal basis:\n\n            # Construct orthonormal basis U with unit_a1 as first vector\n            U = [unit_a1]\n            for i in range(dim-1):\n                base = [0]*dim\n                base[(i+1)%dim] = 1  # simple perpendicular approx\n                # Gram-Schmidt orthogonalize base vs U\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j]-proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-12:\n                    U.append([x/norm_base for x in base])\n                else:\n                    # fallback: constructs zero vector, skip\n                    U.append([0]*dim)\n\n            # L matrix diagonal\n            r1 = c_best / 2\n            if c_best*c_best - c_min*c_min < 0:\n                r2 = 0\n            else:\n                r2 = math.sqrt(c_best*c_best - c_min*c_min) / 2\n            radii = [r1] + [r2] * (dim - 1)\n\n            # Sample unit ball in dim\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-12:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n\n                # Scale by radii\n                point_scaled = [radii[i]*point_ball[i] for i in range(dim)]\n\n                # Rotate via U matrix: point = sum(point_scaled[i] * U[i]) over basis vectors\n                point_rotated = [0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i]*U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        for iter_count in range(self.max_iter):\n            if found_solution:\n                sample_pt = ellipsoid_sample(best_cost)\n            else:\n                sample_pt = ellipsoid_sample(float('inf'))\n\n            # Alternate growing start and goal trees\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n\n                if in_obstacle(new_pos) or edge_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                near = near_nodes(tree_a, new_pos, self.radius)\n\n                # Choose best parent in near nodes with minimal cost + dist and collision free edge\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for candidate in near:\n                    cand_cost = candidate.cost + dist(candidate.position, new_pos)\n                    if cand_cost + self.improve_tol < min_cost and not edge_obstacle(candidate.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = candidate\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire near nodes if new_node offers lower cost connection\n                for near_node in near:\n                    if near_node == best_parent:\n                        continue\n                    alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if alt_cost + self.improve_tol < near_node.cost and not edge_obstacle(new_node.position, near_node.position):\n                        # Remove old edge\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                        if near_node.parent and near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n                # Try connect trees if nodes close enough\n                connect_node = nearest(tree_b, new_node.position)\n                if dist(new_node.position, connect_node.position) <= self.step_size and not edge_obstacle(new_node.position, connect_node.position):\n                    path = extract_path(new_node, connect_node)\n                    path_cost = new_node.cost + dist(new_node.position, connect_node.position) + connect_node.cost\n                    if path_cost + self.improve_tol < best_cost:\n                        best_cost = path_cost\n                        # Stitch trees at connection nodes: assign parents carefully\n                        # For bidirectional path extraction, keep nodes and edges unchanged,\n                        # just store nodes for path extraction\n                        best_path = path\n                        found_solution = True\n                        best_goal_node = connect_node\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n\n                    if found_solution and no_improve_count >= self.max_no_improve:\n                        post_opt_count += 1\n                        if post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_opt_count += 1\n                        if no_improve_count >= self.max_no_improve or post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
            "objective": 52.64884,
            "time_improvement": -220.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 323.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06786198616027832,
                    "num_nodes_avg": 317.3,
                    "path_length_avg": 155.50621247453464,
                    "smoothness_avg": 0.02411673119934513,
                    "success_improvement": 0.0,
                    "time_improvement": -179.4349134355319,
                    "length_improvement": 14.764580789082476,
                    "smoothness_improvement": 277.4792135897667,
                    "objective_score": -43.58432948926125
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.14667820930480957,
                    "num_nodes_avg": 670.6,
                    "path_length_avg": 226.29277909188164,
                    "smoothness_avg": 0.017873034085429756,
                    "success_improvement": 0.0,
                    "time_improvement": 9.158040406689327,
                    "length_improvement": 24.45695686263326,
                    "smoothness_improvement": 359.8860404442116,
                    "objective_score": 19.22101644180781
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.2925038576126099,
                    "num_nodes_avg": 613.1,
                    "path_length_avg": 120.56565817380633,
                    "smoothness_avg": 0.03399415459254427,
                    "success_improvement": 0.0,
                    "time_improvement": -490.6695072338173,
                    "length_improvement": 19.926030560654297,
                    "smoothness_improvement": 332.4031372296796,
                    "objective_score": -133.58321814760419
                }
            ],
            "success_rate": 1.0
        },
        "objective": 12.8,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient exploration due to uniform or unconstrained sampling leading to slower convergence.\n   - Excessive computational overhead from redundant collision checks and suboptimal nearest-neighbor searches.\n   - Limited or fixed-radius rewiring strategies reducing flexibility in path cost improvement.\n   - Lack of robust bidirectional tree connection and adaptive sampling strategies.\n   - Absence of effective early stopping criteria causing unnecessary iterations after convergence."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Introduction of bidirectional tree growth with systematic alternating expansion and connection attempts.\n   - Adoption of informed, ellipsoidal sampling focused on the subset of the state space likely to yield better paths.\n   - Implementation of adaptive local rewiring with cost-based edge updating to improve path quality continuously.\n   - Enhanced termination conditions based on improvement stagnation to reduce planning time.\n2. Expected mechanism of impact:\n   - Focused sampling reduces exploration of irrelevant regions, accelerating better path discovery.\n   - Efficient rewiring and connection reduce overall path length by optimizing node parents and connections dynamically.\n   - Bidirectional expansion shortens the time to find feasible connections between start and goal regions.\n   - Early stopping avoids unnecessary computations after solution quality plateaus, improving computational efficiency."
        }
    },
    {
        "parents": [
            {
                "operator": "e2",
                "algorithm_description": "A bidirectional informed RRT* planner with adaptive step sizing, dynamic neighbor radius using k-nearest approach, obstacle-aware rewiring, and heuristic-guided sampling that progressively focuses sampling within an ellipsoid to concentrate efforts around promising paths. The planner implements pruning of trees beyond the current best cost, uses balanced tree growth with rapid connection attempts, and performs iterative path shortcutting to smooth and shorten the resulting path efficiently, terminating early if no significant improvements are observed.",
                "planning_mechanism": "The algorithm alternates growth between the two trees with adaptive step sizes reducing as better paths are found, samples in an admissible ellipsoidal region shrinking with best costs to intensify search near the optimum, applies k-nearest rewiring for flexible neighborhood connection, prunes nodes exceeding current best path cost to save computation, connects trees eagerly when within step-size distance, and applies iterative shortcutting on the final path to enhance smoothness while monitoring improvement to early halt the search.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size_init=5.0, k_nearest=12,\n                 no_improve_limit=60, improve_tol=1e-7, shortcut_iters=250):\n        self.max_iter = max_iter\n        self.step_size_init = step_size_init\n        self.k_nearest = k_nearest\n        self.no_improve_limit = no_improve_limit\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def dist(a, b):\n            d_sq = 0.0\n            for i in range(dim):\n                d_sq += (a[i] - b[i]) ** 2\n            return math.sqrt(d_sq)\n\n        def in_obstacle(p):\n            px = p + (0.0,) * (3 - dim) if dim < 3 else p\n            for obs in obstacles:\n                if dim == 2:\n                    ox, oy, ow, oh = obs\n                    if ox <= px[0] <= ox + ow and oy <= px[1] <= oy + oh:\n                        return True\n                else:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px[0] <= ox + ow and oy <= px[1] <= oy + oh and oz <= px[2] <= oz + od:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=0.4):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(f[j] + (t[j] - f[j]) * (i / steps) for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to, max_step):\n            d = dist(frm, to)\n            if d <= max_step:\n                return to\n            ratio = max_step / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d += diff * diff\n                    if d > best_dist * best_dist:\n                        break\n                else:\n                    d = math.sqrt(d)\n                    if d < best_dist:\n                        best = node\n                        best_dist = d\n            return best\n\n        def k_nearest_nodes(tree, point, k):\n            # find k nearest nodes by distance (linear scan sufficient for this scale)\n            dists = []\n            for n in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d += diff * diff\n                    if d > float('inf'):\n                        break\n                else:\n                    dists.append((math.sqrt(d), n))\n            dists.sort(key=lambda x: x[0])\n            return [n for _, n in dists[:k]]\n\n        def cost_to_node(node):\n            return node.cost\n\n        c_min = dist(start, goal)\n\n        def ellipsoid_sample(c_best):\n            # If no solution, sample uniformly in bounds\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-14:\n                # Degenerate case, sample uniformly\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Build orthonormal basis using Gram-Schmidt for dim-dim matrix U\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0.0] * dim\n                base[(idx + 1) % dim] = 1.0\n                for u in U:\n                    proj = sum(base[j] * u[j] for j in range(dim))\n                    base = [base[j] - proj * u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-14:\n                    base = [x / norm_base for x in base]\n                else:\n                    base = [0.0] * dim\n                U.append(base)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            # Sample in unit ball then scale and rotate\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n\n                point_scaled = [radii[i] * point_ball[i] for i in range(dim)]\n                # Rotate by U matrix transpose\n                point_rotated = [0.0] * dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i] * U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        def dynamic_step_size(iter_count, best_cost):\n            # shrink step size as better paths found (min 1.0)\n            base = self.step_size_init\n            shrink = 1.0\n            if best_cost != float('inf'):\n                shrink = max(0.3, best_cost / (c_min * 3.0))\n            # also reduce with iteration to refine\n            decay_iter_factor = max(0.2, 1.0 - iter_count / self.max_iter)\n            step = base * shrink * decay_iter_factor\n            return max(1.0, step)\n\n        def add_node(tree, sample, all_nodes, edges, best_cost, iter_count):\n            step_size = dynamic_step_size(iter_count, best_cost)\n            nn = nearest(tree, sample)\n            new_pos = steer(nn.position, sample, step_size)\n            if in_obstacle(new_pos) or edge_obstacle(nn.position, new_pos):\n                return None\n            # Find k nearest neighbors in tree for rewiring\n            near = k_nearest_nodes(tree, new_pos, self.k_nearest)\n\n            # Choose best parent among near nodes\n            best_parent = nn\n            best_cost_to_new = nn.cost + dist(nn.position, new_pos)\n            for near_node in near:\n                if near_node == nn:\n                    continue\n                cand_cost = near_node.cost + dist(near_node.position, new_pos)\n                if cand_cost + self.improve_tol < best_cost_to_new and not edge_obstacle(near_node.position, new_pos):\n                    best_parent = near_node\n                    best_cost_to_new = cand_cost\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost_to_new\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new node if beneficial\n            for near_node in near:\n                if near_node == best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost and not edge_obstacle(new_node.position, near_node.position):\n                    if near_node.parent is not None:\n                        near_node.parent.remove_child(near_node)\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                    new_node.add_child(near_node)\n                    near_node.cost = alt_cost\n                    edges.append((new_node, near_node))\n\n            return new_node\n\n        def extract_path(node_s, node_g):\n            path_s = node_s.path_from_root()\n            path_g = node_g.path_from_root()\n            # The connection node is node_s and node_g may not be same position.\n            # Attach goal tree path reversed (excluding common node if exists)\n            # To avoid double node, check equality of endpoints\n            if path_s and path_g and path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            else:\n                return path_s + path_g[::-1]\n\n        def shortcut_path(path):\n            # Iteratively shortcut path by trying to connect non-consecutive nodes directly\n            if len(path) < 3:\n                return path\n            changed = True\n            count = 0\n            while changed and count < self.shortcut_iters:\n                changed = False\n                count += 1\n                i = 0\n                while i < len(path) - 2:\n                    # Random distant j\n                    max_jump = min(len(path) - 1, i + 6)\n                    j = random.randint(i + 2, max_jump)\n                    if not edge_obstacle(path[i], path[j]):\n                        # shortcut possible\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialize trees\n        start_node = Node(start)\n        goal_node = Node(goal)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        found = False\n\n        no_improve_count = 0\n        last_best = float('inf')\n\n        for itr in range(self.max_iter):\n            # Sample using ellipsoidal informed sampling\n            sample_pt = ellipsoid_sample(best_cost)\n\n            # Alternate trees for growth\n            if itr % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            new_node = add_node(tree_a, sample_pt, all_nodes, edges, best_cost, itr)\n            if new_node is None:\n                continue\n\n            # Try to connect new node to nearest on other tree\n            near_connect = nearest(tree_b, new_node.position)\n            if near_connect is not None:\n                dist_cand = dist(near_connect.position, new_node.position)\n                step_curr = dynamic_step_size(itr, best_cost)\n                if dist_cand <= step_curr and not edge_obstacle(new_node.position, near_connect.position):\n                    # Possible connection\n                    path_candidate = extract_path(new_node, near_connect)\n                    candidate_cost = new_node.cost + dist_cand + near_connect.cost\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = path_candidate\n                        found = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    if found:\n                        no_improve_count += 1\n\n            # Prune nodes exceeding best cost + tolerance to improve efficiency\n            if found:\n                limit_cost = best_cost + self.improve_tol\n                def prune(tree):\n                    to_remove = []\n                    for node in tree:\n                        if node.cost > limit_cost:\n                            to_remove.append(node)\n                    for node in to_remove:\n                        if node.parent:\n                            node.parent.remove_child(node)\n                        try:\n                            tree.remove(node)\n                            all_nodes.remove(node)\n                        except Exception:\n                            pass\n                prune(tree_start)\n                prune(tree_goal)\n\n            # Early stopping on stagnation\n            if found:\n                if best_cost + self.improve_tol < last_best:\n                    last_best = best_cost\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                if no_improve_count >= self.no_improve_limit:\n                    break\n\n        # Post-processing shortcutting for smoothness and length improvements\n        if found and len(best_path) > 3:\n            best_path = shortcut_path(best_path)\n\n        if found:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
                "objective": 44.13367,
                "time_improvement": -94.0,
                "length_improvement": 19.0,
                "smoothness_improvement": 1116.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.056844019889831544,
                        "num_nodes_avg": 131.4,
                        "path_length_avg": 158.28767403870523,
                        "smoothness_avg": 0.04288565059179957,
                        "success_improvement": 0.0,
                        "time_improvement": -134.06629655263816,
                        "length_improvement": 13.240017630681594,
                        "smoothness_improvement": 571.2535594424835,
                        "objective_score": -29.419610590170073
                    },
                    {
                        "map_id": 1,
                        "success_rate": 0.9,
                        "time_avg": 0.0836817741394043,
                        "num_nodes_avg": 359.9,
                        "path_length_avg": 228.1134320486448,
                        "smoothness_avg": 0.07374435827108994,
                        "success_improvement": -9.999999999999998,
                        "time_improvement": 48.173512745365564,
                        "length_improvement": 23.84917050107601,
                        "smoothness_improvement": 1797.4954542294452,
                        "objective_score": -12.250966604597496
                    },
                    {
                        "map_id": 2,
                        "success_rate": 0.9,
                        "time_avg": 0.1458946704864502,
                        "num_nodes_avg": 412.3,
                        "path_length_avg": 118.5632699248331,
                        "smoothness_avg": 0.08490620066984564,
                        "success_improvement": -9.999999999999998,
                        "time_improvement": -194.6133217784839,
                        "length_improvement": 21.255921492140313,
                        "smoothness_improvement": 980.0006053966165,
                        "objective_score": -90.7304406112779
                    }
                ],
                "success_rate": 0.9333333333333332
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
                "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -23.76291481494683,
                "time_improvement": 61.0,
                "length_improvement": 8.0,
                "smoothness_improvement": 166.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.012529301643371581,
                        "num_nodes_avg": 131.9,
                        "path_length_avg": 176.77827310097746,
                        "smoothness_avg": 0.01645631271580969,
                        "success_improvement": 0.0,
                        "time_improvement": 48.408166070262766,
                        "length_improvement": 3.105027282357968,
                        "smoothness_improvement": 157.5770294574498,
                        "objective_score": 17.173351337780858
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.01886875629425049,
                        "num_nodes_avg": 256.8,
                        "path_length_avg": 267.7347696890942,
                        "smoothness_avg": 0.010597136127488454,
                        "success_improvement": 0.0,
                        "time_improvement": 88.31404606735866,
                        "length_improvement": 10.622427559723258,
                        "smoothness_improvement": 172.67194536891012,
                        "objective_score": 33.7310300828861
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.026641178131103515,
                        "num_nodes_avg": 304.4,
                        "path_length_avg": 136.29588257526552,
                        "smoothness_avg": 0.02101448639210645,
                        "success_improvement": 0.0,
                        "time_improvement": 46.20196913892299,
                        "length_improvement": 9.478764505998065,
                        "smoothness_improvement": 167.3027157795587,
                        "objective_score": 20.384363024173528
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "A bidirectional RRT* planner with adaptive radius rewiring, progressive heuristic ellipsoidal sampling focusing search on promising paths, and early termination on convergence stagnation. It uses dynamic neighbor radius scaled with the logarithm of current tree size, adaptive step size that balances exploration and refinement, and incremental cost-based rewiring with bidirectional tree connection attempts. Path shortcutting is performed iteratively post solution to shorten and smooth the path efficiently.",
            "planning_mechanism": "The planner grows two trees from start and goal nodes alternately, samples new points focusing inside an informed ellipsoid shaped by current best solution cost to guide exploration. New nodes are connected using parent selection minimizing path cost within a dynamically computed neighbor radius that adapts as the tree grows. Rewiring adjusts tree topology to reduce costs. When the two trees connect within step distance, the combined path is saved if better. Early termination triggers if no cost improvement occurs over a configurable window, reducing runtime. Post processing shortcuts the path to remove unnecessary waypoints and improves path smoothness.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, neighbor_factor=2.0, no_improve_limit=60, improve_tol=1e-7, shortcut_iters=250):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor\n        self.no_improve_limit = no_improve_limit\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def dist(a,b):\n            return math.sqrt(sum((a[i]-b[i])**2 for i in range(dim)))\n\n        def in_obstacle(p):\n            px = p + (0.0,)*(3-dim) if dim<3 else p\n            for obs in obstacles:\n                if dim == 2:\n                    x,y,w,h = obs\n                    if x <= px[0] <= x+w and y <= px[1] <= y+h:\n                        return True\n                else:\n                    x,y,z,w,h,d = obs\n                    if x <= px[0] <= x+w and y <= px[1] <= y+h and z <= px[2] <= z+d:\n                        return True\n            return False\n\n        def edge_obstacle(f,t,resolution=0.4):\n            length = dist(f,t)\n            if length < 1e-12:\n                return False\n            steps = max(2,int(length/resolution))\n            for i in range(steps+1):\n                interp = tuple(f[j] + (t[j]-f[j])*(i/steps) for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm,to,max_step):\n            d = dist(frm,to)\n            if d <= max_step:\n                return to\n            ratio = max_step/d\n            return tuple(frm[i]+(to[i]-frm[i])*ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d += diff*diff\n                    if d > best_dist*best_dist:\n                        break\n                else:\n                    d = math.sqrt(d)\n                    if d < best_dist:\n                        best = node\n                        best_dist = d\n            return best\n\n        def neighbor_radius(tree_len):\n            # Adaptive neighbor radius based on tree size, theoretical RRT* scaling\n            if tree_len < 2:\n                return self.step_size * 2.0\n            return min(self.step_size*5.0, self.neighbor_factor * (math.log(tree_len)/tree_len)**(1.0/dim)*max(bounds))\n\n        def neighbors(tree, point, radius):\n            neigh = []\n            r_sq = radius*radius\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d_sq += diff*diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    neigh.append(node)\n            return neigh\n\n        c_min = dist(start, goal)\n\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            center = tuple((start[i]+goal[i])*0.5 for i in range(dim))\n            a1 = [goal[i]-start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            # Orthonormal basis U via Gram-Schmidt (dim x dim)\n            U = [unit_a1]\n            for idx in range(dim-1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j]-proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    base = [x/norm_base for x in base]\n                else:\n                    base = [0.0]*dim\n                U.append(base)\n\n            r1 = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val>0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x/norm_ball for x in x_ball]\n                u_rand = random.random()**(1.0/dim)\n                point_ball = [coord*u_rand for coord in unit_ball]\n\n                point_scaled = [radii[i]*point_ball[i] for i in range(dim)]\n\n                # Rotate by U matrix transpose\n                point_rot = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rot[j] += point_scaled[i]*U[i][j]\n\n                sample = tuple(center[i]+point_rot[i] for i in range(dim))\n                if all(0.0<=sample[i]<=bounds[i] for i in range(dim)):\n                    return sample\n\n        def add_node(tree, sample, all_nodes, edges, best_cost):\n            nn = nearest(tree, sample)\n            new_pos = steer(nn.position, sample, self.step_size)\n            if in_obstacle(new_pos) or edge_obstacle(nn.position,new_pos):\n                return None\n            radius = neighbor_radius(len(tree))\n            near = neighbors(tree, new_pos, radius)\n            best_parent = nn\n            min_cost = nn.cost + dist(nn.position,new_pos)\n            for candidate in near:\n                cand_cost = candidate.cost + dist(candidate.position,new_pos)\n                if cand_cost + self.improve_tol < min_cost and not edge_obstacle(candidate.position,new_pos):\n                    best_parent = candidate\n                    min_cost = cand_cost\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent,new_node))\n\n            # Rewire neighbors through new node if beneficial\n            for neighbor in near:\n                if neighbor is best_parent: \n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost + self.improve_tol < neighbor.cost and not edge_obstacle(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        neighbor.parent.remove_child(neighbor)\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n                    new_node.add_child(neighbor)\n                    neighbor.cost = alt_cost\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def extract_path(node_s, node_g):\n            path_s = node_s.path_from_root()\n            path_g = node_g.path_from_root()\n            # Avoid duplicate duplicate connecting node\n            if path_s and path_g and path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            else:\n                return path_s + path_g[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            count = 0\n            changed = True\n            while changed and count < self.shortcut_iters:\n                changed = False\n                count += 1\n                i = 0\n                while i < len(path)-2:\n                    max_jump = min(len(path)-1, i+6)\n                    j = random.randint(i+2, max_jump)\n                    if not edge_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        start_node = Node(start)\n        goal_node = Node(goal)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        found = False\n        no_improve_count = 0\n        last_best = best_cost\n\n        for itr in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost)\n\n            if itr % 2 == 0:\n                main_tree, other_tree = tree_start, tree_goal\n            else:\n                main_tree, other_tree = tree_goal, tree_start\n\n            new_node = add_node(main_tree, sample_pt, all_nodes, edges, best_cost)\n            if new_node is None:\n                continue\n\n            near_connect = nearest(other_tree, new_node.position)\n            step_dist = dist(near_connect.position, new_node.position)\n            if step_dist <= self.step_size and not edge_obstacle(new_node.position, near_connect.position):\n                candidate_cost = new_node.cost + near_connect.cost + step_dist\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = extract_path(new_node, near_connect)\n                    found = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            else:\n                if found:\n                    no_improve_count += 1\n\n            if found:\n                # Early stopping on stagnation of improvement\n                if best_cost + self.improve_tol < last_best:\n                    last_best = best_cost\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                if no_improve_count >= self.no_improve_limit:\n                    break\n\n        if found and len(best_path) > 3:\n            best_path = shortcut_path(best_path)\n\n        if found:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
            "objective": 6.30946,
            "time_improvement": -81.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1172.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.08813977241516113,
                    "num_nodes_avg": 171.3,
                    "path_length_avg": 155.94724987804915,
                    "smoothness_avg": 0.037895327969512546,
                    "success_improvement": 0.0,
                    "time_improvement": -262.9326382650782,
                    "length_improvement": 14.522841199531285,
                    "smoothness_improvement": 493.1441737446706,
                    "objective_score": -67.70036589108133
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08728914260864258,
                    "num_nodes_avg": 314.3,
                    "path_length_avg": 226.58476458100463,
                    "smoothness_avg": 0.07942344506505501,
                    "success_improvement": 0.0,
                    "time_improvement": 45.93936752179157,
                    "length_improvement": 24.35948370202769,
                    "smoothness_improvement": 1943.6224479190457,
                    "objective_score": 38.11561271734931
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.061713361740112306,
                    "num_nodes_avg": 259.4,
                    "path_length_avg": 118.83941821204158,
                    "smoothness_avg": 0.09275591661871693,
                    "success_improvement": 0.0,
                    "time_improvement": -24.621265737464196,
                    "length_improvement": 21.072516948544795,
                    "smoothness_improvement": 1079.8484128604985,
                    "objective_score": 10.65637251219011
                }
            ],
            "success_rate": 1.0
        },
        "objective": 11.6,
        "analysis": {
            "problem": [
                ""
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Adoption of an adaptive neighbor radius that scales with the growth of the search tree, enabling more efficient and targeted rewiring.\n   - Implementation of heuristic-informed sampling inside an ellipsoid focused on the promising region between start and goal points.\n   - Incorporation of early stopping criteria upon detection of stagnation in cost improvement to reduce unnecessary computation.\n   - Enhanced rewiring strategies with dynamic neighbor radius improving path cost optimizations.\n   - More extensive and iterative path shortcutting post-processing significantly improving path smoothness and length.\n\n2. Expected mechanism of impact:\n   - Adaptive neighbor radius reduces the number of redundant neighbor checks and rewiring operations, improving computational efficiency and enabling faster convergence.\n   - Focused ellipsoidal sampling concentrates effort in relevant space, reducing random exploration and accelerating finding high-quality paths.\n   - Early termination prevents wasted iterations and lowers planning time once an adequate solution is found.\n   - Improved rewiring increases chances of finding and maintaining lower-cost connections, resulting in shorter paths.\n   - Iterative shortcutting removes unnecessary waypoints and smooths trajectories, enhancing path smoothness and reducing length."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "A simplified and efficient bidirectional RRT* planner with adaptive rewiring radius and focused ellipsoidal sampling that balances exploration and exploitation. It uses efficient nearest node and neighbor searches with a radius increasing moderately with tree size, performs rewiring to optimize paths, and connects both trees early. Early stopping triggers on cost stagnation. Post-processing shortcutting smooths and shortens the final path.",
                "planning_mechanism": "The planner grows two trees from start and goal nodes in alternation, sampling mostly inside an informed ellipsoid once an initial solution is found, steering towards samples within step size. New nodes pick parents minimizing total cost inside a radius adaptive to tree size and problem scale. Rewiring adjusts neighbors to improve costs. When the two trees connect within an edge free of obstacles, the combined path is updated if better. Iterations stop on stagnation of improvement or max iteration/time. Final path undergoes shortcutting for smoothness and length improvement.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, neighbor_multiplier=2.5, no_improve_stop=50, improve_tol=1e-6, shortcut_iters=200, time_limit=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_multiplier = neighbor_multiplier\n        self.no_improve_stop = no_improve_stop\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def dist(a,b):\n            return math.sqrt(sum((a[i]-b[i])**2 for i in range(dim)))\n\n        def in_obstacle(p):\n            px = p + (0.0,)*(3 - dim) if dim < 3 else p\n            for obs in obstacles:\n                if dim == 2:\n                    x,y,w,h = obs\n                    if x <= px[0] <= x+w and y <= px[1] <= y+h:\n                        return True\n                else:\n                    x,y,z,w,h,d = obs\n                    if x <= px[0] <= x+w and y <= px[1] <= y+h and z <= px[2] <= z+d:\n                        return True\n            return False\n\n        def edge_obstacle(p1, p2, resolution=0.4):\n            length = dist(p1,p2)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[j] + (p2[j]-p1[j])*(i/steps) for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to, max_step):\n            d = dist(frm,to)\n            if d <= max_step:\n                return to\n            ratio = max_step/d\n            return tuple(frm[i] + (to[i]-frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_d = float('inf')\n            for node in tree:\n                dd = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    dd += diff*diff\n                    if dd > best_d*best_d:\n                        break\n                else:\n                    d = math.sqrt(dd)\n                    if d < best_d:\n                        best = node\n                        best_d = d\n            return best\n\n        def neighbor_radius(tree_len):\n            if tree_len < 2:\n                return self.step_size * 3.0\n            val = (math.log(tree_len)/tree_len)**(1.0/dim)\n            return min(self.step_size*8.0, self.neighbor_multiplier * val * max(bounds))\n\n        def neighbors(tree, point, radius):\n            r_sq = radius*radius\n            result = []\n            for node in tree:\n                dd = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    dd += diff*diff\n                    if dd > r_sq:\n                        break\n                else:\n                    result.append(node)\n            return result\n\n        c_min = dist(start, goal)\n\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i]-start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            U = [unit_a1]\n            for idx in range(dim-1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j]-proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    base = [x/norm_base for x in base]\n                else:\n                    base = [0.0]*dim\n                U.append(base)\n\n            r1 = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r_rest = math.sqrt(val)*0.5 if val > 0 else 0.0\n            radii = [r1] + [r_rest]*(dim-1)\n\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x/norm_ball for x in x_ball]\n                u_rand = random.random()**(1.0/dim)\n                point_ball = [coord*u_rand for coord in unit_ball]\n\n                point_scaled = [radii[i]*point_ball[i] for i in range(dim)]\n\n                point_rot = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rot[j] += point_scaled[i]*U[i][j]\n\n                sample = tuple(center[i] + point_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        def add_node(tree, sample, all_nodes, edges, c_best):\n            nn = nearest(tree, sample)\n            new_pos = steer(nn.position, sample, self.step_size)\n            if in_obstacle(new_pos) or edge_obstacle(nn.position, new_pos):\n                return None\n            radius = neighbor_radius(len(tree))\n            near = neighbors(tree, new_pos, radius)\n\n            best_parent = nn\n            min_cost = nn.cost + dist(nn.position, new_pos)\n            for cand in near:\n                cand_cost = cand.cost + dist(cand.position, new_pos)\n                if cand_cost + self.improve_tol < min_cost and not edge_obstacle(cand.position, new_pos):\n                    best_parent = cand\n                    min_cost = cand_cost\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost + self.improve_tol < neighbor.cost and not edge_obstacle(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        neighbor.parent.remove_child(neighbor)\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n                    new_node.add_child(neighbor)\n                    neighbor.cost = alt_cost\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def extract_path(node_s, node_g):\n            path_s = node_s.path_from_root()\n            path_g = node_g.path_from_root()\n            if path_s and path_g and path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            return path_s + path_g[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            changed = True\n            count = 0\n            while changed and count < self.shortcut_iters:\n                changed = False\n                count += 1\n                i = 0\n                while i < len(path)-2:\n                    max_jump = min(len(path)-1, i+6)\n                    j = random.randint(i+2, max_jump)\n                    if not edge_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        start_node = Node(start)\n        goal_node = Node(goal)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        found = False\n        no_improve_count = 0\n        last_cost = best_cost\n        t_start = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - t_start > self.time_limit:\n                break\n            sample_pt = informed_sample(best_cost)\n            main_tree, other_tree = (tree_start, tree_goal) if (it % 2 == 0) else (tree_goal, tree_start)\n\n            new_node = add_node(main_tree, sample_pt, all_nodes, edges, best_cost)\n            if new_node is None:\n                if found:\n                    no_improve_count += 1\n                continue\n\n            near_other = nearest(other_tree, new_node.position)\n            d_connect = dist(new_node.position, near_other.position)\n            if d_connect <= self.step_size and not edge_obstacle(new_node.position, near_other.position):\n                candidate_cost = new_node.cost + near_other.cost + d_connect\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = extract_path(new_node, near_other)\n                    found = True\n                    no_improve_count = 0\n                else:\n                    if found:\n                        no_improve_count += 1\n            else:\n                if found:\n                    no_improve_count += 1\n\n            if found:\n                if best_cost + self.improve_tol < last_cost:\n                    last_cost = best_cost\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                if no_improve_count >= self.no_improve_stop:\n                    break\n\n        if found and len(best_path) > 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(found, best_path, all_nodes, edges)",
                "objective": 112.263,
                "time_improvement": -374.0,
                "length_improvement": 19.0,
                "smoothness_improvement": 1092.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.14681096076965333,
                        "num_nodes_avg": 146.4,
                        "path_length_avg": 161.61468378381954,
                        "smoothness_avg": 0.04584694745004782,
                        "success_improvement": 0.0,
                        "time_improvement": -504.52265598539185,
                        "length_improvement": 11.416430869541331,
                        "smoothness_improvement": 617.6042858331209,
                        "objective_score": -141.41891684472716
                    },
                    {
                        "map_id": 1,
                        "success_rate": 0.9,
                        "time_avg": 0.15154016017913818,
                        "num_nodes_avg": 313.5,
                        "path_length_avg": 228.31025368589385,
                        "smoothness_avg": 0.06567437201306224,
                        "success_improvement": -9.999999999999998,
                        "time_improvement": 6.14689684989422,
                        "length_improvement": 23.78346577336556,
                        "smoothness_improvement": 1589.8488952342373,
                        "objective_score": -25.936607004841207
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.3584346055984497,
                        "num_nodes_avg": 373.7,
                        "path_length_avg": 119.52410280963332,
                        "smoothness_avg": 0.0917931816840071,
                        "success_improvement": 0.0,
                        "time_improvement": -623.8071784502058,
                        "length_improvement": 20.617782040001302,
                        "smoothness_improvement": 1067.6024955526905,
                        "objective_score": -169.43347183329752
                    }
                ],
                "success_rate": 0.9666666666666667
            },
            {
                "operator": "initial",
                "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
                "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
                "objective": -18.199350067879823,
                "time_improvement": 67.0,
                "length_improvement": -4.0,
                "smoothness_improvement": 78.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.009241986274719238,
                        "num_nodes_avg": 98.6,
                        "path_length_avg": 188.60059541559173,
                        "smoothness_avg": 0.011107369580525531,
                        "success_improvement": 0.0,
                        "time_improvement": 61.94432581815326,
                        "length_improvement": -3.3749749149674124,
                        "smoothness_improvement": 73.85445397432328,
                        "objective_score": 16.927585066337148
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.013762164115905761,
                        "num_nodes_avg": 215.1,
                        "path_length_avg": 298.4716236591105,
                        "smoothness_avg": 0.007330142954732018,
                        "success_improvement": 0.0,
                        "time_improvement": 91.47670289636794,
                        "length_improvement": 0.3615809932444448,
                        "smoothness_improvement": 88.6098579138185,
                        "objective_score": 28.103008754426142
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.02535843849182129,
                        "num_nodes_avg": 323.5,
                        "path_length_avg": 164.19293370544943,
                        "smoothness_avg": 0.013510302519313377,
                        "success_improvement": 0.0,
                        "time_improvement": 48.79227750896705,
                        "length_improvement": -9.049128539847096,
                        "smoothness_improvement": 71.85005081886685,
                        "objective_score": 9.567456382876191
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "A refined bidirectional RRT* inspired planner with consistent adaptive neighbor radius scaling, prioritized rewiring, and iterative shortcutting for improved path length, smoothness, and efficiency. The planner balances exploration and exploitation by incrementally searching with a well-defined neighbor radius proportional to tree size and dimensionality, performs rewiring for cost minimization, and uses early stopping on cost stagnation. The final path undergoes aggressive shortcutting for length and smoothness improvements.",
            "planning_mechanism": "The algorithm alternates growing two trees from start and goal nodes, samples adaptively inside an informed ellipsoid once a solution exists, extends by steering towards samples within a fixed step size, and performs rewiring of neighbors inside a radius defined by a consistent formula to optimize path costs. Trees attempt connection at every iteration, updating best solution and stopping early when improvements stagnate. A shortcutting routine improves final path length and smoothness.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, neighbor_const=2.4, no_improve_stop=60,\n                 improve_tol=1e-6, shortcut_iters=300, shortcut_max_jump=7, time_limit=18.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_const = neighbor_const\n        self.no_improve_stop = no_improve_stop\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n        self.shortcut_max_jump = shortcut_max_jump\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.sqrt(sum((a[i] - b[i]) ** 2 for i in range(dim)))\n\n        def in_obstacle(p):\n            px = p + (0.0,) * (3 - dim) if dim < 3 else p\n            for obs in obstacles:\n                if dim == 2:\n                    x, y, w, h = obs\n                    if x <= px[0] <= x + w and y <= px[1] <= y + h:\n                        return True\n                else:\n                    x, y, z, w, h, d = obs\n                    if x <= px[0] <= x + w and y <= px[1] <= y + h and z <= px[2] <= z + d:\n                        return True\n            return False\n\n        def edge_obstacle(p1, p2, resolution=0.4):\n            length = dist(p1, p2)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to, max_step):\n            d = dist(frm, to)\n            if d <= max_step:\n                return to\n            ratio = max_step / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_d_sq = float('inf')\n            for node in tree:\n                dd = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    dd += diff * diff\n                    if dd > best_d_sq:\n                        break\n                else:\n                    if dd < best_d_sq:\n                        best = node\n                        best_d_sq = dd\n            return best\n\n        def neighbors(tree, point, radius):\n            r_sq = radius * radius\n            result = []\n            for node in tree:\n                dd = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    dd += diff * diff\n                    if dd > r_sq:\n                        break\n                else:\n                    result.append(node)\n            return result\n\n        def neighbor_radius(tree_len):\n            if tree_len < 2:\n                return self.step_size * 3.0\n            # Consistent radius scaling based on RRT* theory:\n            val = (math.log(tree_len) / tree_len) ** (1.0 / dim)\n            radius = min(self.neighbor_const * val * max(bounds), self.step_size * 7.5)\n            return max(radius, self.step_size * 2.0)\n\n        c_min = dist(start, goal)\n\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Construct an orthonormal basis:\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0.0] * dim\n                base[(idx + 1) % dim] = 1.0\n                for u in U:\n                    proj = sum(base[j] * u[j] for j in range(dim))\n                    base = [base[j] - proj * u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-14:\n                    base = [x / norm_base for x in base]\n                else:\n                    base = [0.0] * dim\n                U.append(base)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r_rest = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r_rest] * (dim - 1)\n\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u_rand = random.random() ** (1.0 / dim)\n                point_ball = [coord * u_rand for coord in unit_ball]\n\n                point_scaled = [radii[i] * point_ball[i] for i in range(dim)]\n\n                point_rot = [0.0] * dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rot[j] += point_scaled[i] * U[i][j]\n\n                sample = tuple(center[i] + point_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        def add_node(tree, sample, all_nodes, edges, c_best):\n            nn = nearest(tree, sample)\n            new_pos = steer(nn.position, sample, self.step_size)\n            if in_obstacle(new_pos) or edge_obstacle(nn.position, new_pos):\n                return None\n            radius = neighbor_radius(len(tree))\n            near = neighbors(tree, new_pos, radius)\n\n            best_parent = nn\n            min_cost = nn.cost + dist(nn.position, new_pos)\n            for cand in near:\n                cand_cost = cand.cost + dist(cand.position, new_pos)\n                if cand_cost + self.improve_tol < min_cost and not edge_obstacle(cand.position, new_pos):\n                    best_parent = cand\n                    min_cost = cand_cost\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for potential improvements\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost + self.improve_tol < neighbor.cost and not edge_obstacle(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        neighbor.parent.remove_child(neighbor)\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    new_node.add_child(neighbor)\n                    neighbor.cost = alt_cost\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def extract_path(node_s, node_g):\n            path_s = node_s.path_from_root()\n            path_g = node_g.path_from_root()\n            if path_s and path_g and path_s[-1] == path_g[-1]:\n                # Overlapping connection node, so skip duplicate last\n                return path_s + path_g[-2::-1]\n            return path_s + path_g[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            count = 0\n            changed = True\n            while changed and count < self.shortcut_iters:\n                changed = False\n                count += 1\n                i = 0\n                while i < len(path) - 2:\n                    max_jump_idx = min(len(path) - 1, i + self.shortcut_max_jump)\n                    j = random.randint(i + 2, max_jump_idx)\n                    if not edge_obstacle(path[i], path[j]):\n                        # Remove intermediate points between i and j\n                        path = path[:i + 1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        start_node = Node(start)\n        goal_node = Node(goal)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        found = False\n        no_improve_count = 0\n        last_cost = best_cost\n        t_start = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - t_start > self.time_limit:\n                break\n            sample_pt = informed_sample(best_cost)\n            main_tree, other_tree = (tree_start, tree_goal) if (it % 2 == 0) else (tree_goal, tree_start)\n\n            new_node = add_node(main_tree, sample_pt, all_nodes, edges, best_cost)\n            if new_node is None:\n                if found:\n                    no_improve_count += 1\n                continue\n\n            near_other = nearest(other_tree, new_node.position)\n            d_connect = dist(new_node.position, near_other.position)\n            if d_connect <= self.step_size and not edge_obstacle(new_node.position, near_other.position):\n                candidate_cost = new_node.cost + near_other.cost + d_connect\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = extract_path(new_node, near_other)\n                    found = True\n                    no_improve_count = 0\n                else:\n                    if found:\n                        no_improve_count += 1\n            else:\n                if found:\n                    no_improve_count += 1\n\n            if found:\n                if best_cost + self.improve_tol < last_cost:\n                    last_cost = best_cost\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                if no_improve_count >= self.no_improve_stop:\n                    break\n\n        if found and len(best_path) > 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(found, best_path, all_nodes, edges)",
            "objective": 39.15867,
            "time_improvement": -188.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1088.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.11048943996429443,
                    "num_nodes_avg": 134.5,
                    "path_length_avg": 157.18071287891655,
                    "smoothness_avg": 0.04972884232498757,
                    "success_improvement": 0.0,
                    "time_improvement": -354.96173688524993,
                    "length_improvement": 13.846760583283842,
                    "smoothness_improvement": 678.3643702955704,
                    "objective_score": -94.78864286412681
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.10013914108276367,
                    "num_nodes_avg": 271.3,
                    "path_length_avg": 229.07299233276945,
                    "smoothness_avg": 0.06740144740588477,
                    "success_improvement": 0.0,
                    "time_improvement": 37.981000374464145,
                    "length_improvement": 23.528841658823822,
                    "smoothness_improvement": 1634.2877890536852,
                    "objective_score": 33.68304405290196
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.17249653339385987,
                    "num_nodes_avg": 312.2,
                    "path_length_avg": 117.01505065920387,
                    "smoothness_avg": 0.08268411140396412,
                    "success_improvement": 0.0,
                    "time_improvement": -248.331961194964,
                    "length_improvement": 22.2841750100922,
                    "smoothness_improvement": 951.735793952172,
                    "objective_score": -56.37040438267303
                }
            ],
            "success_rate": 1.0
        },
        "objective": 11.6,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient nearest neighbor search without spatial indexing causing slower planning times.\n   - Overly conservative or inconsistent neighbor radius scaling leading to suboptimal rewiring and longer paths.\n   - Basic or absent edge rewiring mechanisms resulting in less optimal path cost improvement.\n   - Limited or simplistic path shortcutting and smoothing algorithms, insufficient to significantly improve path smoothness.\n   - Redundant or suboptimal connection strategies without early stopping mechanisms causing excessive computation.\n   - Lack of adaptive sampling within an informed subset after finding preliminary solutions, resulting in wasted exploration."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Introduction of consistent and theoretically grounded neighbor radius scaling for more effective rewiring.\n   - Enhanced rewiring logic that iteratively improves node parentage and path costs.\n   - More aggressive and parameterized shortcutting routine that better smooths and shortens paths.\n   - Use of informed sampling to focus exploration within regions likely to improve the best path found.\n   - Integration of early stopping criteria based on stagnation detection to reduce unnecessary computation.\n\n2. Expected mechanism of impact:\n   - Consistent neighbor radius and improved rewiring enable the planner to minimize path length more effectively by dynamically reconnecting nodes in a cost-efficient manner.\n   - Informed sampling reduces the search space after an initial solution is found, leading to faster convergence on better-quality paths, thus reducing planning time in practical terms.\n   - Enhanced shortcutting removes redundant waypoints and smooths abrupt turns, substantially boosting path smoothness.\n   - Early stopping prevents wasted iterations after path improvements stagnate, optimizing computational resource usage.\n   - These combined improvements strategically balance exploration and exploitation, facilitating improved path length and smoothness without excessive time penalty."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "An improved bidirectional RRT* variant with simplified adaptive neighborhood radius, consistent incremental rewiring, and combined informed plus uniform sampling for balanced exploration. The planner applies strict collision checks on nodes and edges, optimizes parent selection to minimize path cost, and attempts connection between trees after each insertion. It leverages a unified rewiring radius calculation based on node density and iteration progress, integrates early stopping on improvement stagnation, and performs lightweight post-processing shortcutting to improve path quality and smoothness, achieving efficient planning, shorter path length, and smoother results while maintaining robustness and simplicity.",
                "planning_mechanism": "The planner grows two trees from start and goal positions in alternating iterations, sampling points biased towards an ellipsoidal informed subset once a solution is found to focus search. Nodes are added by steering towards samples within step size, selecting parents from neighbors that reduce path cost and maintain collision-free edges. Rewiring is done on neighbors with a unified adaptive radius that shrinks according to node count and iteration to refine local connectivity. After each added node, the planner attempts to connect the two trees to find feasible paths that are combined to update the best solution. Early stopping terminates planning after a number of iterations without improvement. A final random shortcutting pass reduces unnecessary detours for improved smoothness.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 max_radius=25.0,\n                 min_radius=5.0,\n                 max_no_improve=60,\n                 shortcut_iter=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / res))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_frm_to = math.dist(frm, to)\n            if dist_frm_to <= self.step_size:\n                return to\n            ratio = self.step_size / dist_frm_to\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(node_count, iteration):\n            # Unified radius shrinking with node count and iteration progress\n            if node_count <= 1:\n                return self.max_radius\n            import math\n            gamma = self.max_radius\n            r = gamma * (math.log(node_count) / node_count) ** (1 / dim)\n            decay = max(self.min_radius / gamma, 1.0 - 0.95 * (iteration / self.max_iter))\n            return max(self.min_radius, min(r * decay, self.max_radius))\n\n        def neighbors(tree, point, radius):\n            radius_sq = radius * radius\n            res = []\n            px = point\n            for node in tree:\n                d_sq = 0.0\n                for i_ in range(dim):\n                    diff = node.position[i_] - px[i_]\n                    d_sq += diff * diff\n                    if d_sq > radius_sq:\n                        break\n                else:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, new_pos, iter_i):\n            n_nodes = len(tree)\n            r = adaptive_radius(n_nodes, iter_i)\n            nbrs = neighbors(tree, new_pos, r)\n            # filter valid parents with collision-free edge\n            valid_parents = []\n            for n in nbrs:\n                if edge_in_obstacle(n.position, new_pos):\n                    continue\n                valid_parents.append(n)\n            if not valid_parents:\n                # fallback: find nearest node with collision-free edge\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                best_parent = nearest\n                cost = best_parent.cost + nearest_dist\n                new_node = Node(new_pos, parent=best_parent, cost=cost)\n                best_parent.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            # select parent minimizing cost\n            best_parent = None\n            min_cost = float('inf')\n            for p in valid_parents:\n                c = p.cost + math.dist(p.position, new_pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = p\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    # Rewire parent-child\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree_from, node_to_connect):\n            if not tree_from:\n                return None\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, node_to_connect.position))\n            dist_near = math.dist(nearest.position, node_to_connect.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                    return None\n                new_node = Node(node_to_connect.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_from.append(new_node)\n                return new_node\n            # incremental steering towards target\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, node_to_connect.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_from.append(new_node)\n                current = new_node\n                if math.dist(current.position, node_to_connect.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, node_to_connect.position) or in_obstacle(node_to_connect.position):\n                        return None\n                    final_node = Node(node_to_connect.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, node_to_connect.position))\n                    current.add_child(final_node)\n                    tree_from.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = c_best * 0.5\n            val = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1] * v[2] - u[2] * v[1], u[2] * v[0] - u[0] * v[2], u[0] * v[1] - u[1] * v[0])\n\n                def norm(v):\n                    return math.sqrt(sum(x * x for x in v))\n\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v * v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v / nrm for v in vec]\n                    r = random.random() ** (1 / dim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                # Occasionally sample uniform to avoid local minima\n                if random.random() < 0.15:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_n = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_n.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_n.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos, iter_i)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node is not None:\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
                "objective": -32.09066,
                "time_improvement": 51.0,
                "length_improvement": 17.0,
                "smoothness_improvement": 1354.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.017293906211853026,
                        "num_nodes_avg": 91.5,
                        "path_length_avg": 161.730924310866,
                        "smoothness_avg": 0.042930783900201136,
                        "success_improvement": 0.0,
                        "time_improvement": 28.788981008339842,
                        "length_improvement": 11.352717594718152,
                        "smoothness_improvement": 571.9599937275159,
                        "objective_score": 18.308124827970424
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03642895221710205,
                        "num_nodes_avg": 225.4,
                        "path_length_avg": 238.2939143004422,
                        "smoothness_avg": 0.0897730230727014,
                        "success_improvement": 0.0,
                        "time_improvement": 77.4385205476863,
                        "length_improvement": 20.450632496491846,
                        "smoothness_improvement": 2209.924544555513,
                        "objective_score": 46.551558384978556
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.02602849006652832,
                        "num_nodes_avg": 208.0,
                        "path_length_avg": 123.50286586657371,
                        "smoothness_avg": 0.10841836272819716,
                        "success_improvement": 0.0,
                        "time_improvement": 47.439204641197854,
                        "length_improvement": 17.97527706591856,
                        "smoothness_improvement": 1279.073571291572,
                        "objective_score": 31.41229548836835
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m3",
            "algorithm_description": "A streamlined bidirectional RRT* planner that employs a fixed-radius neighbor search combined with uniform and informed sampling, early termination on improvement stagnation, and post-planning progressive shortcutting for efficient and smooth path finding. It performs consistent collision checks for nodes and edges, incrementally rewires locally to reduce path cost, and attempts to connect the two trees after each insertion to find feasible paths more quickly. The fixed radius provides stable local connectivity without complex adaptive decay, improving runtime and path quality balance.",
            "planning_mechanism": "The planner grows two trees from start and goal positions alternately by sampling points within the map bounds, switching to informed sampling after a solution is found. New nodes are added by steering towards samples with collision avoidance. Parent selection minimizes cost within a fixed-radius neighborhood, and rewiring locally reduces path costs further. After each insertion, it tries to connect the opposite tree to form a path. It terminates early if improvements stagnate for a set number of iterations. Finally, a randomized shortcutting pass smooths the best found path before returning it.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=5.0,\n                 neighbor_radius=20.0,\n                 max_no_improve=60,\n                 shortcut_iter=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size / dist\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        def neighbors(tree, point, radius):\n            rad_sq = radius * radius\n            res = []\n            for node in tree:\n                d_sq = 0.0\n                for i_ in range(dim):\n                    diff = node.position[i_] - point[i_]\n                    d_sq += diff * diff\n                    if d_sq > rad_sq:\n                        break\n                else:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, new_pos):\n            nbrs = neighbors(tree, new_pos, self.neighbor_radius)\n            valid_parents = [n for n in nbrs if not edge_in_obstacle(n.position, new_pos)]\n            if not valid_parents:\n                # fallback: nearest with collision-free edge\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                cost = nearest.cost + nearest_dist\n                new_node = Node(new_pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda p: p.cost + math.dist(p.position, new_pos))\n            cost_min = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=cost_min)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, neighbors_):\n            for nb in neighbors_:\n                if nb == pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree_from, target_node):\n            if not tree_from:\n                return None\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, target_node.position))\n            dist_near = math.dist(nearest.position, target_node.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_from.append(new_node)\n                return new_node\n            # incremental steering\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_from.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree_from.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = c_best * 0.5\n            val = max(c_best*c_best - c_min*c_min, 0.0)\n            r_other = math.sqrt(val)*0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(d):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(d)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random() ** (1/d)\n                    return [v*r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                # small chance to sample uniform for exploration\n                if random.random() < 0.15:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_n = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_n.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_n.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node:\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path)-1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i+1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
            "objective": 3.22489,
            "time_improvement": -72.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1323.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.06798641681671143,
                    "num_nodes_avg": 123.4,
                    "path_length_avg": 158.25975576767524,
                    "smoothness_avg": 0.041266763987781445,
                    "success_improvement": 0.0,
                    "time_improvement": -179.94728083997234,
                    "length_improvement": 13.255320077426443,
                    "smoothness_improvement": 545.9144686210723,
                    "objective_score": -43.30141986243047
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.08122842311859131,
                    "num_nodes_avg": 252.4,
                    "path_length_avg": 226.73791300031098,
                    "smoothness_avg": 0.090667552008909,
                    "success_improvement": 0.0,
                    "time_improvement": 49.69294235496602,
                    "length_improvement": 24.308358351530394,
                    "smoothness_improvement": 2232.9414183872846,
                    "objective_score": 40.65760480934446
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09193034172058105,
                    "num_nodes_avg": 257.6,
                    "path_length_avg": 118.69005639372278,
                    "smoothness_avg": 0.10154385768895954,
                    "success_improvement": 0.0,
                    "time_improvement": -85.64011458559013,
                    "length_improvement": 21.171715956426652,
                    "smoothness_improvement": 1191.6303746156489,
                    "objective_score": -7.0308529287428
                }
            ],
            "success_rate": 1.0
        },
        "objective": 10.8,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Use of complex adaptive neighborhood radius that shrinks aggressively, limiting effective rewiring and leading to suboptimal parent choices.\n   - Reliance on fallback nearest nodes without radius constraints, causing inefficient and longer connections.\n   - Expensive and repeated collision checking, especially during neighbor search and rewiring, increasing planning time.\n   - Heavy use of ellipsoid-guided sampling without consistent fallback, sometimes resulting in wasted iterations.\n   - Lack of early termination criteria based on stagnation, prolonging computation unnecessarily.\n   - Late-stage smoothing with limited iteration shortcutting, missing opportunities for incremental path refinement."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Simplified and fixed-radius neighbor search providing stable local rewiring opportunities.\n   - Consistent and strict parent selection minimizing cost within neighborhood, enhancing path length efficiency.\n   - Early stopping after no improvement detected over a finite window, reducing excess iterations.\n   - Balanced sampling strategy with occasional uniform sampling to avoid local minima.\n   - Incremental rewiring with collision checks, ensuring better tree connectivity and path shortening.\n   - Increased shortcutting iterations for better final path smoothing.\n\n2. Expected mechanism of impact:\n   - Stable neighborhood radius improves local graph connectivity and enables more effective rewiring that shortens paths.\n   - Cost-based parent selection ensures new nodes attach to minimal cost ancestors, reducing total path length.\n   - Early termination reduces planning time spent in stagnant states, improving overall efficiency.\n   - Combining informed and uniform sampling aids exploration and exploitation balance, leading to faster convergence.\n   - Enhanced rewiring leads to stepwise improvement in the tree structure, producing shorter and more optimized paths.\n   - More extensive shortcutting after planning removes redundant loops and zigzags, smoothing and shortening the final path."
        }
    },
    {
        "parents": [
            {
                "operator": "initial",
                "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
                "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
                "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if (not self._is_in_obstacle(new_pos, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(next_node.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=next_node)\n                        next_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((next_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n",
                "objective": -25.227923962981944,
                "time_improvement": 87.0,
                "length_improvement": -2.0,
                "smoothness_improvement": 63.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.004349446296691895,
                        "num_nodes_avg": 77.1,
                        "path_length_avg": 181.3336822357041,
                        "smoothness_avg": 0.010364133226421615,
                        "success_improvement": 0.0,
                        "time_improvement": 82.0903097864236,
                        "length_improvement": 0.6081353505372269,
                        "smoothness_improvement": 62.22119106902168,
                        "objective_score": 25.303080101594528
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.009473919868469238,
                        "num_nodes_avg": 232.1,
                        "path_length_avg": 309.7098401574599,
                        "smoothness_avg": 0.0063037920317717076,
                        "success_improvement": 0.0,
                        "time_improvement": 94.13253372835166,
                        "length_improvement": -3.3900591480309807,
                        "smoothness_improvement": 62.20110941536065,
                        "objective_score": 26.516730176763712
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.0069907188415527345,
                        "num_nodes_avg": 156.4,
                        "path_length_avg": 156.13971391106816,
                        "smoothness_avg": 0.012882547888137738,
                        "success_improvement": 0.0,
                        "time_improvement": 85.88324787559279,
                        "length_improvement": -3.7005634055365793,
                        "smoothness_improvement": 63.865058246339665,
                        "objective_score": 23.863961610587587
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m1",
                "algorithm_description": "An enhanced bidirectional RRT* planner integrating adaptive radius rewiring, robust minimal-cost parent selection, a hybrid sampling strategy combining uniform, informed ellipsoidal, and goal biasing sampling to efficiently explore the space and avoid local minima, with efficient spatial hashing for neighbor queries. It includes early termination upon stagnation and progressive multi-pass shortcutting to improve path length and smoothness. The planner performs strict collision checks before node and edge additions and incrementally rewires to optimize global path quality, ensuring shorter, smoother paths with less planning time and higher success rates.",
                "planning_mechanism": "The planner grows two trees alternately from start and goal, sampling points biased by a mix of uniform, informed, and goal-directed samples. For each sample, it finds neighbors within an adaptive radius that decreases as trees grow, selects the minimal-cost parent through collision-checked edges, and adds the new node. It then incrementally rewires nearby nodes if connecting through the new node lowers their cost. The two trees attempt to connect every iteration. Early stopping triggers on stagnation. Once connected, the path is extracted and refined via multiple shortcutting passes to produce a short, smooth path.",
                "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        path.reverse()\n        return path\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=5.0,\n                 base_radius=20.0,\n                 min_radius=8.0,\n                 time_limit=20.0,\n                 no_improve_limit=50,\n                 shortcut_passes=5,\n                 shortcut_attempts=500,\n                 uniform_sample_chance=0.1,\n                 goal_sample_chance=0.05,\n                 grid_cell_size=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_chance = uniform_sample_chance\n        self.goal_sample_chance = goal_sample_chance\n        self.grid_cell_size = grid_cell_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import time\n        import random\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,)* (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,res=1.0):\n            dist = math.dist(a,b)\n            if dist < 1e-12:\n                return False\n            steps = max(2,int(dist/res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm,to):\n            dist = math.dist(frm,to)\n            if dist <= self.step_size:\n                return to\n            r = self.step_size/dist\n            return tuple(frm[d] + (to[d]-frm[d])*r for d in range(dim))\n\n        class SpatialGrid:\n            __slots__ = ('cell_size','dim','grid')\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self,pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self,node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self,node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self,pos,radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                result = []\n                rng = range(-cr,cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx,base[1]+dy)\n                            if cell in self.grid:\n                                result.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx,base[1]+dy,base[2]+dz)\n                                if cell in self.grid:\n                                    result.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for node in result:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        dist_sq += (node.position[d]-pos[d])**2\n                    if dist_sq <= r2:\n                        filtered.append(node)\n                return filtered\n            def nearest(self,pos):\n                base = self._hash(pos)\n                search_range = 0\n                candidates = []\n                max_search = 8\n                while not candidates and search_range <= max_search:\n                    rng = range(-search_range, search_range+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        candidates.extend(self.grid[cell])\n                    search_range += 1\n                if not candidates:\n                    return None\n                nearest_node = min(candidates,key=lambda n:math.dist(n.position,pos))\n                return nearest_node\n\n        # Sampling strategies\n        def sample_uniform():\n            for _ in range(30):\n                p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n            center = tuple(0.5*(start_pos[d]+goal_pos[d]) for d in range(dim))\n            a1 = tuple((goal_pos[d]-start_pos[d])/c_min for d in range(dim))\n            radii = [c_best*0.5] + [math.sqrt(max(0, c_best*c_best - c_min*c_min))*0.5]*(dim-1)\n            basis = [list(a1)]\n            for i in range(dim-1):\n                v = [0.0]*dim\n                v[(i+1)%dim] = 1.0\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j]-proj*b[j] for j in range(dim)]\n                nrm = math.sqrt(sum(x*x for x in v))\n                if nrm > 1e-10:\n                    basis.append([x/nrm for x in v])\n                else:\n                    basis.append([0.0]*dim)\n            for _ in range(50):\n                vec = [random.gauss(0,1) for _ in range(dim)]\n                nrm = math.sqrt(sum(x*x for x in vec))\n                if nrm < 1e-10:\n                    continue\n                unit_vec = [x/nrm for x in vec]\n                r = random.random()**(1/dim)\n                scale = [radii[i]*unit_vec[i]*r for i in range(dim)]\n                p = [center[j]+sum(basis[i][j]*scale[i] for i in range(dim)) for j in range(dim)]\n                clamped = tuple(max(0.0,min(bounds[d],p[d])) for d in range(dim))\n                if not in_obstacle(clamped):\n                    return clamped\n            return sample_uniform()\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        # Adaptive radius function: decreases as tree grows\n        def adaptive_radius(n_nodes):\n            val = self.base_radius * (math.log(n_nodes+1)/(n_nodes+1))**(1/dim)\n            return max(self.min_radius, min(val, self.base_radius))\n\n        def choose_parent(nodes, grid, pos, radius):\n            neighbors = grid.query_radius(pos, radius)\n            candidates = [n for n in neighbors if n and not edge_in_obstacle(n.position, pos)]\n            # Also consider nearest if no candidate\n            if not candidates:\n                nearest = grid.nearest(pos)\n                if nearest is None or edge_in_obstacle(nearest.position,pos) or in_obstacle(pos):\n                    return None, []\n                candidates = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in candidates:\n                c = nb.cost + math.dist(nb.position, pos)\n                if c < best_cost:\n                    best_cost = c\n                    best_parent = nb\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, candidates\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(new_node.position, nb.position):\n                        continue\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    # Propagate cost downstream efficiently\n                    stack = [nb]\n                    while stack:\n                        current = stack.pop()\n                        for ch in current.children:\n                            dcost = current.cost + math.dist(current.position, ch.position)\n                            if dcost + 1e-12 < ch.cost:\n                                ch.cost = dcost\n                                ch.parent = current\n                                stack.append(ch)\n\n        def try_connect(tree_nodes, tree_grid, other_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_grid.nearest(other_node.position)\n            if nearest is None:\n                return None\n            dist = math.dist(nearest.position, other_node.position)\n            if dist <= self.step_size:\n                if edge_in_obstacle(nearest.position, other_node.position) or in_obstacle(other_node.position):\n                    return None\n                new_node = Node(other_node.position, parent=nearest, cost=nearest.cost + dist)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                return new_node\n            # Stepwise steer toward other_node\n            current = nearest\n            steps = int(math.ceil(dist/self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, other_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position,new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position,new_pos))\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, other_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, other_node.position) or in_obstacle(other_node.position):\n                        return None\n                    final_node = Node(other_node.position, parent=current, cost=current.cost + math.dist(current.position, other_node.position))\n                    tree_nodes.append(final_node)\n                    tree_grid.insert(final_node)\n                    return final_node\n            return None\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _pass in range(self.shortcut_passes):\n                changed = True\n                attempt = 0\n                while changed and attempt < self.shortcut_attempts:\n                    changed = False\n                    attempt += 1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path)-3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1, p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        # Initialization\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found = False\n        no_improve_count = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n\n            # Sampling with mixture: goal bias, uniform, informed sampling\n            r = random.random()\n            if r < self.goal_sample_chance:\n                sample_pt = sample_goal()\n            elif found and r < self.goal_sample_chance + (1 - self.goal_sample_chance) * (1 - self.uniform_sample_chance):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid_a.nearest(sample_pt)\n            if nearest is None:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            new_node, nbrs = choose_parent(tree_a, grid_a, new_pos, radius)\n            if new_node is None:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, nbrs, grid_a)\n\n            connect_node = try_connect(tree_b, grid_b, new_node)\n            if connect_node is not None:\n                # Construct merged path\n                if it % 2 == 0:\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = connect_node.path_from_root()\n                else:\n                    path_from_start = connect_node.path_from_root()\n                    path_from_goal = new_node.path_from_root()\n                if path_from_start and path_from_goal and (path_from_start[-1] == path_from_goal[0]):\n                    merged = path_from_start + path_from_goal[1:]\n                else:\n                    merged = path_from_start + path_from_goal[::-1]\n\n                total_cost = 0.0\n                for i in range(len(merged)-1):\n                    total_cost += math.dist(merged[i], merged[i+1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = merged\n                    found = True\n                    no_improve_count = 0\n                else:\n                    if found:\n                        no_improve_count += 1\n                        if no_improve_count >= self.no_improve_limit:\n                            break\n            else:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n        if found and len(best_path) > 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found, path=best_path,\n                             nodes=start_tree + goal_tree,\n                             edges=[])",
                "objective": -23.47946,
                "time_improvement": 50.0,
                "length_improvement": 13.0,
                "smoothness_improvement": 196.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.014624309539794923,
                        "num_nodes_avg": 130.3,
                        "path_length_avg": 165.4729579686278,
                        "smoothness_avg": 0.015159899480090827,
                        "success_improvement": 0.0,
                        "time_improvement": 39.78156400174748,
                        "length_improvement": 9.301649650581044,
                        "smoothness_improvement": 137.2853471120493,
                        "objective_score": 18.20188572643312
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.024036192893981935,
                        "num_nodes_avg": 307.3,
                        "path_length_avg": 264.8755101048411,
                        "smoothness_avg": 0.009042457580025903,
                        "success_improvement": 0.0,
                        "time_improvement": 85.11370656895161,
                        "length_improvement": 11.57693070817087,
                        "smoothness_improvement": 132.66894655300317,
                        "objective_score": 33.14361512835303
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.03758563995361328,
                        "num_nodes_avg": 370.6,
                        "path_length_avg": 124.79156925933553,
                        "smoothness_avg": 0.03287575734057671,
                        "success_improvement": 0.0,
                        "time_improvement": 24.10120122288823,
                        "length_improvement": 17.11938163390731,
                        "smoothness_improvement": 318.1772067361503,
                        "objective_score": 19.092875380891602
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "m2",
            "algorithm_description": "An improved bidirectional RRT* planner that integrates adaptive informed sampling, dynamic rewiring with efficient neighbor querying via spatial hashing, and a curvature-aware smoothing post-process. The planner alternates tree growth from start and goal, uses a tempered early stopping mechanism based on improvement stagnation, and refines the final path by combining shortcutting with a lightweight curvature smoothing pass to produce collision-free, shorter, and smoother trajectories while reducing planning time.",
            "planning_mechanism": "The planner performs bidirectional tree expansion with alternating growth and connection attempts, samples points biased by a mix of goal, uniform, and informed strategies restricted to a reshaped ellipsoid for focusing search as better solutions emerge. It maintains spatial hashed structures for efficient neighbor retrieval and performs adaptive radius rewiring to optimize path cost and structure locally. Early stopping prevents unnecessary computation. The final extracted path goes through multi-pass shortcutting combined with a curvature-based moving average smoothing to improve smoothness of the trajectory while preserving obstacle clearance and path length gains.",
            "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=4.5,\n                 base_radius=18.0,\n                 min_radius=7.5,\n                 time_limit=15.0,\n                 no_improve_limit=40,\n                 shortcut_passes=6,\n                 shortcut_attempts=600,\n                 uniform_sample_chance=0.12,\n                 goal_sample_chance=0.07,\n                 grid_cell_size=12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_chance = uniform_sample_chance\n        self.goal_sample_chance = goal_sample_chance\n        self.grid_cell_size = grid_cell_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import time\n        import random\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,) * (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,res=1.0):\n            dist = math.dist(a,b)\n            if dist < 1e-12:\n                return False\n            steps = max(2,int(dist/res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm,to):\n            dist = math.dist(frm,to)\n            if dist <= self.step_size:\n                return to\n            r = self.step_size/dist\n            return tuple(frm[d] + (to[d]-frm[d])*r for d in range(dim))\n\n        class SpatialGrid:\n            __slots__ = ('cell_size','dim','grid')\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self,pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self,node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self,node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self,pos,radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                result = []\n                rng = range(-cr,cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx,base[1]+dy)\n                            if cell in self.grid:\n                                result.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx,base[1]+dy,base[2]+dz)\n                                if cell in self.grid:\n                                    result.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for node in result:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        dist_sq += (node.position[d]-pos[d])**2\n                    if dist_sq <= r2:\n                        filtered.append(node)\n                return filtered\n            def nearest(self,pos):\n                base = self._hash(pos)\n                search_range = 0\n                candidates = []\n                max_search = 7\n                while not candidates and search_range <= max_search:\n                    rng = range(-search_range, search_range+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        candidates.extend(self.grid[cell])\n                    search_range += 1\n                if not candidates:\n                    return None\n                nearest_node = min(candidates,key=lambda n:math.dist(n.position,pos))\n                return nearest_node\n\n        # Sampling strategies\n        def sample_uniform():\n            for _ in range(30):\n                p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n            center = tuple(0.5*(start_pos[d]+goal_pos[d]) for d in range(dim))\n            a1 = [(goal_pos[d]-start_pos[d])/c_min for d in range(dim)]\n            # Radii of ellipse axes:\n            r1 = c_best*0.5\n            squared = max(0.0, c_best*c_best - c_min*c_min)\n            r_others = math.sqrt(squared)*0.5 if dim > 1 else 0\n            radii = [r1] + [r_others]*(dim-1)\n            # Build orthonormal basis with a1 as first vector\n            basis = []\n            basis.append(a1)\n            for i in range(1,dim):\n                v = [0.0]*dim\n                v[i] = 1.0\n                # Gram-Schmidt\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j] - proj*b[j] for j in range(dim)]\n                norm_v = math.sqrt(sum(x*x for x in v))\n                if norm_v > 1e-10:\n                    v = [x/norm_v for x in v]\n                else:\n                    v = [0.0]*dim\n                basis.append(v)\n            for _ in range(40):\n                vec = [random.gauss(0,1) for _ in range(dim)]\n                norm_vec = math.sqrt(sum(x*x for x in vec))\n                if norm_vec < 1e-10:\n                    continue\n                unit_vec = [x/norm_vec for x in vec]\n                r = random.random()**(1/dim)\n                scale = [radii[i]*unit_vec[i]*r for i in range(dim)]\n                p = [center[j] + sum(basis[i][j]*scale[i] for i in range(dim)) for j in range(dim)]\n                clamped = tuple(max(0.0,min(bounds[d],p[d])) for d in range(dim))\n                if not in_obstacle(clamped):\n                    return clamped\n            return sample_uniform()\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def adaptive_radius(n_nodes):\n            if n_nodes < 2:\n                return self.base_radius\n            val = self.base_radius * (math.log(n_nodes+1)/(n_nodes+1))**(1/dim)\n            return max(self.min_radius, min(val, self.base_radius))\n\n        def choose_parent(nodes, grid, pos, radius):\n            neighbors = grid.query_radius(pos, radius)\n            candidates = [n for n in neighbors if n and not edge_in_obstacle(n.position, pos)]\n            if not candidates:\n                nearest = grid.nearest(pos)\n                if nearest is None or edge_in_obstacle(nearest.position, pos) or in_obstacle(pos):\n                    return None, []\n                candidates = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in candidates:\n                c = nb.cost + math.dist(nb.position, pos)\n                if c < best_cost:\n                    best_cost = c\n                    best_parent = nb\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, candidates\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(new_node.position, nb.position):\n                        continue\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    stack = [nb]\n                    while stack:\n                        curr = stack.pop()\n                        for ch in curr.children:\n                            new_ch_cost = curr.cost + math.dist(curr.position, ch.position)\n                            if new_ch_cost + 1e-12 < ch.cost:\n                                ch.cost = new_ch_cost\n                                ch.parent = curr\n                                stack.append(ch)\n\n        def try_connect(tree_nodes, tree_grid, other_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_grid.nearest(other_node.position)\n            if nearest is None:\n                return None\n            dist = math.dist(nearest.position, other_node.position)\n            if dist <= self.step_size:\n                if edge_in_obstacle(nearest.position, other_node.position) or in_obstacle(other_node.position):\n                    return None\n                new_node = Node(other_node.position, parent=nearest, cost=nearest.cost+dist)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                return new_node\n            current = nearest\n            max_steps = int(math.ceil(dist/self.step_size))\n            for _ in range(max_steps):\n                new_pos = steer(current.position, other_node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos) or \n                    edge_in_obstacle(current.position, new_pos)):\n                    return None\n                d = math.dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=current.cost+d)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, other_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, other_node.position) or in_obstacle(other_node.position):\n                        return None\n                    final_node = Node(other_node.position, parent=current, cost=current.cost + math.dist(current.position, other_node.position))\n                    tree_nodes.append(final_node)\n                    tree_grid.insert(final_node)\n                    return final_node\n            return None\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _pass in range(self.shortcut_passes):\n                changed = True\n                attempt = 0\n                while changed and attempt < self.shortcut_attempts:\n                    changed = False\n                    attempt += 1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path) - 3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1, p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        def smooth_path(path):\n            # Curvature-aware lightweight smoothing by iterative averaging without entering obstacles\n            if len(path) < 4:\n                return path[:]\n            smoothed = list(path)\n            alpha = 0.15  # blending factor\n            for _ in range(7):\n                for i in range(1, len(smoothed)-1):\n                    prev_p = smoothed[i-1]\n                    curr_p = smoothed[i]\n                    next_p = smoothed[i+1]\n                    new_pt = tuple(\n                        curr_p[d] + alpha * (prev_p[d] + next_p[d] - 2 * curr_p[d])\n                        for d in range(dim)\n                    )\n                    # Clamp to bounds\n                    clamped = tuple(max(0.0, min(bounds[d], new_pt[d])) for d in range(dim))\n                    if (not in_obstacle(clamped) and\n                        not edge_in_obstacle(smoothed[i-1], clamped) and\n                        not edge_in_obstacle(clamped, smoothed[i+1])):\n                        smoothed[i] = clamped\n            return smoothed\n\n        # Initialize trees and grids\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found = False\n        no_improve_count = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n\n            r = random.random()\n            if r < self.goal_sample_chance:\n                sample_pt = sample_goal()\n            elif found and r < self.goal_sample_chance + (1 - self.goal_sample_chance) * (1 - self.uniform_sample_chance):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid_a.nearest(sample_pt)\n            if nearest is None:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if (not in_bounds(new_pos) or in_obstacle(new_pos) or \n                edge_in_obstacle(nearest.position, new_pos)):\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            new_node, neighbors = choose_parent(tree_a, grid_a, new_pos, radius)\n            if new_node is None:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid_a)\n\n            connect_node = try_connect(tree_b, grid_b, new_node)\n            if connect_node is not None:\n                if it % 2 == 0:\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = connect_node.path_from_root()\n                else:\n                    path_from_start = connect_node.path_from_root()\n                    path_from_goal = new_node.path_from_root()\n\n                if path_from_start and path_from_goal and (path_from_start[-1] == path_from_goal[0]):\n                    merged = path_from_start + path_from_goal[1:]\n                else:\n                    merged = path_from_start + path_from_goal[::-1]\n\n                # Calculate cost\n                total_cost = 0.0\n                for i in range(len(merged)-1):\n                    total_cost += math.dist(merged[i], merged[i+1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = merged\n                    found = True\n                    no_improve_count = 0\n                else:\n                    if found:\n                        no_improve_count += 1\n                        if no_improve_count >= self.no_improve_limit:\n                            break\n            else:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n        if found and len(best_path) > 3:\n            best_path = shortcut_path(best_path)\n            best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found, path=best_path,\n                             nodes=start_tree + goal_tree,\n                             edges=[])",
            "objective": -22.47355,
            "time_improvement": 31.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 210.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.02435743808746338,
                    "num_nodes_avg": 134.9,
                    "path_length_avg": 150.0151772566704,
                    "smoothness_avg": 0.011776657899457267,
                    "success_improvement": 0.0,
                    "time_improvement": -0.2964839167292523,
                    "length_improvement": 17.77430420301498,
                    "smoothness_improvement": 84.3302695484517,
                    "objective_score": 10.997288694532472
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.034082865715026854,
                    "num_nodes_avg": 318.3,
                    "path_length_avg": 236.9473194012731,
                    "smoothness_avg": 0.010060586508523858,
                    "success_improvement": 0.0,
                    "time_improvement": 78.89151820994326,
                    "length_improvement": 20.900164633419585,
                    "smoothness_improvement": 158.8661372118814,
                    "objective_score": 37.00188492909413
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0427628755569458,
                    "num_nodes_avg": 416.9,
                    "path_length_avg": 116.96333679077054,
                    "smoothness_avg": 0.038308683773727,
                    "success_improvement": 0.0,
                    "time_improvement": 13.64651789798031,
                    "length_improvement": 22.318520899155825,
                    "smoothness_improvement": 387.283629948907,
                    "objective_score": 19.421486058632123
                }
            ],
            "success_rate": 1.0
        },
        "objective": 9.2,
        "analysis": {
            "problem": [
                ""
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Integration of adaptive informed sampling narrowing the search space as better solutions are found.\n   - Implementation of spatial hashing for efficient neighbor queries enabling dynamic and frequent rewiring.\n   - Use of adaptive radius for neighbor selection to better balance exploration and exploitation.\n   - Incorporation of a curvature-aware smoothing post-processing step improving path smoothness without sacrificing clearance.\n   - Employing a tempered early stopping mechanism allowing more thorough search before termination.\n\n2. Expected mechanism of impact:\n   - Focused sampling reduces wasted samples in irrelevant space, accelerating discovery of shorter paths.\n   - Efficient neighbor lookup and rewiring optimize path costs incrementally leading to shorter and more efficient trajectories.\n   - Adaptive radius enhances local connectivity, preventing overly large or small neighborhoods, fostering more effective graph restructuring.\n   - Smoothing improves path quality by removing unnecessary sharp turns and intermediate nodes, reducing path length and increasing smoothness.\n   - Early stopping balanced with stagnation thresholds ensures adequate optimization without excessive computation."
        }
    },
    {
        "parents": [
            {
                "operator": "e2",
                "algorithm_description": "A Bidirectional Informed RRT* with Adaptive Radius and Progressive Rewiring integrating a balanced ellipsoidal informed sampler, efficient linear nearest neighbor search with incremental rewiring, and robust early stopping based on solution stagnation and path cost improvement. The algorithm alternately expands start and goal trees, prioritizes smoother and shorter paths by cost-aware parent selection, adaptively adjusts rewiring radius based on the number of nodes and best cost, and applies a final multi-pass shortcut smoothing to yield efficient, low-cost, and smooth paths within bounded planning time.",
                "planning_mechanism": "The planner maintains two trees grown alternately from start and goal. Sampling is initially uniform and focuses progressively within a shrinking ellipsoid around the currently best path. The nearest parent is selected by minimal cost plus a small curvature penalty. An adaptive rewiring radius shrinks as better solutions are found, enabling local optimization. Each new node attempts rewiring neighbors within radius if it improves cost. The trees connect when nodes are near and collision free. Early termination occurs if no improvements happen in prolonged iterations. After planning, a multi-pass shortcutting cleans and smooths the path to reduce length and curvature.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=5.5, n_near_const=28,\n                 max_no_improve=70, improve_tol=1e-6, shortcut_iters=300):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a, b: math.dist(a, b)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if (ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od):\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if (ox <= px <= ox + ow and oy <= py <= oy + oh):\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps +1):\n                inter = tuple(f[d] + (t[d] - f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best = None\n            best_d = float('inf')\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 >= best_d*best_d:\n                        break\n                else:\n                    d = math.sqrt(d2)\n                    if d < best_d:\n                        best = n\n                        best_d = d\n            return best, best_d\n\n        def near_nodes(tree, p, radius):\n            r2 = radius*radius\n            res = []\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 > r2:\n                        break\n                if d2 <= r2:\n                    res.append(n)\n            return res\n\n        def adaptive_radius(n_nodes, c_best):\n            gamma = self.n_near_const\n            if n_nodes == 0:\n                return self.step_size * 3.0\n            radius = min((gamma * (math.log(n_nodes)/n_nodes))**(1/dim), self.step_size * 6.0)\n            if c_best == float('inf'):\n                return radius\n            shrink = max(0.3, c_best / (c_min * 3.1))\n            return max(self.step_size * 0.8, radius * shrink)\n\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                # Uniform sample in bounds avoiding boundary issues\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n            U = [unit_a1]\n            for idx in range(dim -1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j] - proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0.0]*dim)\n            r1 = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val > 0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n\n            max_attempt = 50\n            for _ in range(max_attempt):\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n                scaled = [radii[i]*point_ball[i] for i in range(dim)]\n                point_rot = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rot[j] += scaled[i]*U[i][j]\n                sample = tuple(center[i] + point_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not in_obstacle(sample):\n                    return sample\n            # fallback\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def extract_path(node):\n            return node.path_from_root()\n\n        def connect_path(n_start, n_goal):\n            path_s = extract_path(n_start)\n            path_g_rev = extract_path(n_goal)\n            path_g = path_g_rev[::-1]\n            if len(path_s) > 0 and len(path_g) > 0 and path_s[-1] == path_g[0]:\n                return path_s + path_g[1:]\n            else:\n                return path_s + path_g\n\n        def curvature_penalty(p_parent, p_child, p_new):\n            # Small curvature cost for smoother parent selection\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_child[i] - p_parent[i] for i in range(dim))\n            v2 = tuple(p_new[i] - p_child[i] for i in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))/(len1*len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        def add_node(tree, new_pos, nodes_all, edges, c_best):\n            nn, _ = nearest(tree, new_pos)\n            if nn is None:\n                return None\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(nodes_all)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos_steered, radius)\n\n            alpha_curv = 0.04\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos_steered)\n            best_score = best_cost + alpha_curv * curvature_penalty(nn.parent.position if nn.parent else None, nn.position, new_pos_steered)\n\n            for candidate in near:\n                if candidate == nn:\n                    continue\n                if edge_obstacle(candidate.position, new_pos_steered):\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, new_pos_steered)\n                curv_cost = alpha_curv * curvature_penalty(candidate.parent.position if candidate.parent else None, candidate.position, new_pos_steered)\n                score = candidate_cost + curv_cost\n                if score + self.improve_tol < best_score:\n                    best_parent = candidate\n                    best_cost = candidate_cost\n                    best_score = score\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node if better path found\n            near_rewire = near_nodes(tree, new_node.position, radius)\n            for near_n in near_rewire:\n                if near_n == best_parent or near_n == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost and not edge_obstacle(new_node.position, near_n.position):\n                    # Additionally check curvature penalty for rewiring\n                    curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, near_n.position)\n                    curv_old = curvature_penalty(near_n.parent.parent.position if near_n.parent and near_n.parent.parent else None, near_n.parent.position if near_n.parent else None, near_n.position)\n                    if alpha_curv * curv_new <= alpha_curv * curv_old + 0.15:  # allow slight increase for cost gain\n                        if near_n.parent:\n                            near_n.parent.remove_child(near_n)\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_n)\n                        near_n.cost = alt_cost\n                        edges.append((new_node, near_n))\n\n            return new_node\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path = list(path)\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                changed = False\n                iter_count +=1\n                i=0\n                while i < len(path)-2:\n                    max_j = min(len(path)-1, i + 7 + random.randint(0,4))\n                    j = random.randint(i+2, max_j) if max_j > i+2 else i+2\n                    if j > i+1 and not edge_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialize bidirectional trees\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate growing trees: even iterations start-tree, odd goal-tree\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            new_node = add_node(tree_a, sample_pt, nodes_all, edges, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                continue\n\n            nbr_node, nbr_dist = nearest(tree_b, new_node.position)\n            if nbr_node and nbr_dist <= self.step_size and not edge_obstacle(new_node.position, nbr_node.position):\n                candidate_path = connect_path(new_node, nbr_node)\n                candidate_cost = new_node.cost + dist(new_node.position, nbr_node.position) + nbr_node.cost\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                last_best_cost = best_cost\n                no_improve_count = 0\n\n        if found_solution and len(best_path) > 3:\n            # Multiple progressive shortcut passes to enhance path quality\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
                "objective": -23.40566,
                "time_improvement": 28.0,
                "length_improvement": 13.0,
                "smoothness_improvement": 1419.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.02814173698425293,
                        "num_nodes_avg": 174.7,
                        "path_length_avg": 170.78044027086807,
                        "smoothness_avg": 0.041064375085066517,
                        "success_improvement": 0.0,
                        "time_improvement": -15.879069904428114,
                        "length_improvement": 6.3925344982841175,
                        "smoothness_improvement": 542.746642799047,
                        "objective_score": 1.7855329416372712
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.04101948738098145,
                        "num_nodes_avg": 312.8,
                        "path_length_avg": 241.95417433722574,
                        "smoothness_avg": 0.08769719153831615,
                        "success_improvement": 0.0,
                        "time_improvement": 74.59547240955273,
                        "length_improvement": 19.228732341469897,
                        "smoothness_improvement": 2156.5119040147615,
                        "objective_score": 44.698440647821556
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.036681413650512695,
                        "num_nodes_avg": 276.1,
                        "path_length_avg": 130.08856674191185,
                        "smoothness_avg": 0.13041023521317593,
                        "success_improvement": 0.0,
                        "time_improvement": 25.927156303411085,
                        "length_improvement": 13.601368121895007,
                        "smoothness_improvement": 1558.8085660293298,
                        "objective_score": 23.733010594306975
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m2",
                "algorithm_description": "An improved bidirectional RRT* planner that integrates adaptive informed sampling, dynamic rewiring with efficient neighbor querying via spatial hashing, and a curvature-aware smoothing post-process. The planner alternates tree growth from start and goal, uses a tempered early stopping mechanism based on improvement stagnation, and refines the final path by combining shortcutting with a lightweight curvature smoothing pass to produce collision-free, shorter, and smoother trajectories while reducing planning time.",
                "planning_mechanism": "The planner performs bidirectional tree expansion with alternating growth and connection attempts, samples points biased by a mix of goal, uniform, and informed strategies restricted to a reshaped ellipsoid for focusing search as better solutions emerge. It maintains spatial hashed structures for efficient neighbor retrieval and performs adaptive radius rewiring to optimize path cost and structure locally. Early stopping prevents unnecessary computation. The final extracted path goes through multi-pass shortcutting combined with a curvature-based moving average smoothing to improve smoothness of the trajectory while preserving obstacle clearance and path length gains.",
                "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=4.5,\n                 base_radius=18.0,\n                 min_radius=7.5,\n                 time_limit=15.0,\n                 no_improve_limit=40,\n                 shortcut_passes=6,\n                 shortcut_attempts=600,\n                 uniform_sample_chance=0.12,\n                 goal_sample_chance=0.07,\n                 grid_cell_size=12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_chance = uniform_sample_chance\n        self.goal_sample_chance = goal_sample_chance\n        self.grid_cell_size = grid_cell_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import time\n        import random\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,) * (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,res=1.0):\n            dist = math.dist(a,b)\n            if dist < 1e-12:\n                return False\n            steps = max(2,int(dist/res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm,to):\n            dist = math.dist(frm,to)\n            if dist <= self.step_size:\n                return to\n            r = self.step_size/dist\n            return tuple(frm[d] + (to[d]-frm[d])*r for d in range(dim))\n\n        class SpatialGrid:\n            __slots__ = ('cell_size','dim','grid')\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self,pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self,node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self,node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self,pos,radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                result = []\n                rng = range(-cr,cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx,base[1]+dy)\n                            if cell in self.grid:\n                                result.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx,base[1]+dy,base[2]+dz)\n                                if cell in self.grid:\n                                    result.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for node in result:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        dist_sq += (node.position[d]-pos[d])**2\n                    if dist_sq <= r2:\n                        filtered.append(node)\n                return filtered\n            def nearest(self,pos):\n                base = self._hash(pos)\n                search_range = 0\n                candidates = []\n                max_search = 7\n                while not candidates and search_range <= max_search:\n                    rng = range(-search_range, search_range+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        candidates.extend(self.grid[cell])\n                    search_range += 1\n                if not candidates:\n                    return None\n                nearest_node = min(candidates,key=lambda n:math.dist(n.position,pos))\n                return nearest_node\n\n        # Sampling strategies\n        def sample_uniform():\n            for _ in range(30):\n                p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n            center = tuple(0.5*(start_pos[d]+goal_pos[d]) for d in range(dim))\n            a1 = [(goal_pos[d]-start_pos[d])/c_min for d in range(dim)]\n            # Radii of ellipse axes:\n            r1 = c_best*0.5\n            squared = max(0.0, c_best*c_best - c_min*c_min)\n            r_others = math.sqrt(squared)*0.5 if dim > 1 else 0\n            radii = [r1] + [r_others]*(dim-1)\n            # Build orthonormal basis with a1 as first vector\n            basis = []\n            basis.append(a1)\n            for i in range(1,dim):\n                v = [0.0]*dim\n                v[i] = 1.0\n                # Gram-Schmidt\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j] - proj*b[j] for j in range(dim)]\n                norm_v = math.sqrt(sum(x*x for x in v))\n                if norm_v > 1e-10:\n                    v = [x/norm_v for x in v]\n                else:\n                    v = [0.0]*dim\n                basis.append(v)\n            for _ in range(40):\n                vec = [random.gauss(0,1) for _ in range(dim)]\n                norm_vec = math.sqrt(sum(x*x for x in vec))\n                if norm_vec < 1e-10:\n                    continue\n                unit_vec = [x/norm_vec for x in vec]\n                r = random.random()**(1/dim)\n                scale = [radii[i]*unit_vec[i]*r for i in range(dim)]\n                p = [center[j] + sum(basis[i][j]*scale[i] for i in range(dim)) for j in range(dim)]\n                clamped = tuple(max(0.0,min(bounds[d],p[d])) for d in range(dim))\n                if not in_obstacle(clamped):\n                    return clamped\n            return sample_uniform()\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def adaptive_radius(n_nodes):\n            if n_nodes < 2:\n                return self.base_radius\n            val = self.base_radius * (math.log(n_nodes+1)/(n_nodes+1))**(1/dim)\n            return max(self.min_radius, min(val, self.base_radius))\n\n        def choose_parent(nodes, grid, pos, radius):\n            neighbors = grid.query_radius(pos, radius)\n            candidates = [n for n in neighbors if n and not edge_in_obstacle(n.position, pos)]\n            if not candidates:\n                nearest = grid.nearest(pos)\n                if nearest is None or edge_in_obstacle(nearest.position, pos) or in_obstacle(pos):\n                    return None, []\n                candidates = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in candidates:\n                c = nb.cost + math.dist(nb.position, pos)\n                if c < best_cost:\n                    best_cost = c\n                    best_parent = nb\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, candidates\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(new_node.position, nb.position):\n                        continue\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    stack = [nb]\n                    while stack:\n                        curr = stack.pop()\n                        for ch in curr.children:\n                            new_ch_cost = curr.cost + math.dist(curr.position, ch.position)\n                            if new_ch_cost + 1e-12 < ch.cost:\n                                ch.cost = new_ch_cost\n                                ch.parent = curr\n                                stack.append(ch)\n\n        def try_connect(tree_nodes, tree_grid, other_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_grid.nearest(other_node.position)\n            if nearest is None:\n                return None\n            dist = math.dist(nearest.position, other_node.position)\n            if dist <= self.step_size:\n                if edge_in_obstacle(nearest.position, other_node.position) or in_obstacle(other_node.position):\n                    return None\n                new_node = Node(other_node.position, parent=nearest, cost=nearest.cost+dist)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                return new_node\n            current = nearest\n            max_steps = int(math.ceil(dist/self.step_size))\n            for _ in range(max_steps):\n                new_pos = steer(current.position, other_node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos) or \n                    edge_in_obstacle(current.position, new_pos)):\n                    return None\n                d = math.dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=current.cost+d)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, other_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, other_node.position) or in_obstacle(other_node.position):\n                        return None\n                    final_node = Node(other_node.position, parent=current, cost=current.cost + math.dist(current.position, other_node.position))\n                    tree_nodes.append(final_node)\n                    tree_grid.insert(final_node)\n                    return final_node\n            return None\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _pass in range(self.shortcut_passes):\n                changed = True\n                attempt = 0\n                while changed and attempt < self.shortcut_attempts:\n                    changed = False\n                    attempt += 1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path) - 3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1, p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        def smooth_path(path):\n            # Curvature-aware lightweight smoothing by iterative averaging without entering obstacles\n            if len(path) < 4:\n                return path[:]\n            smoothed = list(path)\n            alpha = 0.15  # blending factor\n            for _ in range(7):\n                for i in range(1, len(smoothed)-1):\n                    prev_p = smoothed[i-1]\n                    curr_p = smoothed[i]\n                    next_p = smoothed[i+1]\n                    new_pt = tuple(\n                        curr_p[d] + alpha * (prev_p[d] + next_p[d] - 2 * curr_p[d])\n                        for d in range(dim)\n                    )\n                    # Clamp to bounds\n                    clamped = tuple(max(0.0, min(bounds[d], new_pt[d])) for d in range(dim))\n                    if (not in_obstacle(clamped) and\n                        not edge_in_obstacle(smoothed[i-1], clamped) and\n                        not edge_in_obstacle(clamped, smoothed[i+1])):\n                        smoothed[i] = clamped\n            return smoothed\n\n        # Initialize trees and grids\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found = False\n        no_improve_count = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n\n            r = random.random()\n            if r < self.goal_sample_chance:\n                sample_pt = sample_goal()\n            elif found and r < self.goal_sample_chance + (1 - self.goal_sample_chance) * (1 - self.uniform_sample_chance):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid_a.nearest(sample_pt)\n            if nearest is None:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if (not in_bounds(new_pos) or in_obstacle(new_pos) or \n                edge_in_obstacle(nearest.position, new_pos)):\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            new_node, neighbors = choose_parent(tree_a, grid_a, new_pos, radius)\n            if new_node is None:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid_a)\n\n            connect_node = try_connect(tree_b, grid_b, new_node)\n            if connect_node is not None:\n                if it % 2 == 0:\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = connect_node.path_from_root()\n                else:\n                    path_from_start = connect_node.path_from_root()\n                    path_from_goal = new_node.path_from_root()\n\n                if path_from_start and path_from_goal and (path_from_start[-1] == path_from_goal[0]):\n                    merged = path_from_start + path_from_goal[1:]\n                else:\n                    merged = path_from_start + path_from_goal[::-1]\n\n                # Calculate cost\n                total_cost = 0.0\n                for i in range(len(merged)-1):\n                    total_cost += math.dist(merged[i], merged[i+1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = merged\n                    found = True\n                    no_improve_count = 0\n                else:\n                    if found:\n                        no_improve_count += 1\n                        if no_improve_count >= self.no_improve_limit:\n                            break\n            else:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n        if found and len(best_path) > 3:\n            best_path = shortcut_path(best_path)\n            best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found, path=best_path,\n                             nodes=start_tree + goal_tree,\n                             edges=[])",
                "objective": -22.47355,
                "time_improvement": 31.0,
                "length_improvement": 20.0,
                "smoothness_improvement": 210.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.02435743808746338,
                        "num_nodes_avg": 134.9,
                        "path_length_avg": 150.0151772566704,
                        "smoothness_avg": 0.011776657899457267,
                        "success_improvement": 0.0,
                        "time_improvement": -0.2964839167292523,
                        "length_improvement": 17.77430420301498,
                        "smoothness_improvement": 84.3302695484517,
                        "objective_score": 10.997288694532472
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.034082865715026854,
                        "num_nodes_avg": 318.3,
                        "path_length_avg": 236.9473194012731,
                        "smoothness_avg": 0.010060586508523858,
                        "success_improvement": 0.0,
                        "time_improvement": 78.89151820994326,
                        "length_improvement": 20.900164633419585,
                        "smoothness_improvement": 158.8661372118814,
                        "objective_score": 37.00188492909413
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.0427628755569458,
                        "num_nodes_avg": 416.9,
                        "path_length_avg": 116.96333679077054,
                        "smoothness_avg": 0.038308683773727,
                        "success_improvement": 0.0,
                        "time_improvement": 13.64651789798031,
                        "length_improvement": 22.318520899155825,
                        "smoothness_improvement": 387.283629948907,
                        "objective_score": 19.421486058632123
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "A Bidirectional Adaptive Informed RRT* planner integrating spatial hashing for accelerated nearest neighbor search, dynamic adaptive rewiring with curvature-aware cost propagation, integrated pruning of suboptimal nodes to constrain tree size, and an enhanced multi-pass shortcutting and curvature-aware smoothing during planning and post-processing. The planner balances exploration and informed focused sampling within ellipsoidal regions shrinking with best path cost, alternates tree expansions from start and goal, and aggressively optimizes path length and smoothness while controlling computational cost via pruning and efficient collision checks.",
            "planning_mechanism": "The planner maintains two trees grown alternately from start and goal positions. Sampling shifts from uniform to ellipsoidal informed sampling focused around the current best solution, with fallback uniform sampling. Spatial hashing accelerates nearest and neighbor searches allowing efficient adaptive rewiring within a radius that diminishes with tree size and best path cost. New nodes integrate curvature penalties directly into cost evaluation to favor smooth transitions. Rewiring triggers downstream cost propagation and curvature checks to enhance smoothness. Suboptimal branches exceeding cost and curvature thresholds are pruned dynamically to reduce overhead. Finally, multi-pass shortcutting and curvature-aware smoothing\u2014executed both during planning and after termination\u2014refine the extracted path into a shorter, smoother trajectory while ensuring collision-free continuity. Early stopping occurs based on improvement stagnation or time limit, resulting in robust, efficient planning with high-quality paths.",
            "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 base_radius=20.0,\n                 min_radius=5.0,\n                 time_limit=15.0,\n                 no_improve_limit=60,\n                 shortcut_passes=5,\n                 shortcut_attempts=400,\n                 uniform_sample_prob=0.1,\n                 goal_sample_prob=0.08,\n                 grid_cell_size=15.0,\n                 curvature_w=0.06,\n                 max_curvature_increase=0.12,\n                 prune_cost_factor=1.8):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_prob = uniform_sample_prob\n        self.goal_sample_prob = goal_sample_prob\n        self.grid_cell_size = grid_cell_size\n        self.curvature_w = curvature_w\n        self.max_curvature_increase = max_curvature_increase\n        self.prune_cost_factor = prune_cost_factor\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,) * (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a,b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_f_t = math.dist(frm, to)\n            if dist_f_t <= self.step_size:\n                return to\n            r = self.step_size / dist_f_t\n            return tuple(frm[d] + (to[d] - frm[d]) * r for d in range(dim))\n\n        # Curvature penalty: angle between vectors (parent->current) and (current->new)\n        def curvature_penalty(p_parent, p_curr, p_new):\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_curr[d] - p_parent[d] for d in range(dim))\n            v2 = tuple(p_new[d] - p_curr[d] for d in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[d]*v2[d] for d in range(dim)) / (len1 * len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        # Spatial hashing for fast neighbor queries\n        class SpatialGrid:\n            __slots__ = ('cell_size', 'dim', 'grid')\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self, pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self, node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self, node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self, pos, radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                result = []\n                rng = range(-cr, cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx, base[1]+dy)\n                            if cell in self.grid:\n                                result.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                if cell in self.grid:\n                                    result.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for node in result:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        diff = node.position[d] - pos[d]\n                        dist_sq += diff*diff\n                        if dist_sq > r2:\n                            break\n                    else:\n                        filtered.append(node)\n                return filtered\n            def nearest(self, pos):\n                base = self._hash(pos)\n                search_range = 0\n                candidates = []\n                max_search = 8\n                while not candidates and search_range <= max_search:\n                    rng = range(-search_range, search_range+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        candidates.extend(self.grid[cell])\n                    search_range += 1\n                if not candidates:\n                    return None\n                nearest_node = min(candidates, key=lambda n: math.dist(n.position,pos))\n                return nearest_node\n\n        # Sampling methods\n        def sample_uniform():\n            for _ in range(30):\n                p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d]+goal_pos[d])*0.5 for d in range(dim))\n            # Unit vector from start to goal:\n            dvec = [(goal_pos[d]-start_pos[d]) / c_min for d in range(dim)]\n            # Build orthonormal basis\n            basis = [dvec]\n            for i in range(1, dim):\n                v = [0.0]*dim\n                v[i] = 1.0\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j]-proj*b[j] for j in range(dim)]\n                normv = math.sqrt(sum(x*x for x in v))\n                basis.append([x/normv if normv>1e-14 else 0.0 for x in v])\n            r_long = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r_short = math.sqrt(max(0.0,val))*0.5 if dim > 1 else 0.0\n            radii = [r_long] + [r_short]*(dim-1)\n            for _ in range(40):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                unit_x = [x / norm_x for x in x_ball]\n                u = random.random()**(1/dim)\n                scaled = [radii[i]*unit_x[i]*u for i in range(dim)]\n                sample = [center[d] + sum(basis[i][d]*scaled[i] for i in range(dim)) for d in range(dim)]\n                sample = tuple(max(0.0, min(bounds[d], sample[d])) for d in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes < 2:\n                return self.base_radius\n            val = self.base_radius * (math.log(n_nodes+1) / (n_nodes+1))**(1/dim)\n            radius = max(self.min_radius, min(val, self.base_radius))\n            if c_best == float('inf'):\n                return radius\n            # Shrink radius with best solution cost to focus rewiring locally\n            shrink_factor = c_best / (math.dist(start_pos, goal_pos) * 2.8)\n            return max(self.min_radius, radius * max(0.4, shrink_factor))\n\n        def choose_parent(nodes, grid, pos, radius, c_best):\n            neighbors = grid.query_radius(pos, radius)\n            candidates = []\n            for nb in neighbors:\n                if in_obstacle(pos) or edge_in_obstacle(nb.position, pos):\n                    continue\n                candidates.append(nb)\n            if not candidates:\n                nearest = grid.nearest(pos)\n                if nearest is None or in_obstacle(pos) or edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                candidates = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in candidates:\n                c = nb.cost + math.dist(nb.position, pos)\n                curv = curvature_penalty(nb.parent.position if nb.parent else None, nb.position, pos)\n                score = c + self.curvature_w * curv\n                if score < best_cost:\n                    best_cost = score\n                    best_parent = nb\n            if best_parent is None:\n                return None, []\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, candidates\n\n        def propagate_costs(node, grid):\n            # DFS propagate improved costs downstream\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for ch in curr.children[:]:\n                    new_cost = curr.cost + math.dist(curr.position, ch.position)\n                    curv = curvature_penalty(curr.parent.position if curr.parent else None, curr.position, ch.position)\n                    new_score = new_cost + self.curvature_w * curv\n                    old_score = ch.cost + (self.curvature_w * curvature_penalty(ch.parent.parent.position if ch.parent and ch.parent.parent else None, ch.parent.position if ch.parent else None, ch.position) if ch.parent else 0)\n                    if new_score + 1e-10 < old_score:\n                        if edge_in_obstacle(curr.position, ch.position):\n                            continue\n                        ch.cost = new_cost\n                        ch.parent.remove_child(ch)\n                        curr.add_child(ch)\n                        stack.append(ch)\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                dist_new_nb = math.dist(new_node.position, nb.position)\n                new_cost = new_node.cost + dist_new_nb\n                if new_cost + 1e-12 >= nb.cost:\n                    continue\n                if edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                # Curvature penalty with parent-child relation check\n                curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, nb.position)\n                curv_old = curvature_penalty(nb.parent.parent.position if nb.parent and nb.parent.parent else None,\n                                            nb.parent.position if nb.parent else None, nb.position)\n                if self.curvature_w * curv_new > self.curvature_w * curv_old + self.max_curvature_increase:\n                    continue\n                if nb.parent is not None:\n                    nb.parent.remove_child(nb)\n                new_node.add_child(nb)\n                nb.cost = new_cost\n                propagate_costs(nb, grid)\n\n        def try_connect(tree_nodes, tree_grid, other_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_grid.nearest(other_node.position)\n            if nearest is None:\n                return None\n            dist_n_o = math.dist(nearest.position, other_node.position)\n            if dist_n_o <= self.step_size:\n                if edge_in_obstacle(nearest.position, other_node.position) or in_obstacle(other_node.position):\n                    return None\n                new_node = Node(other_node.position, parent=nearest, cost=nearest.cost+dist_n_o)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                return new_node\n            current = nearest\n            max_steps = int(math.ceil(dist_n_o / self.step_size))\n            for _ in range(max_steps):\n                new_pos = steer(current.position, other_node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos)):\n                    return None\n                dist_c_np = math.dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=current.cost+dist_c_np)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, other_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, other_node.position) or in_obstacle(other_node.position):\n                        return None\n                    final_node = Node(other_node.position, parent=current, cost=current.cost + math.dist(current.position, other_node.position))\n                    tree_nodes.append(final_node)\n                    tree_grid.insert(final_node)\n                    return final_node\n            return None\n\n        # Prune nodes that are far above best_path cost to keep tree small\n        def prune_tree(nodes, grid, cost_limit):\n            remove_nodes = []\n            for n in nodes:\n                if n.cost > cost_limit:\n                    remove_nodes.append(n)\n            for n in remove_nodes:\n                # Remove from parent's children list\n                if n.parent:\n                    n.parent.remove_child(n)\n                # Remove from grid and nodes list\n                grid.remove(n)\n                if n in nodes:\n                    nodes.remove(n)\n                # Post removal descendants are unreachable, no direct deletion here (could be improved)\n            return len(remove_nodes)\n\n        # Shortcutting path by removing intermediate nodes with collision-free chords\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _pass in range(self.shortcut_passes):\n                changed = True\n                attempts = 0\n                while changed and attempts < self.shortcut_attempts:\n                    changed = False\n                    attempts +=1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path)-3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1, p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        # Curvature-aware smoothing by iterative averaging during and after planning\n        def smooth_path(path):\n            if len(path) < 4:\n                return list(path)\n            smoothed = list(path)\n            alpha = 0.17\n            for _ in range(9):\n                for i in range(1, len(smoothed)-1):\n                    prev_p, curr_p, next_p = smoothed[i-1], smoothed[i], smoothed[i+1]\n                    new_pt = tuple(curr_p[d] + alpha*(prev_p[d] + next_p[d] - 2*curr_p[d]) for d in range(dim))\n                    # Clamp and collision check\n                    new_pt = tuple(max(0.0, min(bounds[d], new_pt[d])) for d in range(dim))\n                    if (not in_obstacle(new_pt) and not edge_in_obstacle(smoothed[i-1], new_pt) and not edge_in_obstacle(new_pt, smoothed[i+1])):\n                        smoothed[i] = new_pt\n            return smoothed\n\n        # Extract combined path from start_node to goal_node by reversing one branch and concatenating\n        def combine_paths(start_node, goal_node, reverse_start):\n            path_start = start_node.path_from_root()\n            path_goal = goal_node.path_from_root()\n            if reverse_start:\n                # path_start reversed, so goal_node tree is forward\n                path_start.reverse()\n                full_path = path_goal + path_start[1:]\n            else:\n                # start_node forward, goal_node reversed\n                path_goal.reverse()\n                full_path = path_start + path_goal[1:]\n            return full_path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n        start_time = time.time()\n        c_min = math.dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n                reverse_start = False\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n                reverse_start = True\n\n            r = random.random()\n            if r < self.goal_sample_prob:\n                sample_pt = sample_goal()\n            elif found_solution and r < self.goal_sample_prob + (1 - self.goal_sample_prob - self.uniform_sample_prob):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid_a.nearest(sample_pt)\n            if nearest is None:\n                if found_solution:\n                    no_improve_count +=1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            radius = adaptive_radius(len(tree_a), best_cost)\n            new_node, neighbors = choose_parent(tree_a, grid_a, new_pos, radius, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid_a)\n\n            connect_node = try_connect(tree_b, grid_b, new_node)\n            if connect_node:\n                candidate_path = combine_paths(new_node, connect_node, reverse_start)\n                total_cost = 0.0\n                for i in range(len(candidate_path) -1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i+1])\n                if total_cost + 1e-10 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                    # Prune both trees aggressively to trim nodes far away from best cost\n                    cost_limit = best_cost * self.prune_cost_factor\n                    prune_tree(start_tree, start_grid, cost_limit)\n                    prune_tree(goal_tree, goal_grid, cost_limit)\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count +=1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n            # Early abort if improvement stagnates heavily\n            if found_solution and no_improve_count >= self.no_improve_limit:\n                break\n\n        if found_solution and len(best_path) > 3:\n            # Multi-pass shortcutting and smoothing post-planning\n            for _ in range(2):\n                best_path = shortcut_path(best_path)\n                best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path,\n                             nodes=start_tree + goal_tree,\n                             edges=[])",
            "objective": -21.94032,
            "time_improvement": 27.0,
            "length_improvement": 21.0,
            "smoothness_improvement": 218.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.033988142013549806,
                    "num_nodes_avg": 152.2,
                    "path_length_avg": 155.0029124627248,
                    "smoothness_avg": 0.013386992872664144,
                    "success_improvement": 0.0,
                    "time_improvement": -39.95277855498452,
                    "length_improvement": 15.040447500854501,
                    "smoothness_improvement": 109.53550877750344,
                    "objective_score": -2.413887522095137
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.03955721855163574,
                    "num_nodes_avg": 342.0,
                    "path_length_avg": 225.80758202741654,
                    "smoothness_avg": 0.014658329875318548,
                    "success_improvement": 0.0,
                    "time_improvement": 75.50109681374721,
                    "length_improvement": 24.618929608374863,
                    "smoothness_improvement": 277.16938566019917,
                    "objective_score": 38.80753373745007
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.027274346351623534,
                    "num_nodes_avg": 269.3,
                    "path_length_avg": 113.89325843043791,
                    "smoothness_avg": 0.02886494217452123,
                    "success_improvement": 0.0,
                    "time_improvement": 44.923376904744714,
                    "length_improvement": 24.357520764667115,
                    "smoothness_improvement": 267.15993387150496,
                    "objective_score": 29.427325199581208
                }
            ],
            "success_rate": 1.0
        },
        "objective": 12.2,
        "analysis": {
            "problem": [
                ""
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Integration of spatial hashing data structures significantly accelerated nearest neighbor and radius queries, reducing computation time.\n   - Curvature-aware cost functions and constraints in both parent selection and rewiring improved path quality by balancing smoothness and length.\n   - Dynamic pruning of nodes based on cost thresholds effectively bounded tree sizes, lowering computational load and focusing search.\n   - Adaptive radius shrinking linked with current best solution cost concentrated rewiring efforts locally, enhancing optimization efficiency.\n   - Enhanced multi-pass shortcutting combined with curvature-aware smoothing during and after planning improved path smoothness substantially.\n2. Expected mechanism of impact:\n   - Faster neighbor queries allowed more iterations and rewiring steps within the same or less time, enabling better exploration and optimization.\n   - Incorporating curvature penalties during rewiring prevented excessive jagged connections, leading to smoother, shorter paths.\n   - Pruning reduced unnecessary search overhead by removing high-cost branches, accelerating convergence to high-quality paths.\n   - Focused sampling in ellipsoidal informed sets, coupled with radius adaptation, reduced wasted effort in irrelevant areas.\n   - The combined smoothing techniques refined final paths by removing suboptimal turns and straightening edges without compromising collision safety."
        }
    },
    {
        "parents": [
            {
                "operator": "cross_over",
                "algorithm_description": "A Bidirectional Informed RRT* planner with hybrid spatial hashing and balanced ellipsoidal sampling, integrating fast adaptive rewiring with curvature-aware incremental cost and multi-scale smoothing with enhanced shortcutting. The planner grows start and goal trees alternately, dynamically adjusts rewiring radius based on node count and best cost, uses spatial hashing for efficient neighbor queries, enforces curvature penalties to favor smooth transitions in both rewiring and smoothing, applies adaptive multi-pass shortcutting with early-exit heuristics, and prunes suboptimal branches to reduce overhead. Early stopping triggers on stagnation or time limit, resulting in faster convergence to shorter, smoother feasible paths.",
                "planning_mechanism": "A bidirectional planning approach that combines efficient sampling inside shrinking informed ellipsoids and uniform exploration, accelerated nearest node and neighbor retrieval via spatial hashing, adaptive rewiring considering curvature costs, dynamic pruning to constrain tree size, and progressive shortcutting and curvature-aware smoothing to refine paths both during and after planning, achieving improved path length and smoothness with reduced planning time.",
                "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=5.0,\n                 base_radius=18.0,\n                 min_radius=4.5,\n                 time_limit=12.0,\n                 no_improve_limit=50,\n                 shortcut_passes=3,\n                 shortcut_attempts=350,\n                 uniform_sample_prob=0.12,\n                 goal_sample_prob=0.07,\n                 grid_cell_size=14.0,\n                 curvature_w=0.055,\n                 max_curvature_increase=0.1,\n                 prune_cost_factor=1.7):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_prob = uniform_sample_prob\n        self.goal_sample_prob = goal_sample_prob\n        self.grid_cell_size = grid_cell_size\n        self.curvature_w = curvature_w\n        self.max_curvature_increase = max_curvature_increase\n        self.prune_cost_factor = prune_cost_factor\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,) * (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a,b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_f_t = math.dist(frm, to)\n            if dist_f_t <= self.step_size:\n                return to\n            r = self.step_size / dist_f_t\n            return tuple(frm[d] + (to[d] - frm[d]) * r for d in range(dim))\n\n        def curvature_penalty(p_parent, p_curr, p_new):\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_curr[d] - p_parent[d] for d in range(dim))\n            v2 = tuple(p_new[d] - p_curr[d] for d in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[d]*v2[d] for d in range(dim)) / (len1 * len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        class SpatialGrid:\n            __slots__ = ('cell_size', 'dim', 'grid')\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self, pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self, node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self, node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self, pos, radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                result = []\n                rng = range(-cr, cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx, base[1]+dy)\n                            if cell in self.grid:\n                                result.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                if cell in self.grid:\n                                    result.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for node in result:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        diff = node.position[d] - pos[d]\n                        dist_sq += diff*diff\n                        if dist_sq > r2:\n                            break\n                    else:\n                        filtered.append(node)\n                return filtered\n            def nearest(self, pos):\n                base = self._hash(pos)\n                search_range = 0\n                candidates = []\n                max_search = 7\n                while not candidates and search_range <= max_search:\n                    rng = range(-search_range, search_range+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        candidates.extend(self.grid[cell])\n                    search_range += 1\n                if not candidates:\n                    return None\n                nearest_node = min(candidates, key=lambda n: math.dist(n.position,pos))\n                return nearest_node\n\n        def sample_uniform():\n            for _ in range(25):\n                p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d]+goal_pos[d])*0.5 for d in range(dim))\n            dvec = [(goal_pos[d]-start_pos[d]) / c_min for d in range(dim)]\n            basis = [dvec]\n            for i in range(1, dim):\n                v = [0.0]*dim\n                v[i] = 1.0\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j]-proj*b[j] for j in range(dim)]\n                normv = math.sqrt(sum(x*x for x in v))\n                basis.append([x/normv if normv>1e-14 else 0.0 for x in v])\n            r_long = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r_short = math.sqrt(max(0.0,val))*0.5 if dim > 1 else 0.0\n            radii = [r_long] + [r_short]*(dim-1)\n            for _ in range(35):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                unit_x = [x / norm_x for x in x_ball]\n                u = random.random()**(1/dim)\n                scaled = [radii[i]*unit_x[i]*u for i in range(dim)]\n                sample = [center[d] + sum(basis[i][d]*scaled[i] for i in range(dim)) for d in range(dim)]\n                sample = tuple(max(0.0, min(bounds[d], sample[d])) for d in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes < 2:\n                return self.base_radius\n            val = self.base_radius * (math.log(n_nodes+1) / (n_nodes+1))**(1/dim)\n            radius = max(self.min_radius, min(val, self.base_radius))\n            if c_best == float('inf'):\n                return radius\n            shrink_factor = c_best / (math.dist(start_pos, goal_pos) * 2.6)\n            return max(self.min_radius, radius * max(0.42, shrink_factor))\n\n        def choose_parent(nodes, grid, pos, radius, c_best):\n            neighbors = grid.query_radius(pos, radius)\n            candidates = []\n            for nb in neighbors:\n                if in_obstacle(pos) or edge_in_obstacle(nb.position, pos):\n                    continue\n                candidates.append(nb)\n            if not candidates:\n                nearest = grid.nearest(pos)\n                if nearest is None or in_obstacle(pos) or edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                candidates = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in candidates:\n                c = nb.cost + math.dist(nb.position, pos)\n                curv = curvature_penalty(nb.parent.position if nb.parent else None, nb.position, pos)\n                score = c + self.curvature_w * curv\n                if score < best_cost:\n                    best_cost = score\n                    best_parent = nb\n            if best_parent is None:\n                return None, []\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, candidates\n\n        def propagate_costs(node, grid):\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for ch in curr.children[:]:\n                    new_cost = curr.cost + math.dist(curr.position, ch.position)\n                    curv = curvature_penalty(curr.parent.position if curr.parent else None, curr.position, ch.position)\n                    new_score = new_cost + self.curvature_w * curv\n                    old_score = ch.cost + (self.curvature_w * curvature_penalty(ch.parent.parent.position if ch.parent and ch.parent.parent else None,\n                                                                               ch.parent.position if ch.parent else None, ch.position) if ch.parent else 0)\n                    if new_score + 1e-10 < old_score:\n                        if edge_in_obstacle(curr.position, ch.position):\n                            continue\n                        ch.cost = new_cost\n                        if ch.parent:\n                            ch.parent.remove_child(ch)\n                        curr.add_child(ch)\n                        stack.append(ch)\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                dist_new_nb = math.dist(new_node.position, nb.position)\n                new_cost = new_node.cost + dist_new_nb\n                if new_cost + 1e-12 >= nb.cost:\n                    continue\n                if edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, nb.position)\n                curv_old = curvature_penalty(nb.parent.parent.position if nb.parent and nb.parent.parent else None,\n                                            nb.parent.position if nb.parent else None, nb.position)\n                if self.curvature_w * curv_new > self.curvature_w * curv_old + self.max_curvature_increase:\n                    continue\n                if nb.parent is not None:\n                    nb.parent.remove_child(nb)\n                new_node.add_child(nb)\n                nb.cost = new_cost\n                propagate_costs(nb, grid)\n\n        def try_connect(tree_nodes, tree_grid, other_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_grid.nearest(other_node.position)\n            if nearest is None:\n                return None\n            dist_n_o = math.dist(nearest.position, other_node.position)\n            if dist_n_o <= self.step_size:\n                if edge_in_obstacle(nearest.position, other_node.position) or in_obstacle(other_node.position):\n                    return None\n                new_node = Node(other_node.position, parent=nearest, cost=nearest.cost+dist_n_o)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                return new_node\n            current = nearest\n            max_steps = int(math.ceil(dist_n_o / self.step_size))\n            for _ in range(max_steps):\n                new_pos = steer(current.position, other_node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos)):\n                    return None\n                dist_c_np = math.dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=current.cost+dist_c_np)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, other_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, other_node.position) or in_obstacle(other_node.position):\n                        return None\n                    final_node = Node(other_node.position, parent=current, cost=current.cost + math.dist(current.position, other_node.position))\n                    tree_nodes.append(final_node)\n                    tree_grid.insert(final_node)\n                    return final_node\n            return None\n\n        def prune_tree(nodes, grid, cost_limit):\n            remove_nodes = []\n            for n in nodes:\n                if n.cost > cost_limit:\n                    remove_nodes.append(n)\n            for n in remove_nodes:\n                if n.parent:\n                    n.parent.remove_child(n)\n                grid.remove(n)\n                if n in nodes:\n                    nodes.remove(n)\n            return len(remove_nodes)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _pass in range(self.shortcut_passes):\n                changed = True\n                attempts = 0\n                while changed and attempts < self.shortcut_attempts:\n                    changed = False\n                    attempts +=1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path)-3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1, p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        def smooth_path(path):\n            if len(path) < 4:\n                return list(path)\n            smoothed = list(path)\n            alpha = 0.2\n            for _ in range(12):\n                for i in range(1, len(smoothed)-1):\n                    prev_p, curr_p, next_p = smoothed[i-1], smoothed[i], smoothed[i+1]\n                    cand = tuple(curr_p[d] + alpha*(prev_p[d] + next_p[d] - 2*curr_p[d]) for d in range(dim))\n                    cand_clamped = tuple(max(0.0, min(bounds[d], cand[d])) for d in range(dim))\n                    if (not in_obstacle(cand_clamped) and not edge_in_obstacle(smoothed[i-1], cand_clamped) and not edge_in_obstacle(cand_clamped, smoothed[i+1])):\n                        smoothed[i] = cand_clamped\n            return smoothed\n\n        def combine_paths(start_node, goal_node, reverse_start):\n            path_start = start_node.path_from_root()\n            path_goal = goal_node.path_from_root()\n            if reverse_start:\n                path_start.reverse()\n                return path_goal + path_start[1:]\n            else:\n                path_goal.reverse()\n                return path_start + path_goal[1:]\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n                reverse_start = False\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n                reverse_start = True\n\n            r = random.random()\n            if r < self.goal_sample_prob:\n                sample_pt = sample_goal()\n            elif found_solution and r < self.goal_sample_prob + (1 - self.goal_sample_prob - self.uniform_sample_prob):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid_a.nearest(sample_pt)\n            if nearest is None:\n                if found_solution:\n                    no_improve_count +=1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            radius = adaptive_radius(len(tree_a), best_cost)\n            new_node, neighbors = choose_parent(tree_a, grid_a, new_pos, radius, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid_a)\n\n            connect_node = try_connect(tree_b, grid_b, new_node)\n            if connect_node:\n                candidate_path = combine_paths(new_node, connect_node, reverse_start)\n                total_cost = 0.0\n                for i in range(len(candidate_path) -1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i+1])\n                if total_cost + 1e-10 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                    prune_tree(start_tree, start_grid, best_cost * self.prune_cost_factor)\n                    prune_tree(goal_tree, goal_grid, best_cost * self.prune_cost_factor)\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count +=1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n            if found_solution and no_improve_count >= self.no_improve_limit:\n                break\n\n        if found_solution and len(best_path) > 3:\n            for _ in range(2):\n                best_path = shortcut_path(best_path)\n                best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path,\n                             nodes=start_tree + goal_tree,\n                             edges=[])",
                "objective": -16.63933,
                "time_improvement": 11.0,
                "length_improvement": 21.0,
                "smoothness_improvement": 144.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.041080904006958005,
                        "num_nodes_avg": 146.5,
                        "path_length_avg": 158.46380267697668,
                        "smoothness_avg": 0.011363521087994806,
                        "success_improvement": 0.0,
                        "time_improvement": -69.15860416942779,
                        "length_improvement": 13.143478733108138,
                        "smoothness_improvement": 77.86378130811885,
                        "objective_score": -12.47217510442286
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.042876386642456056,
                        "num_nodes_avg": 328.7,
                        "path_length_avg": 227.64070257196983,
                        "smoothness_avg": 0.010340296617776489,
                        "success_improvement": 0.0,
                        "time_improvement": 73.44544222797897,
                        "length_improvement": 24.00698120715365,
                        "smoothness_improvement": 166.0632797899999,
                        "objective_score": 37.26813779163587
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.034953069686889646,
                        "num_nodes_avg": 322.3,
                        "path_length_avg": 112.03768757082898,
                        "smoothness_avg": 0.022686976836790572,
                        "success_improvement": 0.0,
                        "time_improvement": 29.417298572494648,
                        "length_improvement": 25.589902576830166,
                        "smoothness_improvement": 188.57667078553754,
                        "objective_score": 25.122014471774182
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "cross_over",
            "algorithm_description": "A bidirectional informed RRT* planner with dynamically scaled neighbor radius based on sample density and cost, efficient spatial hashing for fast nearest and neighbor lookups, curvature-penalized cost for smoothness, iterative rewiring with cost improvement propagation, focused informed sampling after initial solution, adaptive pruning to maintain tree compactness, and enhanced multi-pass adaptive shortcutting and smoothing employing curvature-aware node updates. Early stopping on stagnation and improved parent choosing considering combined cost-curvature measure lead to faster convergence to shorter, smoother paths.",
            "planning_mechanism": "A bidirectional RRT* that alternately grows start and goal trees, efficiently finding near neighbors via spatial hashing with dynamically scaled radii supporting rewiring and cost propagation; it employs an ellipsoidal informed sampler once a solution is found to expedite convergence. Curvature penalties are integrated in parent choosing and rewiring steps for smoothness, complemented by adaptive multi-pass shortcutting and smoothing including curvature-based node adjustments. The planner prunes nodes exceeding adaptively updated cost thresholds to limit search space growth and uses stagnation detection to stop early, achieving improved path length and reduced planning times.",
            "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        p = []\n        n = self\n        while n:\n            p.append(n.position)\n            n = n.parent\n        return p[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=4.5,\n                 base_radius=20.0,\n                 min_radius=3.5,\n                 time_limit=10.0,\n                 no_improve_limit=40,\n                 shortcut_passes=4,\n                 shortcut_attempts=400,\n                 uniform_sample_prob=0.12,\n                 goal_sample_prob=0.06,\n                 grid_cell_size=12.0,\n                 curvature_w=0.07,\n                 max_curv_increase=0.12,\n                 prune_factor=1.6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_prob = uniform_sample_prob\n        self.goal_sample_prob = goal_sample_prob\n        self.grid_cell_size = grid_cell_size\n        self.curvature_w = curvature_w\n        self.max_curv_increase = max_curv_increase\n        self.prune_factor = prune_factor\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,) * (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a,b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(3, int(dist_ab / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d]) * i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            r = self.step_size / dist\n            return tuple(frm[d] + (to[d]-frm[d])*r for d in range(dim))\n\n        def curvature_penalty(p_parent, p_curr, p_new):\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_curr[d]-p_parent[d] for d in range(dim))\n            v2 = tuple(p_new[d]-p_curr[d] for d in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-16 or len2 < 1e-16:\n                return 0.0\n            dot = sum(v1[d]*v2[d] for d in range(dim)) / (len1 * len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        class SpatialGrid:\n            __slots__ = ('cell_size','dim','grid')\n            def __init__(self,bounds,cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self,pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self,node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self,node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self,pos,radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                candidates = []\n                rng = range(-cr,cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx, base[1]+dy)\n                            if cell in self.grid:\n                                candidates.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for n in candidates:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        diff = n.position[d] - pos[d]\n                        dist_sq += diff*diff\n                        if dist_sq > r2:\n                            break\n                    else:\n                        filtered.append(n)\n                return filtered\n            def nearest(self,pos):\n                base = self._hash(pos)\n                rng_lim = 8\n                search_r = 0\n                cand = []\n                while not cand and search_r <= rng_lim:\n                    rng = range(-search_r,search_r+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    cand.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        cand.extend(self.grid[cell])\n                    search_r += 1\n                if not cand:\n                    return None\n                nearest_node = min(cand, key=lambda n: math.dist(n.position,pos))\n                return nearest_node\n\n        def sample_uniform():\n            for _ in range(20):\n                p = tuple(random.uniform(0.0,bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0.0,bounds[d]) for d in range(dim))\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-14:\n                return sample_uniform()\n            center = tuple((start_pos[d]+goal_pos[d])*0.5 for d in range(dim))\n            dvec = [(goal_pos[d]-start_pos[d]) / c_min for d in range(dim)]\n            basis = [dvec]\n            for i in range(1,dim):\n                v = [0.0]*dim\n                v[i] = 1.0\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j]-proj*b[j] for j in range(dim)]\n                normv = math.sqrt(sum(x*x for x in v))\n                basis.append([x/normv if normv>1e-14 else 0.0 for x in v])\n            r_long = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r_short = math.sqrt(max(0.0,val))*0.5 if dim>1 else 0.0\n            radii = [r_long] + [r_short]*(dim-1)\n            for _ in range(30):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                unit_x = [x / norm_x for x in x_ball]\n                u = random.random()**(1/dim)\n                scaled = [radii[i]*unit_x[i]*u for i in range(dim)]\n                sample = [center[d] + sum(basis[i][d]*scaled[i] for i in range(dim)) for d in range(dim)]\n                sample = tuple(max(0.0,min(bounds[d], sample[d])) for d in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def neighbor_radius(n_nodes, c_best):\n            if n_nodes < 2:\n                return self.base_radius\n            val = self.base_radius * (math.log(n_nodes+1)/(n_nodes+1))**(1/dim)\n            radius = max(self.min_radius, min(val, self.base_radius))\n            if c_best == float('inf'):\n                return radius\n            shrinkf = c_best / (math.dist(start_pos, goal_pos)*2.5)\n            return max(self.min_radius, radius * max(0.38, shrinkf))\n\n        def choose_parent(nodes, grid, pos, radius, c_best):\n            neighbors = grid.query_radius(pos, radius)\n            good_neighbors = []\n            for nb in neighbors:\n                if in_obstacle(pos) or edge_in_obstacle(nb.position, pos):\n                    continue\n                good_neighbors.append(nb)\n            if not good_neighbors:\n                nearest = grid.nearest(pos)\n                if nearest is None or in_obstacle(pos) or edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                good_neighbors = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in good_neighbors:\n                dist_ = math.dist(nb.position, pos)\n                c = nb.cost + dist_\n                curv = curvature_penalty(nb.parent.position if nb.parent else None, nb.position, pos)\n                score = c + self.curvature_w*curv\n                if score < best_cost:\n                    best_cost = score\n                    best_parent = nb\n            if best_parent is None:\n                return None, []\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, good_neighbors\n\n        def propagate_costs(node,grid):\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for ch in curr.children[:]:\n                    new_cost = curr.cost + math.dist(curr.position, ch.position)\n                    curv = curvature_penalty(curr.parent.position if curr.parent else None, curr.position, ch.position)\n                    new_score = new_cost + self.curvature_w*curv\n                    old_score = ch.cost + (self.curvature_w*curvature_penalty(ch.parent.parent.position if ch.parent and ch.parent.parent else None,\n                                                                            ch.parent.position if ch.parent else None, ch.position) if ch.parent else 0)\n                    if new_score + 1e-11 < old_score:\n                        if edge_in_obstacle(curr.position, ch.position):\n                            continue\n                        ch.cost = new_cost\n                        if ch.parent:\n                            ch.parent.remove_child(ch)\n                        curr.add_child(ch)\n                        stack.append(ch)\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb is new_node.parent:\n                    continue\n                dist_ = math.dist(new_node.position, nb.position)\n                new_cost = new_node.cost + dist_\n                if new_cost + 1e-12 >= nb.cost:\n                    continue\n                if edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, nb.position)\n                curv_old = curvature_penalty(nb.parent.parent.position if nb.parent and nb.parent.parent else None,\n                                            nb.parent.position if nb.parent else None, nb.position)\n                if self.curvature_w*curv_new > self.curvature_w*curv_old + self.max_curv_increase:\n                    continue\n                if nb.parent is not None:\n                    nb.parent.remove_child(nb)\n                new_node.add_child(nb)\n                nb.cost = new_cost\n                propagate_costs(nb, grid)\n\n        def try_connect(tree_nodes, tree_grid, other_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_grid.nearest(other_node.position)\n            if nearest is None:\n                return None\n            dist_no = math.dist(nearest.position, other_node.position)\n            if dist_no <= self.step_size:\n                if edge_in_obstacle(nearest.position, other_node.position) or in_obstacle(other_node.position):\n                    return None\n                new_node = Node(other_node.position, parent=nearest, cost=nearest.cost + dist_no)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                return new_node\n            current = nearest\n            max_steps = int(math.ceil(dist_no/self.step_size))\n            for _ in range(max_steps):\n                new_pos = steer(current.position, other_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                dist_cnp = math.dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=current.cost + dist_cnp)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, other_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, other_node.position) or in_obstacle(other_node.position):\n                        return None\n                    final_node = Node(other_node.position, parent=current, cost=current.cost + math.dist(current.position, other_node.position))\n                    tree_nodes.append(final_node)\n                    tree_grid.insert(final_node)\n                    return final_node\n            return None\n\n        def prune_tree(nodes, grid, cost_limit):\n            to_remove = [n for n in nodes if n.cost > cost_limit]\n            for n in to_remove:\n                if n.parent:\n                    n.parent.remove_child(n)\n                grid.remove(n)\n                if n in nodes:\n                    nodes.remove(n)\n            return len(to_remove)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _ in range(self.shortcut_passes):\n                changed = True\n                attempts = 0\n                while changed and attempts < self.shortcut_attempts:\n                    changed = False\n                    attempts += 1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path)-3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1,p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        def smooth_path(path):\n            if len(path) < 4:\n                return list(path)\n            smoothed = list(path)\n            alpha = 0.22\n            for _ in range(14):\n                for i in range(1, len(smoothed)-1):\n                    prev_p, curr_p, next_p = smoothed[i-1], smoothed[i], smoothed[i+1]\n                    cand = tuple(curr_p[d] + alpha*(prev_p[d]+next_p[d]-2*curr_p[d]) for d in range(dim))\n                    cand_clamped = tuple(max(0.0,min(bounds[d], cand[d])) for d in range(dim))\n                    if (not in_obstacle(cand_clamped) and not edge_in_obstacle(smoothed[i-1], cand_clamped)\n                        and not edge_in_obstacle(cand_clamped, smoothed[i+1])):\n                        smoothed[i] = cand_clamped\n            return smoothed\n\n        def combine_paths(snode, gnode, reverse_start):\n            pstart = snode.path_from_root()\n            pgoal = gnode.path_from_root()\n            if reverse_start:\n                pstart.reverse()\n                return pgoal + pstart[1:]\n            else:\n                pgoal.reverse()\n                return pstart + pgoal[1:]\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found = False\n        no_improve = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n                rev_start = False\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n                rev_start = True\n\n            r = random.random()\n            if r < self.goal_sample_prob:\n                sample_pt = sample_goal()\n            elif found and r < self.goal_sample_prob + (1 - self.goal_sample_prob - self.uniform_sample_prob):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid_a.nearest(sample_pt)\n            if nearest is None:\n                if found:\n                    no_improve +=1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            radius = neighbor_radius(len(tree_a), best_cost)\n            new_node, neighbors = choose_parent(tree_a, grid_a, new_pos, radius, best_cost)\n            if new_node is None:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid_a)\n\n            conn_node = try_connect(tree_b, grid_b, new_node)\n            if conn_node:\n                candidate = combine_paths(new_node, conn_node, rev_start)\n                cost_cand = 0.0\n                for i in range(len(candidate)-1):\n                    cost_cand += math.dist(candidate[i], candidate[i+1])\n                if cost_cand + 1e-11 < best_cost:\n                    best_cost = cost_cand\n                    best_path = candidate\n                    found = True\n                    no_improve = 0\n                    prune_tree(start_tree, start_grid, best_cost*self.prune_factor)\n                    prune_tree(goal_tree, goal_grid, best_cost*self.prune_factor)\n                else:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n            else:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n\n            if found and no_improve >= self.no_improve_limit:\n                break\n\n        if found and len(best_path) > 3:\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n                best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found, path=best_path,\n                             nodes=start_tree+goal_tree,\n                             edges=[])",
            "objective": -11.31881,
            "time_improvement": -13.0,
            "length_improvement": 24.0,
            "smoothness_improvement": 215.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.047393965721130374,
                    "num_nodes_avg": 134.6,
                    "path_length_avg": 146.99009020142267,
                    "smoothness_avg": 0.013619690044331782,
                    "success_improvement": 0.0,
                    "time_improvement": -95.15386239022978,
                    "length_improvement": 19.43240235356819,
                    "smoothness_improvement": 113.17772482409802,
                    "objective_score": -16.32082868080753
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.058544158935546875,
                    "num_nodes_avg": 352.1,
                    "path_length_avg": 219.06274328066283,
                    "smoothness_avg": 0.0147639358316728,
                    "success_improvement": 0.0,
                    "time_improvement": 63.741948134944124,
                    "length_improvement": 26.87055092146022,
                    "smoothness_improvement": 279.88670298208984,
                    "objective_score": 36.64434850826982
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.05396511554718018,
                    "num_nodes_avg": 434.3,
                    "path_length_avg": 112.77420988956904,
                    "smoothness_avg": 0.027750346540338443,
                    "success_improvement": 0.0,
                    "time_improvement": -8.974795984689827,
                    "length_improvement": 25.10073952214698,
                    "smoothness_improvement": 252.9823596755917,
                    "objective_score": 13.632916716259198
                }
            ],
            "success_rate": 1.0
        },
        "objective": 13.2,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Use of fixed or less adaptive neighbor radius limiting effective rewiring and exploration.\n   - Insufficient or less effective smoothing and shortcutting passes reducing final path quality.\n   - Conservative curvature penalty weighting possibly rejecting better parent choices leading to longer paths.\n   - Higher step sizes causing suboptimal sampling granularity and less precise connections.\n   - Potential overhead from less aggressive pruning and cost propagation limiting convergence speed."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - More dynamically scaled neighbor radius enabling better rewiring and parent selection.\n   - Increased smoothing and shortcutting iterations improving path refinement.\n   - Slightly higher curvature penalty weight guiding smoother and more optimal parent choices.\n   - Slightly smaller step size allowing finer control and higher path resolution.\n   - More aggressive pruning thresholds reducing tree size and focusing search on promising regions.\n2. Expected mechanism of impact:\n   - Dynamically adapting neighbor radius balances exploration and exploitation, leading to shorter paths.\n   - Enhanced smoothing and shortcutting more effectively remove unnecessary waypoints and reduce path length.\n   - Improved curvature-aware parent choosing reduces path bends while preserving efficient routes.\n   - Finer incremental steps reduce overshooting and improve connection accuracy.\n   - Pruning limits computational overhead, helping the planner focus on shorter path regions and converge faster."
        }
    },
    {
        "parents": [
            {
                "operator": "cross_over",
                "algorithm_description": "A bidirectional informed RRT* planner with dynamically scaled neighbor radius based on sample density and cost, efficient spatial hashing for fast nearest and neighbor lookups, curvature-penalized cost for smoothness, iterative rewiring with cost improvement propagation, focused informed sampling after initial solution, adaptive pruning to maintain tree compactness, and enhanced multi-pass adaptive shortcutting and smoothing employing curvature-aware node updates. Early stopping on stagnation and improved parent choosing considering combined cost-curvature measure lead to faster convergence to shorter, smoother paths.",
                "planning_mechanism": "A bidirectional RRT* that alternately grows start and goal trees, efficiently finding near neighbors via spatial hashing with dynamically scaled radii supporting rewiring and cost propagation; it employs an ellipsoidal informed sampler once a solution is found to expedite convergence. Curvature penalties are integrated in parent choosing and rewiring steps for smoothness, complemented by adaptive multi-pass shortcutting and smoothing including curvature-based node adjustments. The planner prunes nodes exceeding adaptively updated cost thresholds to limit search space growth and uses stagnation detection to stop early, achieving improved path length and reduced planning times.",
                "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        p = []\n        n = self\n        while n:\n            p.append(n.position)\n            n = n.parent\n        return p[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=4.5,\n                 base_radius=20.0,\n                 min_radius=3.5,\n                 time_limit=10.0,\n                 no_improve_limit=40,\n                 shortcut_passes=4,\n                 shortcut_attempts=400,\n                 uniform_sample_prob=0.12,\n                 goal_sample_prob=0.06,\n                 grid_cell_size=12.0,\n                 curvature_w=0.07,\n                 max_curv_increase=0.12,\n                 prune_factor=1.6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_prob = uniform_sample_prob\n        self.goal_sample_prob = goal_sample_prob\n        self.grid_cell_size = grid_cell_size\n        self.curvature_w = curvature_w\n        self.max_curv_increase = max_curv_increase\n        self.prune_factor = prune_factor\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,) * (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a,b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(3, int(dist_ab / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d]) * i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            r = self.step_size / dist\n            return tuple(frm[d] + (to[d]-frm[d])*r for d in range(dim))\n\n        def curvature_penalty(p_parent, p_curr, p_new):\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_curr[d]-p_parent[d] for d in range(dim))\n            v2 = tuple(p_new[d]-p_curr[d] for d in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-16 or len2 < 1e-16:\n                return 0.0\n            dot = sum(v1[d]*v2[d] for d in range(dim)) / (len1 * len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        class SpatialGrid:\n            __slots__ = ('cell_size','dim','grid')\n            def __init__(self,bounds,cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self,pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self,node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self,node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self,pos,radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                candidates = []\n                rng = range(-cr,cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx, base[1]+dy)\n                            if cell in self.grid:\n                                candidates.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for n in candidates:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        diff = n.position[d] - pos[d]\n                        dist_sq += diff*diff\n                        if dist_sq > r2:\n                            break\n                    else:\n                        filtered.append(n)\n                return filtered\n            def nearest(self,pos):\n                base = self._hash(pos)\n                rng_lim = 8\n                search_r = 0\n                cand = []\n                while not cand and search_r <= rng_lim:\n                    rng = range(-search_r,search_r+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    cand.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        cand.extend(self.grid[cell])\n                    search_r += 1\n                if not cand:\n                    return None\n                nearest_node = min(cand, key=lambda n: math.dist(n.position,pos))\n                return nearest_node\n\n        def sample_uniform():\n            for _ in range(20):\n                p = tuple(random.uniform(0.0,bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0.0,bounds[d]) for d in range(dim))\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-14:\n                return sample_uniform()\n            center = tuple((start_pos[d]+goal_pos[d])*0.5 for d in range(dim))\n            dvec = [(goal_pos[d]-start_pos[d]) / c_min for d in range(dim)]\n            basis = [dvec]\n            for i in range(1,dim):\n                v = [0.0]*dim\n                v[i] = 1.0\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j]-proj*b[j] for j in range(dim)]\n                normv = math.sqrt(sum(x*x for x in v))\n                basis.append([x/normv if normv>1e-14 else 0.0 for x in v])\n            r_long = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r_short = math.sqrt(max(0.0,val))*0.5 if dim>1 else 0.0\n            radii = [r_long] + [r_short]*(dim-1)\n            for _ in range(30):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                unit_x = [x / norm_x for x in x_ball]\n                u = random.random()**(1/dim)\n                scaled = [radii[i]*unit_x[i]*u for i in range(dim)]\n                sample = [center[d] + sum(basis[i][d]*scaled[i] for i in range(dim)) for d in range(dim)]\n                sample = tuple(max(0.0,min(bounds[d], sample[d])) for d in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def neighbor_radius(n_nodes, c_best):\n            if n_nodes < 2:\n                return self.base_radius\n            val = self.base_radius * (math.log(n_nodes+1)/(n_nodes+1))**(1/dim)\n            radius = max(self.min_radius, min(val, self.base_radius))\n            if c_best == float('inf'):\n                return radius\n            shrinkf = c_best / (math.dist(start_pos, goal_pos)*2.5)\n            return max(self.min_radius, radius * max(0.38, shrinkf))\n\n        def choose_parent(nodes, grid, pos, radius, c_best):\n            neighbors = grid.query_radius(pos, radius)\n            good_neighbors = []\n            for nb in neighbors:\n                if in_obstacle(pos) or edge_in_obstacle(nb.position, pos):\n                    continue\n                good_neighbors.append(nb)\n            if not good_neighbors:\n                nearest = grid.nearest(pos)\n                if nearest is None or in_obstacle(pos) or edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                good_neighbors = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in good_neighbors:\n                dist_ = math.dist(nb.position, pos)\n                c = nb.cost + dist_\n                curv = curvature_penalty(nb.parent.position if nb.parent else None, nb.position, pos)\n                score = c + self.curvature_w*curv\n                if score < best_cost:\n                    best_cost = score\n                    best_parent = nb\n            if best_parent is None:\n                return None, []\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, good_neighbors\n\n        def propagate_costs(node,grid):\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for ch in curr.children[:]:\n                    new_cost = curr.cost + math.dist(curr.position, ch.position)\n                    curv = curvature_penalty(curr.parent.position if curr.parent else None, curr.position, ch.position)\n                    new_score = new_cost + self.curvature_w*curv\n                    old_score = ch.cost + (self.curvature_w*curvature_penalty(ch.parent.parent.position if ch.parent and ch.parent.parent else None,\n                                                                            ch.parent.position if ch.parent else None, ch.position) if ch.parent else 0)\n                    if new_score + 1e-11 < old_score:\n                        if edge_in_obstacle(curr.position, ch.position):\n                            continue\n                        ch.cost = new_cost\n                        if ch.parent:\n                            ch.parent.remove_child(ch)\n                        curr.add_child(ch)\n                        stack.append(ch)\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb is new_node.parent:\n                    continue\n                dist_ = math.dist(new_node.position, nb.position)\n                new_cost = new_node.cost + dist_\n                if new_cost + 1e-12 >= nb.cost:\n                    continue\n                if edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, nb.position)\n                curv_old = curvature_penalty(nb.parent.parent.position if nb.parent and nb.parent.parent else None,\n                                            nb.parent.position if nb.parent else None, nb.position)\n                if self.curvature_w*curv_new > self.curvature_w*curv_old + self.max_curv_increase:\n                    continue\n                if nb.parent is not None:\n                    nb.parent.remove_child(nb)\n                new_node.add_child(nb)\n                nb.cost = new_cost\n                propagate_costs(nb, grid)\n\n        def try_connect(tree_nodes, tree_grid, other_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_grid.nearest(other_node.position)\n            if nearest is None:\n                return None\n            dist_no = math.dist(nearest.position, other_node.position)\n            if dist_no <= self.step_size:\n                if edge_in_obstacle(nearest.position, other_node.position) or in_obstacle(other_node.position):\n                    return None\n                new_node = Node(other_node.position, parent=nearest, cost=nearest.cost + dist_no)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                return new_node\n            current = nearest\n            max_steps = int(math.ceil(dist_no/self.step_size))\n            for _ in range(max_steps):\n                new_pos = steer(current.position, other_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                dist_cnp = math.dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=current.cost + dist_cnp)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, other_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, other_node.position) or in_obstacle(other_node.position):\n                        return None\n                    final_node = Node(other_node.position, parent=current, cost=current.cost + math.dist(current.position, other_node.position))\n                    tree_nodes.append(final_node)\n                    tree_grid.insert(final_node)\n                    return final_node\n            return None\n\n        def prune_tree(nodes, grid, cost_limit):\n            to_remove = [n for n in nodes if n.cost > cost_limit]\n            for n in to_remove:\n                if n.parent:\n                    n.parent.remove_child(n)\n                grid.remove(n)\n                if n in nodes:\n                    nodes.remove(n)\n            return len(to_remove)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _ in range(self.shortcut_passes):\n                changed = True\n                attempts = 0\n                while changed and attempts < self.shortcut_attempts:\n                    changed = False\n                    attempts += 1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path)-3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1,p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        def smooth_path(path):\n            if len(path) < 4:\n                return list(path)\n            smoothed = list(path)\n            alpha = 0.22\n            for _ in range(14):\n                for i in range(1, len(smoothed)-1):\n                    prev_p, curr_p, next_p = smoothed[i-1], smoothed[i], smoothed[i+1]\n                    cand = tuple(curr_p[d] + alpha*(prev_p[d]+next_p[d]-2*curr_p[d]) for d in range(dim))\n                    cand_clamped = tuple(max(0.0,min(bounds[d], cand[d])) for d in range(dim))\n                    if (not in_obstacle(cand_clamped) and not edge_in_obstacle(smoothed[i-1], cand_clamped)\n                        and not edge_in_obstacle(cand_clamped, smoothed[i+1])):\n                        smoothed[i] = cand_clamped\n            return smoothed\n\n        def combine_paths(snode, gnode, reverse_start):\n            pstart = snode.path_from_root()\n            pgoal = gnode.path_from_root()\n            if reverse_start:\n                pstart.reverse()\n                return pgoal + pstart[1:]\n            else:\n                pgoal.reverse()\n                return pstart + pgoal[1:]\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found = False\n        no_improve = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n                rev_start = False\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n                rev_start = True\n\n            r = random.random()\n            if r < self.goal_sample_prob:\n                sample_pt = sample_goal()\n            elif found and r < self.goal_sample_prob + (1 - self.goal_sample_prob - self.uniform_sample_prob):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid_a.nearest(sample_pt)\n            if nearest is None:\n                if found:\n                    no_improve +=1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            radius = neighbor_radius(len(tree_a), best_cost)\n            new_node, neighbors = choose_parent(tree_a, grid_a, new_pos, radius, best_cost)\n            if new_node is None:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid_a)\n\n            conn_node = try_connect(tree_b, grid_b, new_node)\n            if conn_node:\n                candidate = combine_paths(new_node, conn_node, rev_start)\n                cost_cand = 0.0\n                for i in range(len(candidate)-1):\n                    cost_cand += math.dist(candidate[i], candidate[i+1])\n                if cost_cand + 1e-11 < best_cost:\n                    best_cost = cost_cand\n                    best_path = candidate\n                    found = True\n                    no_improve = 0\n                    prune_tree(start_tree, start_grid, best_cost*self.prune_factor)\n                    prune_tree(goal_tree, goal_grid, best_cost*self.prune_factor)\n                else:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n            else:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n\n            if found and no_improve >= self.no_improve_limit:\n                break\n\n        if found and len(best_path) > 3:\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n                best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found, path=best_path,\n                             nodes=start_tree+goal_tree,\n                             edges=[])",
                "objective": -11.31881,
                "time_improvement": -13.0,
                "length_improvement": 24.0,
                "smoothness_improvement": 215.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.047393965721130374,
                        "num_nodes_avg": 134.6,
                        "path_length_avg": 146.99009020142267,
                        "smoothness_avg": 0.013619690044331782,
                        "success_improvement": 0.0,
                        "time_improvement": -95.15386239022978,
                        "length_improvement": 19.43240235356819,
                        "smoothness_improvement": 113.17772482409802,
                        "objective_score": -16.32082868080753
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.058544158935546875,
                        "num_nodes_avg": 352.1,
                        "path_length_avg": 219.06274328066283,
                        "smoothness_avg": 0.0147639358316728,
                        "success_improvement": 0.0,
                        "time_improvement": 63.741948134944124,
                        "length_improvement": 26.87055092146022,
                        "smoothness_improvement": 279.88670298208984,
                        "objective_score": 36.64434850826982
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.05396511554718018,
                        "num_nodes_avg": 434.3,
                        "path_length_avg": 112.77420988956904,
                        "smoothness_avg": 0.027750346540338443,
                        "success_improvement": 0.0,
                        "time_improvement": -8.974795984689827,
                        "length_improvement": 25.10073952214698,
                        "smoothness_improvement": 252.9823596755917,
                        "objective_score": 13.632916716259198
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "path_expert",
            "algorithm_description": "A bidirectional RRT* planner with fixed-radius neighbor search to improve local rewiring consistency, strict cost-based parent selection minimizing path length, balanced sampling between uniform, goal, and informed sampling to avoid local minima and accelerate convergence, early termination upon stagnation to reduce planning time, incremental rewiring with efficient collision checks, and extended multi-pass shortcutting and smoothing for shorter, smoother paths. This approach avoids aggressive pruning and dynamic radius shrinking, promoting globally optimized shorter paths with improved planning efficiency.",
            "planning_mechanism": "A bidirectional RRT* planner alternates growth between start and goal trees using a fixed neighbor radius for stable connectivity. Parent selection chooses minimal cost neighbors within radius ensuring locally optimal attachments. Sampling combines uniform, goal bias, and ellipsoidal informed samples after initial solution for balanced exploration and exploitation. Rewiring propagates cost improvements, and early stop occurs on stagnation. Post-planning applies multiple shortcutting and smoothing passes to produce short, smooth paths efficiently.",
            "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=2500,\n                 step_size=5.0,\n                 neighbor_radius=15.0,\n                 time_limit=10.0,\n                 no_improve_limit=30,\n                 shortcut_passes=6,\n                 shortcut_attempts=500,\n                 uniform_sample_prob=0.2,\n                 goal_sample_prob=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_prob = uniform_sample_prob\n        self.goal_sample_prob = goal_sample_prob\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,) * (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a,b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(3, int(dist_ab / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d]) * i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            r = self.step_size / dist\n            return tuple(frm[d] + (to[d]-frm[d])*r for d in range(dim))\n\n        class SpatialGrid:\n            __slots__ = ('cell_size','dim','grid')\n            def __init__(self,bounds,cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self,pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self,node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self,node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self,pos,radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                candidates = []\n                rng = range(-cr,cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx, base[1]+dy)\n                            if cell in self.grid:\n                                candidates.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for n in candidates:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        diff = n.position[d] - pos[d]\n                        dist_sq += diff*diff\n                        if dist_sq > r2:\n                            break\n                    else:\n                        filtered.append(n)\n                return filtered\n            def nearest(self,pos):\n                base = self._hash(pos)\n                rng_lim = 10\n                search_r = 0\n                cand = []\n                while not cand and search_r <= rng_lim:\n                    rng = range(-search_r,search_r+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    cand.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        cand.extend(self.grid[cell])\n                    search_r += 1\n                if not cand:\n                    return None\n                nearest_node = min(cand, key=lambda n: math.dist(n.position,pos))\n                return nearest_node\n\n        def sample_uniform():\n            for _ in range(30):\n                p = tuple(random.uniform(0.0,bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0.0,bounds[d]) for d in range(dim))\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-14:\n                return sample_uniform()\n            center = tuple((start_pos[d]+goal_pos[d])*0.5 for d in range(dim))\n            dvec = [(goal_pos[d]-start_pos[d]) / c_min for d in range(dim)]\n            basis = [dvec]\n            for i in range(1,dim):\n                v = [0.0]*dim\n                v[i] = 1.0\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j]-proj*b[j] for j in range(dim)]\n                normv = math.sqrt(sum(x*x for x in v))\n                basis.append([x/normv if normv>1e-14 else 0.0 for x in v])\n            r_long = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r_short = math.sqrt(max(0.0,val))*0.5 if dim>1 else 0.0\n            radii = [r_long] + [r_short]*(dim-1)\n            for _ in range(40):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                unit_x = [x / norm_x for x in x_ball]\n                u = random.random()**(1/dim)\n                scaled = [radii[i]*unit_x[i]*u for i in range(dim)]\n                sample = [center[d] + sum(basis[i][d]*scaled[i] for i in range(dim)) for d in range(dim)]\n                sample = tuple(max(0.0,min(bounds[d], sample[d])) for d in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def choose_parent(nodes, grid, pos, radius):\n            neighbors = grid.query_radius(pos, radius)\n            good_neighbors = []\n            for nb in neighbors:\n                if in_obstacle(pos) or edge_in_obstacle(nb.position, pos):\n                    continue\n                good_neighbors.append(nb)\n            if not good_neighbors:\n                nearest = grid.nearest(pos)\n                if nearest is None or in_obstacle(pos) or edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                good_neighbors = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in good_neighbors:\n                c = nb.cost + math.dist(nb.position, pos)\n                if c < best_cost:\n                    best_cost = c\n                    best_parent = nb\n            if best_parent is None:\n                return None, []\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, good_neighbors\n\n        def propagate_costs(node,grid):\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for ch in curr.children[:]:\n                    new_cost = curr.cost + math.dist(curr.position, ch.position)\n                    if new_cost + 1e-12 < ch.cost:\n                        if edge_in_obstacle(curr.position, ch.position):\n                            continue\n                        ch.cost = new_cost\n                        if ch.parent:\n                            ch.parent.remove_child(ch)\n                        curr.add_child(ch)\n                        stack.append(ch)\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb is new_node.parent:\n                    continue\n                dist_ = math.dist(new_node.position, nb.position)\n                new_cost = new_node.cost + dist_\n                if new_cost + 1e-12 >= nb.cost:\n                    continue\n                if edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                if nb.parent is not None:\n                    nb.parent.remove_child(nb)\n                new_node.add_child(nb)\n                nb.cost = new_cost\n                propagate_costs(nb, grid)\n\n        def try_connect(tree_nodes, tree_grid, other_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_grid.nearest(other_node.position)\n            if nearest is None:\n                return None\n            dist_no = math.dist(nearest.position, other_node.position)\n            if dist_no <= self.step_size:\n                if edge_in_obstacle(nearest.position, other_node.position) or in_obstacle(other_node.position):\n                    return None\n                new_node = Node(other_node.position, parent=nearest, cost=nearest.cost + dist_no)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                return new_node\n            current = nearest\n            max_steps = int(math.ceil(dist_no/self.step_size))\n            for _ in range(max_steps):\n                new_pos = steer(current.position, other_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                dist_cnp = math.dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=current.cost + dist_cnp)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, other_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, other_node.position) or in_obstacle(other_node.position):\n                        return None\n                    final_node = Node(other_node.position, parent=current, cost=current.cost + math.dist(current.position, other_node.position))\n                    tree_nodes.append(final_node)\n                    tree_grid.insert(final_node)\n                    return final_node\n            return None\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _ in range(self.shortcut_passes):\n                changed = True\n                attempts = 0\n                while changed and attempts < self.shortcut_attempts:\n                    changed = False\n                    attempts += 1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path)-3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1,p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        def smooth_path(path):\n            if len(path) < 4:\n                return list(path)\n            smoothed = list(path)\n            alpha = 0.22\n            for _ in range(20):\n                for i in range(1, len(smoothed)-1):\n                    prev_p, curr_p, next_p = smoothed[i-1], smoothed[i], smoothed[i+1]\n                    cand = tuple(curr_p[d] + alpha*(prev_p[d]+next_p[d]-2*curr_p[d]) for d in range(dim))\n                    cand_clamped = tuple(max(0.0,min(bounds[d], cand[d])) for d in range(dim))\n                    if (not in_obstacle(cand_clamped) and not edge_in_obstacle(smoothed[i-1], cand_clamped)\n                        and not edge_in_obstacle(cand_clamped, smoothed[i+1])):\n                        smoothed[i] = cand_clamped\n            return smoothed\n\n        def combine_paths(snode, gnode, reverse_start):\n            pstart = snode.path_from_root()\n            pgoal = gnode.path_from_root()\n            if reverse_start:\n                pstart.reverse()\n                return pgoal + pstart[1:]\n            else:\n                pgoal.reverse()\n                return pstart + pgoal[1:]\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialGrid(bounds, self.neighbor_radius*0.75)\n        goal_grid = SpatialGrid(bounds, self.neighbor_radius*0.75)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found = False\n        no_improve = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            # Alternate trees\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n                rev_start = False\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n                rev_start = True\n\n            r = random.random()\n            if r < self.goal_sample_prob:\n                sample_pt = sample_goal()\n            elif found and r < self.goal_sample_prob + (1 - self.goal_sample_prob - self.uniform_sample_prob):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid_a.nearest(sample_pt)\n            if nearest is None:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            new_node, neighbors = choose_parent(tree_a, grid_a, new_pos, self.neighbor_radius)\n            if new_node is None:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid_a)\n\n            conn_node = try_connect(tree_b, grid_b, new_node)\n            if conn_node:\n                candidate = combine_paths(new_node, conn_node, rev_start)\n                cost_cand = 0.0\n                for i in range(len(candidate)-1):\n                    cost_cand += math.dist(candidate[i], candidate[i+1])\n                if cost_cand + 1e-11 < best_cost:\n                    best_cost = cost_cand\n                    best_path = candidate\n                    found = True\n                    no_improve = 0\n                else:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n            else:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n\n            if found and no_improve >= self.no_improve_limit:\n                break\n\n        if found and len(best_path) > 3:\n            for _ in range(4):\n                best_path = shortcut_path(best_path)\n                best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found, path=best_path, nodes=start_tree+goal_tree, edges=[])",
            "objective": 15.07987,
            "time_improvement": -108.0,
            "length_improvement": 23.0,
            "smoothness_improvement": 711.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.08491573333740235,
                    "num_nodes_avg": 147.6,
                    "path_length_avg": 146.67545264996258,
                    "smoothness_avg": 0.02461913743788308,
                    "success_improvement": 0.0,
                    "time_improvement": -249.657030939373,
                    "length_improvement": 19.60486018127452,
                    "smoothness_improvement": 285.34296221549454,
                    "objective_score": -61.707478361969706
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0883143663406372,
                    "num_nodes_avg": 289.0,
                    "path_length_avg": 223.23869095650394,
                    "smoothness_avg": 0.04821963224132819,
                    "success_improvement": 0.0,
                    "time_improvement": 45.30441749562633,
                    "length_improvement": 25.47649938927517,
                    "smoothness_improvement": 1140.7258687666322,
                    "objective_score": 34.58085422608617
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.10864276885986328,
                    "num_nodes_avg": 328.8,
                    "path_length_avg": 115.00662291698129,
                    "smoothness_avg": 0.06340760577908858,
                    "success_improvement": 0.0,
                    "time_improvement": -119.38845959413591,
                    "length_improvement": 23.618077085424666,
                    "smoothness_improvement": 706.5400652473944,
                    "objective_score": -18.112991300748998
                }
            ],
            "success_rate": 1.0
        },
        "objective": 14.2,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Inefficient adaptive neighbor radius shrinking limited exploration, causing longer detours and suboptimal path length.\n   - Curvature penalty as a heuristic was loosely integrated, resulting in initial sharp turns that required extensive post-processing smoothing.\n   - Aggressive pruning potentially discarded beneficial nodes early, restricting global path optimization.\n   - Multiple expensive spatial queries with variable radius increased planning overhead.\n   - Complex cost computations including curvature penalty added computational load without proportional path quality gains."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Use of fixed-radius neighbor search promoting stable rewiring and consistent local optimization.\n   - Simplified and stricter parent selection focused on minimal path cost without curvature penalty, improving global path length.\n   - Balanced sampling strategy incorporating uniform, goal bias, and informed sampling to enhance exploration and convergence.\n   - Early termination criteria that avoided excessive planning after stagnation, improving computational efficiency.\n   - Enhanced multi-pass shortcutting and smoothing applied systematically post-planning to produce smoother and shorter paths.\n2. Expected mechanism of impact:\n   - Fixed-radius neighbor search stabilized rewiring, reducing redundant or inefficient rewires and promoting better connectivity.\n   - Eliminating curvature penalty in parent selection allowed the planner to find shorter paths more directly, reducing path length.\n   - Balanced sampling avoided local minima and focused exploration in promising regions, accelerating path improvement.\n   - Early stopping reduced wasted iterations on non-improving paths, lowering planning times.\n   - Extensive post-planning path refinement improved smoothness and length without complicating the main planning loop."
        }
    },
    {
        "parents": [
            {
                "operator": "cross_over",
                "algorithm_description": "A Bidirectional Adaptive Informed RRT* planner integrating spatial hashing for accelerated nearest neighbor search, dynamic adaptive rewiring with curvature-aware cost propagation, integrated pruning of suboptimal nodes to constrain tree size, and an enhanced multi-pass shortcutting and curvature-aware smoothing during planning and post-processing. The planner balances exploration and informed focused sampling within ellipsoidal regions shrinking with best path cost, alternates tree expansions from start and goal, and aggressively optimizes path length and smoothness while controlling computational cost via pruning and efficient collision checks.",
                "planning_mechanism": "The planner maintains two trees grown alternately from start and goal positions. Sampling shifts from uniform to ellipsoidal informed sampling focused around the current best solution, with fallback uniform sampling. Spatial hashing accelerates nearest and neighbor searches allowing efficient adaptive rewiring within a radius that diminishes with tree size and best path cost. New nodes integrate curvature penalties directly into cost evaluation to favor smooth transitions. Rewiring triggers downstream cost propagation and curvature checks to enhance smoothness. Suboptimal branches exceeding cost and curvature thresholds are pruned dynamically to reduce overhead. Finally, multi-pass shortcutting and curvature-aware smoothing\u2014executed both during planning and after termination\u2014refine the extracted path into a shorter, smoother trajectory while ensuring collision-free continuity. Early stopping occurs based on improvement stagnation or time limit, resulting in robust, efficient planning with high-quality paths.",
                "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 base_radius=20.0,\n                 min_radius=5.0,\n                 time_limit=15.0,\n                 no_improve_limit=60,\n                 shortcut_passes=5,\n                 shortcut_attempts=400,\n                 uniform_sample_prob=0.1,\n                 goal_sample_prob=0.08,\n                 grid_cell_size=15.0,\n                 curvature_w=0.06,\n                 max_curvature_increase=0.12,\n                 prune_cost_factor=1.8):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_prob = uniform_sample_prob\n        self.goal_sample_prob = goal_sample_prob\n        self.grid_cell_size = grid_cell_size\n        self.curvature_w = curvature_w\n        self.max_curvature_increase = max_curvature_increase\n        self.prune_cost_factor = prune_cost_factor\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,) * (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a,b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_f_t = math.dist(frm, to)\n            if dist_f_t <= self.step_size:\n                return to\n            r = self.step_size / dist_f_t\n            return tuple(frm[d] + (to[d] - frm[d]) * r for d in range(dim))\n\n        # Curvature penalty: angle between vectors (parent->current) and (current->new)\n        def curvature_penalty(p_parent, p_curr, p_new):\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_curr[d] - p_parent[d] for d in range(dim))\n            v2 = tuple(p_new[d] - p_curr[d] for d in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[d]*v2[d] for d in range(dim)) / (len1 * len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        # Spatial hashing for fast neighbor queries\n        class SpatialGrid:\n            __slots__ = ('cell_size', 'dim', 'grid')\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self, pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self, node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self, node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self, pos, radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                result = []\n                rng = range(-cr, cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx, base[1]+dy)\n                            if cell in self.grid:\n                                result.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                if cell in self.grid:\n                                    result.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for node in result:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        diff = node.position[d] - pos[d]\n                        dist_sq += diff*diff\n                        if dist_sq > r2:\n                            break\n                    else:\n                        filtered.append(node)\n                return filtered\n            def nearest(self, pos):\n                base = self._hash(pos)\n                search_range = 0\n                candidates = []\n                max_search = 8\n                while not candidates and search_range <= max_search:\n                    rng = range(-search_range, search_range+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        candidates.extend(self.grid[cell])\n                    search_range += 1\n                if not candidates:\n                    return None\n                nearest_node = min(candidates, key=lambda n: math.dist(n.position,pos))\n                return nearest_node\n\n        # Sampling methods\n        def sample_uniform():\n            for _ in range(30):\n                p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d]+goal_pos[d])*0.5 for d in range(dim))\n            # Unit vector from start to goal:\n            dvec = [(goal_pos[d]-start_pos[d]) / c_min for d in range(dim)]\n            # Build orthonormal basis\n            basis = [dvec]\n            for i in range(1, dim):\n                v = [0.0]*dim\n                v[i] = 1.0\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j]-proj*b[j] for j in range(dim)]\n                normv = math.sqrt(sum(x*x for x in v))\n                basis.append([x/normv if normv>1e-14 else 0.0 for x in v])\n            r_long = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r_short = math.sqrt(max(0.0,val))*0.5 if dim > 1 else 0.0\n            radii = [r_long] + [r_short]*(dim-1)\n            for _ in range(40):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                unit_x = [x / norm_x for x in x_ball]\n                u = random.random()**(1/dim)\n                scaled = [radii[i]*unit_x[i]*u for i in range(dim)]\n                sample = [center[d] + sum(basis[i][d]*scaled[i] for i in range(dim)) for d in range(dim)]\n                sample = tuple(max(0.0, min(bounds[d], sample[d])) for d in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes < 2:\n                return self.base_radius\n            val = self.base_radius * (math.log(n_nodes+1) / (n_nodes+1))**(1/dim)\n            radius = max(self.min_radius, min(val, self.base_radius))\n            if c_best == float('inf'):\n                return radius\n            # Shrink radius with best solution cost to focus rewiring locally\n            shrink_factor = c_best / (math.dist(start_pos, goal_pos) * 2.8)\n            return max(self.min_radius, radius * max(0.4, shrink_factor))\n\n        def choose_parent(nodes, grid, pos, radius, c_best):\n            neighbors = grid.query_radius(pos, radius)\n            candidates = []\n            for nb in neighbors:\n                if in_obstacle(pos) or edge_in_obstacle(nb.position, pos):\n                    continue\n                candidates.append(nb)\n            if not candidates:\n                nearest = grid.nearest(pos)\n                if nearest is None or in_obstacle(pos) or edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                candidates = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in candidates:\n                c = nb.cost + math.dist(nb.position, pos)\n                curv = curvature_penalty(nb.parent.position if nb.parent else None, nb.position, pos)\n                score = c + self.curvature_w * curv\n                if score < best_cost:\n                    best_cost = score\n                    best_parent = nb\n            if best_parent is None:\n                return None, []\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, candidates\n\n        def propagate_costs(node, grid):\n            # DFS propagate improved costs downstream\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for ch in curr.children[:]:\n                    new_cost = curr.cost + math.dist(curr.position, ch.position)\n                    curv = curvature_penalty(curr.parent.position if curr.parent else None, curr.position, ch.position)\n                    new_score = new_cost + self.curvature_w * curv\n                    old_score = ch.cost + (self.curvature_w * curvature_penalty(ch.parent.parent.position if ch.parent and ch.parent.parent else None, ch.parent.position if ch.parent else None, ch.position) if ch.parent else 0)\n                    if new_score + 1e-10 < old_score:\n                        if edge_in_obstacle(curr.position, ch.position):\n                            continue\n                        ch.cost = new_cost\n                        ch.parent.remove_child(ch)\n                        curr.add_child(ch)\n                        stack.append(ch)\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                dist_new_nb = math.dist(new_node.position, nb.position)\n                new_cost = new_node.cost + dist_new_nb\n                if new_cost + 1e-12 >= nb.cost:\n                    continue\n                if edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                # Curvature penalty with parent-child relation check\n                curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, nb.position)\n                curv_old = curvature_penalty(nb.parent.parent.position if nb.parent and nb.parent.parent else None,\n                                            nb.parent.position if nb.parent else None, nb.position)\n                if self.curvature_w * curv_new > self.curvature_w * curv_old + self.max_curvature_increase:\n                    continue\n                if nb.parent is not None:\n                    nb.parent.remove_child(nb)\n                new_node.add_child(nb)\n                nb.cost = new_cost\n                propagate_costs(nb, grid)\n\n        def try_connect(tree_nodes, tree_grid, other_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_grid.nearest(other_node.position)\n            if nearest is None:\n                return None\n            dist_n_o = math.dist(nearest.position, other_node.position)\n            if dist_n_o <= self.step_size:\n                if edge_in_obstacle(nearest.position, other_node.position) or in_obstacle(other_node.position):\n                    return None\n                new_node = Node(other_node.position, parent=nearest, cost=nearest.cost+dist_n_o)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                return new_node\n            current = nearest\n            max_steps = int(math.ceil(dist_n_o / self.step_size))\n            for _ in range(max_steps):\n                new_pos = steer(current.position, other_node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos)):\n                    return None\n                dist_c_np = math.dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=current.cost+dist_c_np)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, other_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, other_node.position) or in_obstacle(other_node.position):\n                        return None\n                    final_node = Node(other_node.position, parent=current, cost=current.cost + math.dist(current.position, other_node.position))\n                    tree_nodes.append(final_node)\n                    tree_grid.insert(final_node)\n                    return final_node\n            return None\n\n        # Prune nodes that are far above best_path cost to keep tree small\n        def prune_tree(nodes, grid, cost_limit):\n            remove_nodes = []\n            for n in nodes:\n                if n.cost > cost_limit:\n                    remove_nodes.append(n)\n            for n in remove_nodes:\n                # Remove from parent's children list\n                if n.parent:\n                    n.parent.remove_child(n)\n                # Remove from grid and nodes list\n                grid.remove(n)\n                if n in nodes:\n                    nodes.remove(n)\n                # Post removal descendants are unreachable, no direct deletion here (could be improved)\n            return len(remove_nodes)\n\n        # Shortcutting path by removing intermediate nodes with collision-free chords\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _pass in range(self.shortcut_passes):\n                changed = True\n                attempts = 0\n                while changed and attempts < self.shortcut_attempts:\n                    changed = False\n                    attempts +=1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path)-3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1, p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        # Curvature-aware smoothing by iterative averaging during and after planning\n        def smooth_path(path):\n            if len(path) < 4:\n                return list(path)\n            smoothed = list(path)\n            alpha = 0.17\n            for _ in range(9):\n                for i in range(1, len(smoothed)-1):\n                    prev_p, curr_p, next_p = smoothed[i-1], smoothed[i], smoothed[i+1]\n                    new_pt = tuple(curr_p[d] + alpha*(prev_p[d] + next_p[d] - 2*curr_p[d]) for d in range(dim))\n                    # Clamp and collision check\n                    new_pt = tuple(max(0.0, min(bounds[d], new_pt[d])) for d in range(dim))\n                    if (not in_obstacle(new_pt) and not edge_in_obstacle(smoothed[i-1], new_pt) and not edge_in_obstacle(new_pt, smoothed[i+1])):\n                        smoothed[i] = new_pt\n            return smoothed\n\n        # Extract combined path from start_node to goal_node by reversing one branch and concatenating\n        def combine_paths(start_node, goal_node, reverse_start):\n            path_start = start_node.path_from_root()\n            path_goal = goal_node.path_from_root()\n            if reverse_start:\n                # path_start reversed, so goal_node tree is forward\n                path_start.reverse()\n                full_path = path_goal + path_start[1:]\n            else:\n                # start_node forward, goal_node reversed\n                path_goal.reverse()\n                full_path = path_start + path_goal[1:]\n            return full_path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n        start_time = time.time()\n        c_min = math.dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n                reverse_start = False\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n                reverse_start = True\n\n            r = random.random()\n            if r < self.goal_sample_prob:\n                sample_pt = sample_goal()\n            elif found_solution and r < self.goal_sample_prob + (1 - self.goal_sample_prob - self.uniform_sample_prob):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid_a.nearest(sample_pt)\n            if nearest is None:\n                if found_solution:\n                    no_improve_count +=1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            radius = adaptive_radius(len(tree_a), best_cost)\n            new_node, neighbors = choose_parent(tree_a, grid_a, new_pos, radius, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid_a)\n\n            connect_node = try_connect(tree_b, grid_b, new_node)\n            if connect_node:\n                candidate_path = combine_paths(new_node, connect_node, reverse_start)\n                total_cost = 0.0\n                for i in range(len(candidate_path) -1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i+1])\n                if total_cost + 1e-10 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                    # Prune both trees aggressively to trim nodes far away from best cost\n                    cost_limit = best_cost * self.prune_cost_factor\n                    prune_tree(start_tree, start_grid, cost_limit)\n                    prune_tree(goal_tree, goal_grid, cost_limit)\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count +=1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n            # Early abort if improvement stagnates heavily\n            if found_solution and no_improve_count >= self.no_improve_limit:\n                break\n\n        if found_solution and len(best_path) > 3:\n            # Multi-pass shortcutting and smoothing post-planning\n            for _ in range(2):\n                best_path = shortcut_path(best_path)\n                best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path,\n                             nodes=start_tree + goal_tree,\n                             edges=[])",
                "objective": -21.94032,
                "time_improvement": 27.0,
                "length_improvement": 21.0,
                "smoothness_improvement": 218.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.033988142013549806,
                        "num_nodes_avg": 152.2,
                        "path_length_avg": 155.0029124627248,
                        "smoothness_avg": 0.013386992872664144,
                        "success_improvement": 0.0,
                        "time_improvement": -39.95277855498452,
                        "length_improvement": 15.040447500854501,
                        "smoothness_improvement": 109.53550877750344,
                        "objective_score": -2.413887522095137
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.03955721855163574,
                        "num_nodes_avg": 342.0,
                        "path_length_avg": 225.80758202741654,
                        "smoothness_avg": 0.014658329875318548,
                        "success_improvement": 0.0,
                        "time_improvement": 75.50109681374721,
                        "length_improvement": 24.618929608374863,
                        "smoothness_improvement": 277.16938566019917,
                        "objective_score": 38.80753373745007
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.027274346351623534,
                        "num_nodes_avg": 269.3,
                        "path_length_avg": 113.89325843043791,
                        "smoothness_avg": 0.02886494217452123,
                        "success_improvement": 0.0,
                        "time_improvement": 44.923376904744714,
                        "length_improvement": 24.357520764667115,
                        "smoothness_improvement": 267.15993387150496,
                        "objective_score": 29.427325199581208
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "path_expert",
            "algorithm_description": "An Enhanced Bidirectional Curvature-Aware Informed RRT* Planner with Efficient Spatial Hashing, Cost-Driven Adaptive Rewiring, Strategic Node Pruning, and Integrated Multi-Stage Shortcutting and Progressive Smoothing applied both intermittently during planning and in post-processing to deliver superior path length minimization, smoothness, and computational efficiency. The planner dynamically adjusts its sampling domain and rewiring radius based on the current best cost, leverages curvature penalties consistently in cost updates and rewiring decisions for smooth transitions, accelerates neighbor searches via spatial hashing, purges suboptimal nodes to keep trees lean, and continuously improves solution quality through phased shortcutting and smoothing passes. It alternately grows two trees from start and goal, attempts connection by incrementally approaching sampled points, and aggressively prunes and optimizes to converge rapidly to shorter, smoother collision-free paths within a time budget.",
            "planning_mechanism": "This planner implements a bidirectional RRT* with informed and adaptive sampling that focuses search regions to ellipsoidal domains based on the best path length found so far. A spatial hash accelerates neighbor queries allowing adaptive rewiring with curvature penalties consistently incorporated into cost evaluations. It prunes subtrees exceeding acceptable cost thresholds to bound computational load. Connections between start and goal trees are incrementally built and rewired. Multi-stage shortcutting and curvature-guided smoothing are performed not only after planning but also intermittently during planning iterations, yielding progressively shorter and smoother paths. Early stopping occurs on stagnation of improvements.",
            "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4500,\n                 step_size=5.0,\n                 base_radius=18.0,\n                 min_radius=5.0,\n                 time_limit=15.0,\n                 no_improve_limit=60,\n                 shortcut_passes=6,\n                 shortcut_attempts=500,\n                 uniform_sample_prob=0.07,\n                 goal_sample_prob=0.09,\n                 grid_cell_size=14.0,\n                 curvature_w=0.075,\n                 max_curvature_increase=0.11,\n                 prune_cost_factor=1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_prob = uniform_sample_prob\n        self.goal_sample_prob = goal_sample_prob\n        self.grid_cell_size = grid_cell_size\n        self.curvature_w = curvature_w\n        self.max_curvature_increase = max_curvature_increase\n        self.prune_cost_factor = prune_cost_factor\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,) * (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a,b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(3, int(dist_ab / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            r = self.step_size / dist\n            return tuple(frm[d] + (to[d] - frm[d]) * r for d in range(dim))\n\n        def curvature_penalty(p_parent, p_curr, p_new):\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_curr[d] - p_parent[d] for d in range(dim))\n            v2 = tuple(p_new[d] - p_curr[d] for d in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[d]*v2[d] for d in range(dim)) / (len1 * len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        class SpatialGrid:\n            __slots__ = ('cell_size', 'dim', 'grid')\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self, pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self, node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self, node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self, pos, radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                result = []\n                rng = range(-cr, cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx, base[1]+dy)\n                            if cell in self.grid:\n                                result.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                if cell in self.grid:\n                                    result.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for node in result:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        diff = node.position[d] - pos[d]\n                        dist_sq += diff*diff\n                        if dist_sq > r2:\n                            break\n                    else:\n                        filtered.append(node)\n                return filtered\n            def nearest(self, pos):\n                base = self._hash(pos)\n                search_range = 0\n                candidates = []\n                max_search = 8\n                while not candidates and search_range <= max_search:\n                    rng = range(-search_range, search_range+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        candidates.extend(self.grid[cell])\n                    search_range += 1\n                if not candidates:\n                    return None\n                nearest_node = min(candidates, key=lambda n: math.dist(n.position,pos))\n                return nearest_node\n\n        # Sampling:\n        def sample_uniform():\n            for _ in range(30):\n                p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d]+goal_pos[d])*0.5 for d in range(dim))\n            dvec = [(goal_pos[d]-start_pos[d]) / c_min for d in range(dim)]\n            basis = [dvec]\n            for i in range(1, dim):\n                v = [0.0]*dim\n                v[i] = 1.0\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j] - proj*b[j] for j in range(dim)]\n                normv = math.sqrt(sum(x*x for x in v))\n                if normv > 1e-14:\n                    basis.append([x/normv for x in v])\n                else:\n                    basis.append([0.0]*dim)\n            r_long = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r_short = math.sqrt(max(0.0,val)) * 0.5 if dim > 1 else 0.0\n            radii = [r_long] + [r_short]*(dim-1)\n            for _ in range(40):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                unit_x = [x / norm_x for x in x_ball]\n                u = random.random()**(1/dim)\n                scaled = [radii[i]*unit_x[i]*u for i in range(dim)]\n                sample = [center[d] + sum(basis[i][d]*scaled[i] for i in range(dim)) for d in range(dim)]\n                sample = tuple(max(0.0, min(bounds[d], sample[d])) for d in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes < 2:\n                return self.base_radius\n            val = self.base_radius * (math.log(n_nodes+1) / (n_nodes+1))**(1/dim)\n            radius = max(self.min_radius, min(val, self.base_radius))\n            if c_best == float('inf'):\n                return radius\n            shrink_factor = c_best / (math.dist(start_pos, goal_pos) * 2.6)\n            return max(self.min_radius, radius * max(0.35, shrink_factor))\n\n        def choose_parent(nodes, grid, pos, radius, c_best):\n            if in_obstacle(pos):\n                return None, []\n            neighbors = grid.query_radius(pos, radius)\n            candidates = []\n            for nb in neighbors:\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                candidates.append(nb)\n            if not candidates:\n                nearest = grid.nearest(pos)\n                if nearest is None or edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                candidates = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in candidates:\n                dist_nb_to_pos = math.dist(nb.position, pos)\n                c = nb.cost + dist_nb_to_pos\n                curv = curvature_penalty(nb.parent.position if nb.parent else None, nb.position, pos)\n                score = c + self.curvature_w * curv\n                if score < best_cost:\n                    best_cost = score\n                    best_parent = nb\n            if best_parent is None:\n                return None, []\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, candidates\n\n        def propagate_costs(root):\n            # Propagate improved cost downstream through BFS\n            queue = [root]\n            while queue:\n                curr = queue.pop(0)\n                for ch in curr.children[:]:\n                    dist = math.dist(curr.position, ch.position)\n                    new_cost = curr.cost + dist\n                    curv = curvature_penalty(curr.parent.position if curr.parent else None, curr.position, ch.position)\n                    new_score = new_cost + self.curvature_w * curv\n                    old_curv = 0.0\n                    if ch.parent:\n                        grandp = ch.parent.parent if ch.parent.parent else None\n                        old_curv = curvature_penalty(grandp.position if grandp else None, ch.parent.position if ch.parent else None, ch.position)\n                    old_score = ch.cost + self.curvature_w * old_curv\n                    if new_score + 1e-10 < old_score:\n                        if edge_in_obstacle(curr.position, ch.position):\n                            continue\n                        ch.cost = new_cost\n                        if ch.parent is not None:\n                            ch.parent.remove_child(ch)\n                        curr.add_child(ch)\n                        queue.append(ch)\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                dist_new_nb = math.dist(new_node.position, nb.position)\n                new_cost = new_node.cost + dist_new_nb\n                if new_cost + 1e-12 >= nb.cost:\n                    continue\n                if edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, nb.position)\n                grandp_nb = nb.parent.parent if nb.parent and nb.parent.parent else None\n                curv_old = curvature_penalty(grandp_nb.position if grandp_nb else None,\n                                            nb.parent.position if nb.parent else None, nb.position)\n                if self.curvature_w * curv_new > self.curvature_w * curv_old + self.max_curvature_increase:\n                    continue\n                if nb.parent is not None:\n                    nb.parent.remove_child(nb)\n                new_node.add_child(nb)\n                nb.cost = new_cost\n                propagate_costs(nb)\n\n        def try_connect(tree_nodes, tree_grid, other_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_grid.nearest(other_node.position)\n            if nearest is None:\n                return None\n            dist_n_o = math.dist(nearest.position, other_node.position)\n            if dist_n_o <= self.step_size:\n                if edge_in_obstacle(nearest.position, other_node.position) or in_obstacle(other_node.position):\n                    return None\n                new_node = Node(other_node.position, parent=nearest, cost=nearest.cost+dist_n_o)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                return new_node\n            current = nearest\n            max_steps = int(math.ceil(dist_n_o / self.step_size))\n            for _ in range(max_steps):\n                new_pos = steer(current.position, other_node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos)):\n                    return None\n                dist_c_np = math.dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=current.cost+dist_c_np)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, other_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, other_node.position) or in_obstacle(other_node.position):\n                        return None\n                    final_node = Node(other_node.position, parent=current, cost=current.cost + math.dist(current.position, other_node.position))\n                    tree_nodes.append(final_node)\n                    tree_grid.insert(final_node)\n                    return final_node\n            return None\n\n        def prune_tree(nodes, grid, cost_limit):\n            to_remove = []\n            for n in nodes:\n                if n.cost > cost_limit:\n                    to_remove.append(n)\n            for n in to_remove:\n                if n.parent:\n                    n.parent.remove_child(n)\n                grid.remove(n)\n                if n in nodes:\n                    nodes.remove(n)\n            return len(to_remove)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _ in range(self.shortcut_passes):\n                attempts = 0\n                changed = True\n                while changed and attempts < self.shortcut_attempts:\n                    changed = False\n                    attempts += 1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path)-3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1, p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        def smooth_path(path, passes=9, alpha=0.16):\n            if len(path) < 4:\n                return list(path)\n            smoothed = list(path)\n            for _ in range(passes):\n                for i in range(1, len(smoothed)-1):\n                    prev_p, curr_p, next_p = smoothed[i-1], smoothed[i], smoothed[i+1]\n                    new_pt = tuple(curr_p[d] + alpha*(prev_p[d] + next_p[d] - 2*curr_p[d]) for d in range(dim))\n                    new_pt = tuple(max(0.0, min(bounds[d], new_pt[d])) for d in range(dim))\n                    if (not in_obstacle(new_pt) and not edge_in_obstacle(smoothed[i-1], new_pt) and not edge_in_obstacle(new_pt, smoothed[i+1])):\n                        smoothed[i] = new_pt\n            return smoothed\n\n        def combine_paths(start_node, goal_node, reverse_start):\n            path_start = start_node.path_from_root()\n            path_goal = goal_node.path_from_root()\n            if reverse_start:\n                path_start.reverse()\n                full = path_goal + path_start[1:]\n            else:\n                path_goal.reverse()\n                full = path_start + path_goal[1:]\n            return full\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n                reverse_start = False\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n                reverse_start = True\n\n            r = random.random()\n            if r < self.goal_sample_prob:\n                sample_pt = sample_goal()\n            elif found_solution and r < self.goal_sample_prob + (1 - self.goal_sample_prob - self.uniform_sample_prob):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid_a.nearest(sample_pt)\n            if nearest is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if (not in_bounds(new_pos)\n                or in_obstacle(new_pos)\n                or edge_in_obstacle(nearest.position, new_pos)):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            radius = adaptive_radius(len(tree_a), best_cost)\n            new_node, neighbors = choose_parent(tree_a, grid_a, new_pos, radius, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid_a)\n\n            connect_node = try_connect(tree_b, grid_b, new_node)\n            if connect_node is not None:\n                candidate_path = combine_paths(new_node, connect_node, reverse_start)\n                total_dist = 0.0\n                for i in range(len(candidate_path)-1):\n                    total_dist += math.dist(candidate_path[i], candidate_path[i+1])\n                if total_dist + 1e-12 < best_cost:\n                    best_cost = total_dist\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                    # Aggressive pruning with tighter cost limit to keep tree focused\n                    prune_limit = best_cost * self.prune_cost_factor\n                    prune_tree(start_tree, start_grid, prune_limit)\n                    prune_tree(goal_tree, goal_grid, prune_limit)\n                    # Intermittent shortcut & smoothing to improve path progressively during planning\n                    if len(best_path) > 3 and it % 300 == 0:\n                        best_path = shortcut_path(best_path)\n                        best_path = smooth_path(best_path, passes=6, alpha=0.14)\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n        if found_solution and len(best_path) > 3:\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n                best_path = smooth_path(best_path, passes=12, alpha=0.15)\n\n        return PlannerResult(success=found_solution, path=best_path,\n                             nodes=start_tree + goal_tree,\n                             edges=[])",
            "objective": -4.10729,
            "time_improvement": -38.0,
            "length_improvement": 23.0,
            "smoothness_improvement": 319.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.053756332397460936,
                    "num_nodes_avg": 188.1,
                    "path_length_avg": 152.38513704254513,
                    "smoothness_avg": 0.016298340276333628,
                    "success_improvement": 0.0,
                    "time_improvement": -121.35214337255364,
                    "length_improvement": 16.475291689961022,
                    "smoothness_improvement": 155.10441773700654,
                    "objective_score": -25.74494590910444
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04884722232818604,
                    "num_nodes_avg": 359.3,
                    "path_length_avg": 218.89731647139757,
                    "smoothness_avg": 0.022614113916076473,
                    "success_improvement": 0.0,
                    "time_improvement": 69.74753497459669,
                    "length_improvement": 26.925775151939664,
                    "smoothness_improvement": 481.8774393485239,
                    "objective_score": 39.489112780285424
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.07991161346435546,
                    "num_nodes_avg": 499.3,
                    "path_length_avg": 111.93431610469949,
                    "smoothness_avg": 0.03291795103995011,
                    "success_improvement": 0.0,
                    "time_improvement": -61.37001998026046,
                    "length_improvement": 25.658556982613113,
                    "smoothness_improvement": 318.713907477765,
                    "objective_score": -1.4223022671214454
                }
            ],
            "success_rate": 1.0
        },
        "objective": 12.999999999999998,
        "analysis": {
            "problem": [
                ""
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - More aggressive and adaptive pruning with tighter cost thresholds kept the search focused and trees compact.\n   - Consistent and enhanced curvature penalty incorporation in cost and rewiring evaluations improved path smoothness and reduced length.\n   - Intermittent shortcutting and smoothing during planning iterations progressively refined the path, accelerating convergence.\n   - Increased iteration limit and refined sampling probabilities balanced exploration and exploitation more effectively.\n   - Use of efficient spatial hashing enabled faster neighbor queries, facilitating adaptive rewiring and pruning.\n\n2. Expected mechanism of impact:\n   - Maintaining smaller, focused trees through aggressive pruning reduced computational burden and improved search efficiency.\n   - Applying curvature penalties uniformly ensured smoother transitions between nodes, reducing unnecessary detours.\n   - Progressive path optimization during planning leveraged early intermediate solutions, leading to shorter final paths.\n   - Adjusted sampling strategies and extended planning iterations allowed better coverage of promising regions.\n   - Faster neighbor lookups enabled timely rewiring and pruning decisions, further enhancing path quality and planning speed."
        }
    },
    {
        "parents": [
            {
                "operator": "m3",
                "algorithm_description": "A simplified bidirectional RRT* planner with adaptive neighbor radius and progressive informed sampling that grows two trees from start and goal alternately. It selects parents minimizing cost within a neighborhood, rewires neighbors to improve path cost, and attempts connection between trees each iteration. After finding a path, it performs shortcutting smoothing and additionally applies a simple path smoothing by averaging non-endpoints to reduce sharp turns, improving path smoothness while maintaining collision-free guarantee. The algorithm balances exploration and exploitation, adapts neighborhood radius with node growth and best cost, and terminates early after stagnation to improve efficiency.",
                "planning_mechanism": "A bidirectional RRT* planner grows two trees alternately using uniform sampling initially and informed ellipsoidal sampling after first solution. Nodes are added by steering and choosing cheapest parent in a shrinking radius. Nearby nodes are rewired to reduce cost. Trees are connected by nearest node attempts. After search, shortcutting randomly removes unnecessary waypoints and a smoothing pass applies local averaging to reduce sharp turns, validated for collision.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=5.0,\n                 radius_max=25.0,\n                 radius_min=5.0,\n                 max_no_improve=50,\n                 shortcut_iter=200,\n                 smoothing_iter=3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius_max = radius_max\n        self.radius_min = radius_min\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n        self.smoothing_iter = smoothing_iter\n\n    def plan(self, map):\n        import math\n        import random\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size / dist\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        def dist_sq(a, b):\n            return sum((a[d] - b[d]) ** 2 for d in range(dim))\n\n        def neighbors(tree, point, radius):\n            rad_sq = radius * radius\n            res = []\n            for node in tree:\n                if dist_sq(node.position, point) <= rad_sq:\n                    res.append(node)\n            return res\n\n        def adaptive_radius(num_nodes, best_cost):\n            if num_nodes <= 1:\n                return self.radius_max\n            base = (math.log(num_nodes + 1) / (num_nodes + 1)) ** (1 / dim)\n            r = self.radius_max * base\n            if best_cost != float('inf'):\n                r = max(self.radius_min, min(r, best_cost * 0.5))\n            return max(self.radius_min, min(r, self.radius_max))\n\n        def choose_parent(tree, new_pos, radius):\n            nbrs = neighbors(tree, new_pos, radius)\n            valid_parents = [n for n in nbrs if not edge_in_obstacle(n.position, new_pos)]\n            if not valid_parents:\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None or in_obstacle(new_pos):\n                    return None, []\n                cost = nearest.cost + nearest_dist\n                new_node = Node(new_pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda p: p.cost + math.dist(p.position, new_pos))\n            cost_min = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=cost_min)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb is pivot.parent:\n                    continue\n                if edge_in_obstacle(pivot.position, nb.position):\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree_from, target_node):\n            if not tree_from:\n                return None\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, target_node.position))\n            dist_near = math.dist(nearest.position, target_node.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_from.append(new_node)\n                return new_node\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos)):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_from.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree_from.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = [(goal_pos[d] - start_pos[d]) / c_min for d in range(dim)]\n            r1 = c_best * 0.5\n            val = max(c_best * c_best - c_min * c_min, 0.0)\n            r_other = math.sqrt(val) * 0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u, v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1, 0, 0) if abs(a1[0]) < 0.9 else (0, 1, 0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0, 0, 1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(d):\n                while True:\n                    vec = [random.gauss(0, 1) for _ in range(d)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random() ** (1/d)\n                    return [v*r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            i = 0\n            while i < len(path) - 2 and i < self.shortcut_iter:\n                j = len(path) - 1\n                improved = False\n                while j > i + 1:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        improved = True\n                        break\n                    j -= 1\n                if not improved:\n                    i += 1\n            return path\n\n        def smooth_path(path):\n            # Basic smoothing by multiple passes of averaging internal points if collision free\n            if len(path) < 3:\n                return path[:]\n            from math import dist\n\n            smoothed = path[:]\n            for _ in range(self.smoothing_iter):\n                new_path = [smoothed[0]]\n                for i in range(1, len(smoothed)-1):\n                    prev_p = new_path[-1]\n                    next_p = smoothed[i+1]\n                    avg_point = tuple( (smoothed[i][d]*0.5 + prev_p[d]*0.25 + next_p[d]*0.25) for d in range(dim))\n                    if in_bounds(avg_point) and not in_obstacle(avg_point) and not edge_in_obstacle(prev_p, avg_point) and not edge_in_obstacle(avg_point, next_p):\n                        new_path.append(avg_point)\n                    else:\n                        new_path.append(smoothed[i])\n                new_path.append(smoothed[-1])\n                smoothed = new_path\n            return smoothed\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                if random.random() < 0.15:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_n = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_n.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_n.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            radius = adaptive_radius(len(nodes), best_cost)\n            new_node, nbrs = choose_parent(tree_a, new_pos, radius)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node:\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n                total_cost = 0.0\n                for i in range(len(candidate_path)-1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i+1])\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n            best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
                "objective": -21.92154,
                "time_improvement": 9.0,
                "length_improvement": 17.0,
                "smoothness_improvement": 1816.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.040337014198303225,
                        "num_nodes_avg": 129.1,
                        "path_length_avg": 160.3712825882546,
                        "smoothness_avg": 0.048995934883907806,
                        "success_improvement": 0.0,
                        "time_improvement": -66.09549334629224,
                        "length_improvement": 12.097958767783277,
                        "smoothness_improvement": 666.8927773086906,
                        "objective_score": -9.235408856674253
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.05174868106842041,
                        "num_nodes_avg": 235.1,
                        "path_length_avg": 234.19924186299787,
                        "smoothness_avg": 0.12374451768937537,
                        "success_improvement": 0.0,
                        "time_improvement": 67.95057959253103,
                        "length_improvement": 21.81755201472203,
                        "smoothness_improvement": 3084.0355697210757,
                        "objective_score": 48.8958829351979
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.03655681610107422,
                        "num_nodes_avg": 204.2,
                        "path_length_avg": 126.07552323955561,
                        "smoothness_avg": 0.14136138750583652,
                        "success_improvement": 0.0,
                        "time_improvement": 26.178763149659375,
                        "length_improvement": 16.26664053556356,
                        "smoothness_improvement": 1698.1064148619935,
                        "objective_score": 26.104145340545916
                    }
                ],
                "success_rate": 1.0
            },
            {
                "operator": "m2",
                "algorithm_description": "A bidirectional RRT* planner with a simplified fixed neighbor radius for reliable rewiring, cost-focused parent selection without curvature penalty to improve path length, combined uniform and ellipsoidal informed sampling with fallback, consistent collision checking, early stopping on solution stagnation, and an enhanced multi-pass shortcutting approach for better smoothness and shorter paths. The planner alternates growth between two trees, connects them incrementally, rewires neighbors within a stable radius to reduce path length, and continuously updates the best path to quickly converge on high-quality solutions.",
                "planning_mechanism": "The planner grows two trees from start and goal by steering toward sampled points drawn mostly from an ellipsoidal informed distribution after an initial solution, selects parents minimizing pure cost in a fixed radius neighborhood for simplicity and effectiveness, rewires nodes to improve path length iteratively, attempts connecting alternate trees each iteration, applies early stopping upon stagnation, and performs a robust multi-pass shortcutting method to smooth and shorten the final path before returning.",
                "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=5.0, neighbor_radius=15.0,\n                 no_improve_limit=60, shortcut_passes=4, shortcut_iter=200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        dist = lambda a,b: math.dist(a,b)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,0,0))[:3]\n            for obs in obstacles:\n                if dim == 3:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,res=1.0):\n            length = dist(a,b)\n            if length < 1e-12:\n                return False\n            steps = max(2,int(length/res))\n            for i in range(steps+1):\n                pt = tuple(a[d] + (b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        def steer(frm,to):\n            d = dist(frm,to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def neighbors(tree, point, radius):\n            r_sq = radius*radius\n            res = []\n            for n in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = n.position[i]-point[i]\n                    d_sq += diff*diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    res.append(n)\n            return res\n\n        def choose_parent(tree, new_pos):\n            nbrs = neighbors(tree, new_pos, self.neighbor_radius)\n            valid_parents = []\n            for candidate in nbrs:\n                if not edge_in_obstacle(candidate.position, new_pos):\n                    valid_parents.append(candidate)\n            if not valid_parents:\n                # fallback nearest neighbor with edge check\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = dist(n.position,new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position,new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                cost = nearest.cost + nearest_dist\n                new_node = Node(new_pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            # choose parent minimizing cost + dist (pure cost)\n            best_parent = min(valid_parents, key=lambda p: p.cost + dist(p.position, new_pos))\n            min_cost = best_parent.cost + dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb is pivot.parent:\n                    continue\n                dist_p_nb = dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_p_nb\n                if new_cost + 1e-12 < nb.cost and not edge_in_obstacle(pivot.position, nb.position):\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = None\n            nearest_dist = float('inf')\n            for n in tree:\n                d = dist(n.position, target_node.position)\n                if d < nearest_dist:\n                    nearest = n\n                    nearest_dist = d\n            if nearest is None:\n                return None\n            if nearest_dist <= self.step_size:\n                if edge_in_obstacle(nearest.position,target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + nearest_dist)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            # incrementally build path by steering in steps\n            current = nearest\n            steps = int(math.ceil(nearest_dist / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if (not in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + dist(current.position,new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if dist(current.position,target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position,target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + dist(current.position,target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n        def ellipsoid_sample(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = [goal[d] - start[d] for d in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-15:\n                return sample_uniform()\n            unit_a1 = [x / norm_a1 for x in a1]\n            basis = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0.0] * dim\n                base[(idx + 1) % dim] = 1.0\n                for b in basis:\n                    proj = sum(base[j]*b[j] for j in range(dim))\n                    base = [base[j] - proj*b[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-15:\n                    base = [x / norm_base for x in base]\n                else:\n                    base = [0.0]*dim\n                basis.append(base)\n            r1 = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r_orth = math.sqrt(val)*0.5 if val > 0 else 0.0\n            radii = [r1] + [r_orth]*(dim-1)\n            for _ in range(30):\n                x_ball = [random.gauss(0.,1.) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-15:\n                    continue\n                unit_ball = [xx / norm_ball for xx in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord*u for coord in unit_ball]\n                sample_point = [0.0]*dim\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        sample_point[j_] += point_ball[i_]*radii[i_]*basis[i_][j_]\n                sample = tuple(min(max(center[i] + sample_point[i],0.0),bounds[i]) for i in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _pass in range(self.shortcut_passes):\n                for _ in range(self.shortcut_iter):\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0,len(path)-3)\n                    j = random.randint(i+2,len(path)-1)\n                    if not edge_in_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n            return path\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        start_tree = [start_node]\n        goal_tree = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = dist(start, goal)\n        found_solution = False\n        no_improve_count = 0\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                if random.random() < 0.75:\n                    sample = ellipsoid_sample(best_cost, c_min)\n                else:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if (not in_bounds(sample)) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            if iter_i % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            nearest_node = min(tree_a, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if (not in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos)\n            if not new_node:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node:\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
                "objective": -1.43424,
                "time_improvement": -55.0,
                "length_improvement": 18.0,
                "smoothness_improvement": 1387.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.06341383457183838,
                        "num_nodes_avg": 103.8,
                        "path_length_avg": 164.54737794771944,
                        "smoothness_avg": 0.04972775433740213,
                        "success_improvement": 0.0,
                        "time_improvement": -161.11878500498233,
                        "length_improvement": 9.808974726794922,
                        "smoothness_improvement": 678.3473409272556,
                        "objective_score": -39.05851396078147
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.07592117786407471,
                        "num_nodes_avg": 252.7,
                        "path_length_avg": 225.9987552426278,
                        "smoothness_avg": 0.09919532921906127,
                        "success_improvement": 0.0,
                        "time_improvement": 52.97986930374476,
                        "length_improvement": 24.555110486521446,
                        "smoothness_improvement": 2452.367268314153,
                        "objective_score": 42.88886342460706
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.07755882740020752,
                        "num_nodes_avg": 259.0,
                        "path_length_avg": 119.68710339321123,
                        "smoothness_avg": 0.08887348783525148,
                        "success_improvement": 0.0,
                        "time_improvement": -56.61890662237307,
                        "length_improvement": 20.509524813642557,
                        "smoothness_improvement": 1030.4642053059013,
                        "objective_score": 0.4723639280031193
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "e2",
            "algorithm_description": "An improved bidirectional RRT* planner that consolidates a stable fixed-radius neighborhood for efficient rewiring, cost-focused parent selection, balanced sampling combining ellipsoidal informed and uniform strategies, and early stopping on stagnation. The planner incrementally grows two trees alternately, rewires neighbors to improve global path optimality, and attempts connecting trees with incremental steering. It performs extensive multi-pass shortcutting smoothing for better path length and smoothness while carefully managing collision checks and pruning during planning for robustness and speed.",
            "planning_mechanism": "A bidirectional incremental RRT* planner with fixed-radius neighbors enabling effective rewiring combined with ellipsoidal plus uniform sampling. It chooses parents to minimize cost, rewires neighbors for global path improvement, incrementally attempts tree connections, and applies extensive shortcut smoothing after early stopping on stagnation for efficient search, shorter, and smoother paths.",
            "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=5.0, neighbor_radius=18.0,\n                 no_improve_limit=50, shortcut_passes=5, shortcut_iter=250):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        dist = lambda a, b: math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if dim == 3:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a, b)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                pt = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def neighbors(tree, point, radius):\n            r_sq = radius * radius\n            res = []\n            for n in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d_sq += diff * diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    res.append(n)\n            return res\n\n        def choose_parent(tree, new_pos):\n            nbrs = neighbors(tree, new_pos, self.neighbor_radius)\n            valid_parents = []\n            for candidate in nbrs:\n                if not edge_in_obstacle(candidate.position, new_pos):\n                    valid_parents.append(candidate)\n            if not valid_parents:\n                # fallback nearest neighbor with edge check\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None or in_obstacle(new_pos):\n                    return None, []\n                cost = nearest.cost + nearest_dist\n                new_node = Node(new_pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            # choose parent minimizing cost + dist (cost-to-come)\n            best_parent = min(valid_parents, key=lambda p: p.cost + dist(p.position, new_pos))\n            min_cost = best_parent.cost + dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb is pivot.parent:\n                    continue\n                dist_p_nb = dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_p_nb\n                if new_cost + 1e-12 < nb.cost and not edge_in_obstacle(pivot.position, nb.position):\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = None\n            nearest_dist = float('inf')\n            for n in tree:\n                d = dist(n.position, target_node.position)\n                if d < nearest_dist:\n                    nearest = n\n                    nearest_dist = d\n            if nearest is None:\n                return None\n            if nearest_dist <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + nearest_dist)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            # incremental steering with multiple steps\n            current = nearest\n            steps = int(math.ceil(nearest_dist / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if (not in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def ellipsoid_sample(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            a1 = [goal[d] - start[d] for d in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-15:\n                return sample_uniform()\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # generate orthonormal basis\n            basis = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0.0] * dim\n                base[(idx + 1) % dim] = 1.0\n                for b in basis:\n                    proj = sum(base[j] * b[j] for j in range(dim))\n                    base = [base[j] - proj * b[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-15:\n                    base = [x / norm_base for x in base]\n                else:\n                    base = [0.0] * dim\n                basis.append(base)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r_orth = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r_orth] * (dim - 1)\n\n            for _ in range(50):\n                x_ball = [random.gauss(0., 1.) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-15:\n                    continue\n                unit_ball = [xx / norm_ball for xx in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n                mapped = [0.0] * dim\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        mapped[j_] += point_ball[i_] * radii[i_] * basis[i_][j_]\n                sample = tuple(min(max(center[i] + mapped[i], 0.0), bounds[i]) for i in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _pass in range(self.shortcut_passes):\n                for _ in range(self.shortcut_iter):\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path) - 3)\n                    j = random.randint(i + 2, len(path) - 1)\n                    if not edge_in_obstacle(path[i], path[j]):\n                        path = path[:i + 1] + path[j:]\n            return path\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        start_tree = [start_node]\n        goal_tree = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = dist(start, goal)\n        found_solution = False\n        no_improve_count = 0\n\n        for iter_i in range(self.max_iter):\n            # Balanced sampling: mostly ellipsoidal after first path found, occasional uniform for exploration\n            if found_solution:\n                if random.random() < 0.7:\n                    sample = ellipsoid_sample(best_cost, c_min)\n                else:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            # Alternate growth of trees each iteration\n            if iter_i % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            nearest_node = min(tree_a, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node:\n                # Reconstruct candidate path from connected trees\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                # Merge paths handling last node duplication\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
            "objective": 15.41941,
            "time_improvement": -114.0,
            "length_improvement": 20.0,
            "smoothness_improvement": 1377.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0893782377243042,
                    "num_nodes_avg": 95.8,
                    "path_length_avg": 154.6273697275617,
                    "smoothness_avg": 0.04224056137084624,
                    "success_improvement": 0.0,
                    "time_improvement": -268.0322598063037,
                    "length_improvement": 15.246288424852844,
                    "smoothness_improvement": 561.1565123008995,
                    "objective_score": -68.45612232547491
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.10737013816833496,
                    "num_nodes_avg": 259.3,
                    "path_length_avg": 230.33873264271023,
                    "smoothness_avg": 0.0936642703995312,
                    "success_improvement": 0.0,
                    "time_improvement": 33.502639558770205,
                    "length_improvement": 23.10630111105081,
                    "smoothness_improvement": 2310.049141027005,
                    "objective_score": 35.46481823939657
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.10335655212402343,
                    "num_nodes_avg": 219.9,
                    "path_length_avg": 117.82108603857912,
                    "smoothness_avg": 0.10688549782159049,
                    "success_improvement": 0.0,
                    "time_improvement": -108.71370453287112,
                    "length_improvement": 21.74884469039136,
                    "smoothness_improvement": 1259.5756428238533,
                    "objective_score": -13.266926331507253
                }
            ],
            "success_rate": 1.0
        },
        "objective": 11.2,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Planning inefficiencies from naive neighbor searches and insufficient pruning, causing slow exploration.\n   - Suboptimal parent selection and limited rewiring scope reducing path optimality.\n   - Simple smoothing strategies that inadequately improve path smoothness and length."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Incorporation of balanced sampling strategies combining informed and uniform exploration.\n   - Enhanced fixed-radius neighborhood rewiring with effective parent cost minimization.\n   - Increased adaptive shortcutting iterations improving global path refinement.\n\n2. Expected mechanism of impact:\n   - Balanced sampling concentrates search in promising regions while retaining exploration, accelerating convergence.\n   - Fixed-radius neighbor rewiring ensures more reliable and globally optimal path improvements.\n   - More extensive shortcutting removes redundant segments, shortening and smoothing the final path."
        }
    },
    {
        "parents": [
            {
                "operator": "cross_over",
                "algorithm_description": "A bidirectional informed RRT* planner with dynamically scaled neighbor radius based on sample density and cost, efficient spatial hashing for fast nearest and neighbor lookups, curvature-penalized cost for smoothness, iterative rewiring with cost improvement propagation, focused informed sampling after initial solution, adaptive pruning to maintain tree compactness, and enhanced multi-pass adaptive shortcutting and smoothing employing curvature-aware node updates. Early stopping on stagnation and improved parent choosing considering combined cost-curvature measure lead to faster convergence to shorter, smoother paths.",
                "planning_mechanism": "A bidirectional RRT* that alternately grows start and goal trees, efficiently finding near neighbors via spatial hashing with dynamically scaled radii supporting rewiring and cost propagation; it employs an ellipsoidal informed sampler once a solution is found to expedite convergence. Curvature penalties are integrated in parent choosing and rewiring steps for smoothness, complemented by adaptive multi-pass shortcutting and smoothing including curvature-based node adjustments. The planner prunes nodes exceeding adaptively updated cost thresholds to limit search space growth and uses stagnation detection to stop early, achieving improved path length and reduced planning times.",
                "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        p = []\n        n = self\n        while n:\n            p.append(n.position)\n            n = n.parent\n        return p[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=4.5,\n                 base_radius=20.0,\n                 min_radius=3.5,\n                 time_limit=10.0,\n                 no_improve_limit=40,\n                 shortcut_passes=4,\n                 shortcut_attempts=400,\n                 uniform_sample_prob=0.12,\n                 goal_sample_prob=0.06,\n                 grid_cell_size=12.0,\n                 curvature_w=0.07,\n                 max_curv_increase=0.12,\n                 prune_factor=1.6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_prob = uniform_sample_prob\n        self.goal_sample_prob = goal_sample_prob\n        self.grid_cell_size = grid_cell_size\n        self.curvature_w = curvature_w\n        self.max_curv_increase = max_curv_increase\n        self.prune_factor = prune_factor\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,) * (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a,b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(3, int(dist_ab / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d]) * i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            r = self.step_size / dist\n            return tuple(frm[d] + (to[d]-frm[d])*r for d in range(dim))\n\n        def curvature_penalty(p_parent, p_curr, p_new):\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_curr[d]-p_parent[d] for d in range(dim))\n            v2 = tuple(p_new[d]-p_curr[d] for d in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-16 or len2 < 1e-16:\n                return 0.0\n            dot = sum(v1[d]*v2[d] for d in range(dim)) / (len1 * len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        class SpatialGrid:\n            __slots__ = ('cell_size','dim','grid')\n            def __init__(self,bounds,cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self,pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self,node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self,node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self,pos,radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                candidates = []\n                rng = range(-cr,cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx, base[1]+dy)\n                            if cell in self.grid:\n                                candidates.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for n in candidates:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        diff = n.position[d] - pos[d]\n                        dist_sq += diff*diff\n                        if dist_sq > r2:\n                            break\n                    else:\n                        filtered.append(n)\n                return filtered\n            def nearest(self,pos):\n                base = self._hash(pos)\n                rng_lim = 8\n                search_r = 0\n                cand = []\n                while not cand and search_r <= rng_lim:\n                    rng = range(-search_r,search_r+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    cand.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        cand.extend(self.grid[cell])\n                    search_r += 1\n                if not cand:\n                    return None\n                nearest_node = min(cand, key=lambda n: math.dist(n.position,pos))\n                return nearest_node\n\n        def sample_uniform():\n            for _ in range(20):\n                p = tuple(random.uniform(0.0,bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0.0,bounds[d]) for d in range(dim))\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-14:\n                return sample_uniform()\n            center = tuple((start_pos[d]+goal_pos[d])*0.5 for d in range(dim))\n            dvec = [(goal_pos[d]-start_pos[d]) / c_min for d in range(dim)]\n            basis = [dvec]\n            for i in range(1,dim):\n                v = [0.0]*dim\n                v[i] = 1.0\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j]-proj*b[j] for j in range(dim)]\n                normv = math.sqrt(sum(x*x for x in v))\n                basis.append([x/normv if normv>1e-14 else 0.0 for x in v])\n            r_long = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r_short = math.sqrt(max(0.0,val))*0.5 if dim>1 else 0.0\n            radii = [r_long] + [r_short]*(dim-1)\n            for _ in range(30):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                unit_x = [x / norm_x for x in x_ball]\n                u = random.random()**(1/dim)\n                scaled = [radii[i]*unit_x[i]*u for i in range(dim)]\n                sample = [center[d] + sum(basis[i][d]*scaled[i] for i in range(dim)) for d in range(dim)]\n                sample = tuple(max(0.0,min(bounds[d], sample[d])) for d in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def neighbor_radius(n_nodes, c_best):\n            if n_nodes < 2:\n                return self.base_radius\n            val = self.base_radius * (math.log(n_nodes+1)/(n_nodes+1))**(1/dim)\n            radius = max(self.min_radius, min(val, self.base_radius))\n            if c_best == float('inf'):\n                return radius\n            shrinkf = c_best / (math.dist(start_pos, goal_pos)*2.5)\n            return max(self.min_radius, radius * max(0.38, shrinkf))\n\n        def choose_parent(nodes, grid, pos, radius, c_best):\n            neighbors = grid.query_radius(pos, radius)\n            good_neighbors = []\n            for nb in neighbors:\n                if in_obstacle(pos) or edge_in_obstacle(nb.position, pos):\n                    continue\n                good_neighbors.append(nb)\n            if not good_neighbors:\n                nearest = grid.nearest(pos)\n                if nearest is None or in_obstacle(pos) or edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                good_neighbors = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in good_neighbors:\n                dist_ = math.dist(nb.position, pos)\n                c = nb.cost + dist_\n                curv = curvature_penalty(nb.parent.position if nb.parent else None, nb.position, pos)\n                score = c + self.curvature_w*curv\n                if score < best_cost:\n                    best_cost = score\n                    best_parent = nb\n            if best_parent is None:\n                return None, []\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, good_neighbors\n\n        def propagate_costs(node,grid):\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for ch in curr.children[:]:\n                    new_cost = curr.cost + math.dist(curr.position, ch.position)\n                    curv = curvature_penalty(curr.parent.position if curr.parent else None, curr.position, ch.position)\n                    new_score = new_cost + self.curvature_w*curv\n                    old_score = ch.cost + (self.curvature_w*curvature_penalty(ch.parent.parent.position if ch.parent and ch.parent.parent else None,\n                                                                            ch.parent.position if ch.parent else None, ch.position) if ch.parent else 0)\n                    if new_score + 1e-11 < old_score:\n                        if edge_in_obstacle(curr.position, ch.position):\n                            continue\n                        ch.cost = new_cost\n                        if ch.parent:\n                            ch.parent.remove_child(ch)\n                        curr.add_child(ch)\n                        stack.append(ch)\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb is new_node.parent:\n                    continue\n                dist_ = math.dist(new_node.position, nb.position)\n                new_cost = new_node.cost + dist_\n                if new_cost + 1e-12 >= nb.cost:\n                    continue\n                if edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, nb.position)\n                curv_old = curvature_penalty(nb.parent.parent.position if nb.parent and nb.parent.parent else None,\n                                            nb.parent.position if nb.parent else None, nb.position)\n                if self.curvature_w*curv_new > self.curvature_w*curv_old + self.max_curv_increase:\n                    continue\n                if nb.parent is not None:\n                    nb.parent.remove_child(nb)\n                new_node.add_child(nb)\n                nb.cost = new_cost\n                propagate_costs(nb, grid)\n\n        def try_connect(tree_nodes, tree_grid, other_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_grid.nearest(other_node.position)\n            if nearest is None:\n                return None\n            dist_no = math.dist(nearest.position, other_node.position)\n            if dist_no <= self.step_size:\n                if edge_in_obstacle(nearest.position, other_node.position) or in_obstacle(other_node.position):\n                    return None\n                new_node = Node(other_node.position, parent=nearest, cost=nearest.cost + dist_no)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                return new_node\n            current = nearest\n            max_steps = int(math.ceil(dist_no/self.step_size))\n            for _ in range(max_steps):\n                new_pos = steer(current.position, other_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                dist_cnp = math.dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=current.cost + dist_cnp)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, other_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, other_node.position) or in_obstacle(other_node.position):\n                        return None\n                    final_node = Node(other_node.position, parent=current, cost=current.cost + math.dist(current.position, other_node.position))\n                    tree_nodes.append(final_node)\n                    tree_grid.insert(final_node)\n                    return final_node\n            return None\n\n        def prune_tree(nodes, grid, cost_limit):\n            to_remove = [n for n in nodes if n.cost > cost_limit]\n            for n in to_remove:\n                if n.parent:\n                    n.parent.remove_child(n)\n                grid.remove(n)\n                if n in nodes:\n                    nodes.remove(n)\n            return len(to_remove)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _ in range(self.shortcut_passes):\n                changed = True\n                attempts = 0\n                while changed and attempts < self.shortcut_attempts:\n                    changed = False\n                    attempts += 1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path)-3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1,p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        def smooth_path(path):\n            if len(path) < 4:\n                return list(path)\n            smoothed = list(path)\n            alpha = 0.22\n            for _ in range(14):\n                for i in range(1, len(smoothed)-1):\n                    prev_p, curr_p, next_p = smoothed[i-1], smoothed[i], smoothed[i+1]\n                    cand = tuple(curr_p[d] + alpha*(prev_p[d]+next_p[d]-2*curr_p[d]) for d in range(dim))\n                    cand_clamped = tuple(max(0.0,min(bounds[d], cand[d])) for d in range(dim))\n                    if (not in_obstacle(cand_clamped) and not edge_in_obstacle(smoothed[i-1], cand_clamped)\n                        and not edge_in_obstacle(cand_clamped, smoothed[i+1])):\n                        smoothed[i] = cand_clamped\n            return smoothed\n\n        def combine_paths(snode, gnode, reverse_start):\n            pstart = snode.path_from_root()\n            pgoal = gnode.path_from_root()\n            if reverse_start:\n                pstart.reverse()\n                return pgoal + pstart[1:]\n            else:\n                pgoal.reverse()\n                return pstart + pgoal[1:]\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found = False\n        no_improve = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n                rev_start = False\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n                rev_start = True\n\n            r = random.random()\n            if r < self.goal_sample_prob:\n                sample_pt = sample_goal()\n            elif found and r < self.goal_sample_prob + (1 - self.goal_sample_prob - self.uniform_sample_prob):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid_a.nearest(sample_pt)\n            if nearest is None:\n                if found:\n                    no_improve +=1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            radius = neighbor_radius(len(tree_a), best_cost)\n            new_node, neighbors = choose_parent(tree_a, grid_a, new_pos, radius, best_cost)\n            if new_node is None:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid_a)\n\n            conn_node = try_connect(tree_b, grid_b, new_node)\n            if conn_node:\n                candidate = combine_paths(new_node, conn_node, rev_start)\n                cost_cand = 0.0\n                for i in range(len(candidate)-1):\n                    cost_cand += math.dist(candidate[i], candidate[i+1])\n                if cost_cand + 1e-11 < best_cost:\n                    best_cost = cost_cand\n                    best_path = candidate\n                    found = True\n                    no_improve = 0\n                    prune_tree(start_tree, start_grid, best_cost*self.prune_factor)\n                    prune_tree(goal_tree, goal_grid, best_cost*self.prune_factor)\n                else:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n            else:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n\n            if found and no_improve >= self.no_improve_limit:\n                break\n\n        if found and len(best_path) > 3:\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n                best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found, path=best_path,\n                             nodes=start_tree+goal_tree,\n                             edges=[])",
                "objective": -11.31881,
                "time_improvement": -13.0,
                "length_improvement": 24.0,
                "smoothness_improvement": 215.0,
                "other_inf": [
                    {
                        "map_id": 0,
                        "success_rate": 1.0,
                        "time_avg": 0.047393965721130374,
                        "num_nodes_avg": 134.6,
                        "path_length_avg": 146.99009020142267,
                        "smoothness_avg": 0.013619690044331782,
                        "success_improvement": 0.0,
                        "time_improvement": -95.15386239022978,
                        "length_improvement": 19.43240235356819,
                        "smoothness_improvement": 113.17772482409802,
                        "objective_score": -16.32082868080753
                    },
                    {
                        "map_id": 1,
                        "success_rate": 1.0,
                        "time_avg": 0.058544158935546875,
                        "num_nodes_avg": 352.1,
                        "path_length_avg": 219.06274328066283,
                        "smoothness_avg": 0.0147639358316728,
                        "success_improvement": 0.0,
                        "time_improvement": 63.741948134944124,
                        "length_improvement": 26.87055092146022,
                        "smoothness_improvement": 279.88670298208984,
                        "objective_score": 36.64434850826982
                    },
                    {
                        "map_id": 2,
                        "success_rate": 1.0,
                        "time_avg": 0.05396511554718018,
                        "num_nodes_avg": 434.3,
                        "path_length_avg": 112.77420988956904,
                        "smoothness_avg": 0.027750346540338443,
                        "success_improvement": 0.0,
                        "time_improvement": -8.974795984689827,
                        "length_improvement": 25.10073952214698,
                        "smoothness_improvement": 252.9823596755917,
                        "objective_score": 13.632916716259198
                    }
                ],
                "success_rate": 1.0
            }
        ],
        "offspring": {
            "operator": "path_expert",
            "algorithm_description": "A unidirectional RRT* planner enhanced with adaptive fixed-radius rewiring, a balanced sampling approach mixing uniform, goal bias, and modest informed ellipsoidal samples for focused exploration that improves path length; spatial grid indexing supports efficient neighbor queries; parent selection prioritizes minimal combined cost with a soft curvature penalty to avoid excessive path length degradation; multi-pass adaptive shortcutting and smoothing improve smoothness and length; pruning rejects nodes exceeding the best cost times a factor, controlling tree size and speeding processing; early stopping occurs upon stagnation to limit runtimes.",
            "planning_mechanism": "A unidirectional RRT* planner grows a tree from start towards goal, using an efficient spatial grid to query neighbors; sampling combines uniform, goal, and ellipsoidal informed strategies adaptively once a solution exists to improve path quality and planning speed; new nodes connect to the locally optimal parent minimizing path length plus a mild curvature penalty; rewiring adjusts nearby nodes if beneficial; path pruning and multi-pass shortcut/smooth operations iteratively refine final path length and smoothness; planning stops early if no improvements are found over several iterations.",
            "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        p = []\n        n = self\n        while n:\n            p.append(n.position)\n            n = n.parent\n        return p[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 step_size=5.0,\n                 base_radius=25.0,\n                 min_radius=4.0,\n                 time_limit=9.0,\n                 no_improve_limit=35,\n                 shortcut_passes=5,\n                 shortcut_attempts=600,\n                 uniform_sample_prob=0.15,\n                 goal_sample_prob=0.07,\n                 grid_cell_size=14.0,\n                 curvature_w=0.035,\n                 prune_factor=1.4):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_prob = uniform_sample_prob\n        self.goal_sample_prob = goal_sample_prob\n        self.grid_cell_size = grid_cell_size\n        self.curvature_w = curvature_w\n        self.prune_factor = prune_factor\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,) * (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a,b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(3, int(dist_ab / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d]) * i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            r = self.step_size / dist\n            return tuple(frm[d] + (to[d]-frm[d])*r for d in range(dim))\n\n        def curvature_penalty(p_parent, p_curr, p_new):\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_curr[d]-p_parent[d] for d in range(dim))\n            v2 = tuple(p_new[d]-p_curr[d] for d in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[d]*v2[d] for d in range(dim)) / (len1 * len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        class SpatialGrid:\n            __slots__ = ('cell_size','dim','grid')\n            def __init__(self,bounds,cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self,pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self,node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self,node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self,pos,radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                candidates = []\n                rng = range(-cr,cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx, base[1]+dy)\n                            if cell in self.grid:\n                                candidates.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for n in candidates:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        diff = n.position[d] - pos[d]\n                        dist_sq += diff*diff\n                        if dist_sq > r2:\n                            break\n                    else:\n                        filtered.append(n)\n                return filtered\n            def nearest(self,pos):\n                base = self._hash(pos)\n                rng_lim = 7\n                search_r = 0\n                cand = []\n                while not cand and search_r <= rng_lim:\n                    rng = range(-search_r,search_r+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    cand.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        cand.extend(self.grid[cell])\n                    search_r += 1\n                if not cand:\n                    return None\n                nearest_node = min(cand, key=lambda n: math.dist(n.position,pos))\n                return nearest_node\n\n        def sample_uniform():\n            for _ in range(15):\n                p = tuple(random.uniform(0.0,bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0.0,bounds[d]) for d in range(dim))\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-14:\n                return sample_uniform()\n            center = tuple((start_pos[d]+goal_pos[d])*0.5 for d in range(dim))\n            dvec = [(goal_pos[d]-start_pos[d]) / c_min for d in range(dim)]\n            basis = [dvec]\n            for i in range(1,dim):\n                v = [0.0]*dim\n                v[i] = 1.0\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j]-proj*b[j] for j in range(dim)]\n                normv = math.sqrt(sum(x*x for x in v))\n                basis.append([x/normv if normv>1e-14 else 0.0 for x in v])\n            r_long = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r_short = math.sqrt(max(0.0,val))*0.5 if dim>1 else 0.0\n            radii = [r_long] + [r_short]*(dim-1)\n            for _ in range(25):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                unit_x = [x / norm_x for x in x_ball]\n                u = random.random()**(1/dim)\n                scaled = [radii[i]*unit_x[i]*u for i in range(dim)]\n                sample = [center[d] + sum(basis[i][d]*scaled[i] for i in range(dim)) for d in range(dim)]\n                sample = tuple(max(0.0,min(bounds[d], sample[d])) for d in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def neighbor_radius(n_nodes, c_best):\n            if n_nodes < 2:\n                return self.base_radius\n            val = self.base_radius * (math.log(n_nodes+1)/(n_nodes+1))**(1/dim)\n            radius = max(self.min_radius, min(val, self.base_radius))\n            if c_best == float('inf'):\n                return radius\n            shrinkf = c_best / (math.dist(start_pos, goal_pos)*2.4)\n            return max(self.min_radius, radius * max(0.4, shrinkf))\n\n        def choose_parent(nodes, grid, pos, radius, c_best):\n            neighbors = grid.query_radius(pos, radius)\n            good_neighbors = []\n            if in_obstacle(pos):\n                return None, []\n            for nb in neighbors:\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                good_neighbors.append(nb)\n            if not good_neighbors:\n                nearest = grid.nearest(pos)\n                if nearest is None or edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                good_neighbors = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in good_neighbors:\n                dist_ = math.dist(nb.position, pos)\n                c = nb.cost + dist_\n                curv = curvature_penalty(nb.parent.position if nb.parent else None, nb.position, pos)\n                score = c + self.curvature_w*curv\n                if score < best_cost:\n                    best_cost = score\n                    best_parent = nb\n            if best_parent is None:\n                return None, []\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, good_neighbors\n\n        def propagate_costs(node,grid):\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for ch in curr.children[:]:\n                    dist_c = math.dist(curr.position, ch.position)\n                    new_cost = curr.cost + dist_c\n                    curv = curvature_penalty(curr.parent.position if curr.parent else None,\n                                             curr.position, ch.position)\n                    new_score = new_cost + self.curvature_w*curv\n                    old_score = ch.cost + (self.curvature_w*curvature_penalty(\n                        ch.parent.parent.position if ch.parent and ch.parent.parent else None,\n                        ch.parent.position if ch.parent else None,\n                        ch.position) if ch.parent else 0)\n                    if new_score + 1e-11 < old_score:\n                        if edge_in_obstacle(curr.position, ch.position):\n                            continue\n                        ch.cost = new_cost\n                        if ch.parent:\n                            ch.parent.remove_child(ch)\n                        curr.add_child(ch)\n                        stack.append(ch)\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb is new_node.parent:\n                    continue\n                dist_ = math.dist(new_node.position, nb.position)\n                new_cost = new_node.cost + dist_\n                if new_cost + 1e-13 >= nb.cost:\n                    continue\n                if edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, nb.position)\n                curv_old = curvature_penalty(nb.parent.parent.position if nb.parent and nb.parent.parent else None,\n                                            nb.parent.position if nb.parent else None, nb.position)\n                # Use a softened curvature increase limit to allow slight curvature growth if cost improvement compensates\n                if self.curvature_w*curv_new > self.curvature_w*curv_old + 0.16:\n                    continue\n                if nb.parent is not None:\n                    nb.parent.remove_child(nb)\n                new_node.add_child(nb)\n                nb.cost = new_cost\n                propagate_costs(nb, grid)\n\n        def prune_tree(nodes, grid, cost_limit):\n            to_remove = [n for n in nodes if n.cost > cost_limit]\n            for n in to_remove:\n                if n.parent:\n                    n.parent.remove_child(n)\n                grid.remove(n)\n                if n in nodes:\n                    nodes.remove(n)\n            return len(to_remove)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _ in range(self.shortcut_passes):\n                changed = True\n                attempts = 0\n                while changed and attempts < self.shortcut_attempts:\n                    changed = False\n                    attempts += 1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path)-3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1,p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        def smooth_path(path):\n            if len(path) < 4:\n                return list(path)\n            smoothed = list(path)\n            alpha = 0.23\n            for _ in range(16):\n                for i in range(1, len(smoothed)-1):\n                    prev_p, curr_p, next_p = smoothed[i-1], smoothed[i], smoothed[i+1]\n                    cand = tuple(curr_p[d] + alpha*(prev_p[d]+next_p[d]-2*curr_p[d]) for d in range(dim))\n                    cand_clamped = tuple(max(0.0,min(bounds[d], cand[d])) for d in range(dim))\n                    if (not in_obstacle(cand_clamped) and not edge_in_obstacle(smoothed[i-1], cand_clamped)\n                        and not edge_in_obstacle(cand_clamped, smoothed[i+1])):\n                        smoothed[i] = cand_clamped\n            return smoothed\n\n        start_root = Node(start_pos, cost=0.0)\n        nodes = [start_root]\n        grid = SpatialGrid(bounds, self.grid_cell_size)\n        grid.insert(start_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found = False\n        no_improve = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            r = random.random()\n            if r < self.goal_sample_prob:\n                sample_pt = sample_goal()\n            elif found and r < self.goal_sample_prob + (1 - self.goal_sample_prob - self.uniform_sample_prob):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid.nearest(sample_pt)\n            if nearest is None:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            radius = neighbor_radius(len(nodes), best_cost)\n            new_node, neighbors = choose_parent(nodes, grid, new_pos, radius, best_cost)\n            if new_node is None:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid)\n\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not in_obstacle(goal_pos) and not edge_in_obstacle(new_node.position, goal_pos):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    nodes.append(goal_node)\n                    grid.insert(goal_node)\n                    candidate = goal_node.path_from_root()\n                    cost_cand = 0.0\n                    for i in range(len(candidate)-1):\n                        cost_cand += math.dist(candidate[i], candidate[i+1])\n                    if cost_cand + 1e-11 < best_cost:\n                        best_cost = cost_cand\n                        best_path = candidate\n                        found = True\n                        no_improve = 0\n                        prune_tree(nodes, grid, best_cost*self.prune_factor)\n                    else:\n                        no_improve += 1\n                        if no_improve >= self.no_improve_limit:\n                            break\n            else:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n\n            if found and no_improve >= self.no_improve_limit:\n                break\n\n        if found and len(best_path) > 3:\n            for _ in range(4):\n                best_path = shortcut_path(best_path)\n                best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found, path=best_path,\n                             nodes=nodes,\n                             edges=[])",
            "objective": 44.90054,
            "time_improvement": -198.0,
            "length_improvement": 21.0,
            "smoothness_improvement": 398.0,
            "other_inf": [
                {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.09703254699707031,
                    "num_nodes_avg": 380.5,
                    "path_length_avg": 162.19367118194887,
                    "smoothness_avg": 0.02085744552662189,
                    "success_improvement": 0.0,
                    "time_improvement": -299.5503654507881,
                    "length_improvement": 11.099078701984212,
                    "smoothness_improvement": 226.46431515952793,
                    "objective_score": -82.07334083824826
                },
                {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.15577273368835448,
                    "num_nodes_avg": 1018.7,
                    "path_length_avg": 217.0141910262245,
                    "smoothness_avg": 0.022985753750998976,
                    "success_improvement": 0.0,
                    "time_improvement": 3.525544479134561,
                    "length_improvement": 27.554416628299023,
                    "smoothness_improvement": 491.4399999824332,
                    "objective_score": 20.04751332063195
                },
                {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.19692347049713135,
                    "num_nodes_avg": 608.2,
                    "path_length_avg": 114.8184375738015,
                    "smoothness_avg": 0.04522006556651624,
                    "success_improvement": 0.0,
                    "time_improvement": -297.6586504898775,
                    "length_improvement": 23.743060829941594,
                    "smoothness_improvement": 475.19589620804805,
                    "objective_score": -72.67577916795804
                }
            ],
            "success_rate": 1.0
        },
        "objective": 13.8,
        "analysis": {
            "problem": [
                "Problem of the parents algorithm:\n   - Use of bidirectional search with alternating tree expansions introduces overhead that may not always accelerate convergence.\n   - Parent selection and rewiring employ relatively strict curvature constraints that can limit rewiring opportunities and path shortening.\n   - Sampling strategies and pruning parameters are conservative, potentially reducing focused exploration near the optimal path.\n   - Path improvement relies on multiple shortcutting and smoothing passes but may be limited by initial tree structure complexity."
            ],
            "solution": "1. Primary contributors to the performance improvement:\n   - Adoption of a unidirectional search simplifies tree management and reduces overhead.\n   - Softer curvature penalty weighting and relaxed curvature increase thresholds enable more effective rewiring and path shortening.\n   - Enhanced sampling probabilities and more aggressive pruning foster focused and efficient exploration near the goal.\n   - Increased shortcut attempts and smoothing iterations improve final path refinement significantly.\n2. Expected mechanism of impact:\n   - Simplifying search direction reduces computational overhead and accelerates node expansions.\n   - Relaxed curvature constraints allow rewiring to improve connectivity and shorten path length without excessive penalty.\n   - More targeted sampling balances exploration and exploitation, concentrating efforts in promising regions.\n   - Enhanced smoothing processes reduce path length by eliminating unnecessary detours, leading to shorter and smoother trajectories."
        }
    }
]