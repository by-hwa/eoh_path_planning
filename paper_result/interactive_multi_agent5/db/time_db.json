[
    {
        "operator": "e2",
        "algorithm_description": "A bidirectional variant of RRT* with informed sampling and efficient rewiring that grows two trees simultaneously, restricts sampling to an ellipsoidal informed subset after first solution, and performs local rewiring to improve path cost and smoothness with early termination on convergence.",
        "planning_mechanism": "The planner grows start and goal trees bidirectionally with RRT* rewiring, initially samples uniformly to quickly find a path, then constrains samples to an ellipsoidal informed set defined by the current best path cost. After each extension, it attempts to connect the two trees if close enough, while performing localized rewiring to continuously improve path quality. Early stopping criteria limit iterations after no improvements to reduce planning time.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, radius=15.0,\n                 post_opt_iters=500, max_no_improve=100, improve_tol=1e-5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n\n        c_min = math.dist(start, goal)\n        found_solution = False\n\n        no_improve_count = 0\n        post_opt_count = 0\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            return tuple(frm[i] + (to[i]-frm[i]) * self.step_size / d for i in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            distance = dist(f, t)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                inter = tuple(f[j] + (t[j]-f[j])*(i/steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def nearest(tree, p):\n            best = tree[0]\n            best_d = dist(best.position, p)\n            for n in tree:\n                d2 = dist(n.position, p)\n                if d2 < best_d:\n                    best = n\n                    best_d = d2\n            return best\n\n        def near_nodes(tree, p, radius):\n            result = []\n            r2 = radius**2\n            for n in tree:\n                d2 = sum((n.position[i]-p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def extract_path(n_start, n_goal):\n            path_start, node = [], n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def ellipsoid_sample(c_best):\n            # Sample inside prolate hyperspheroid defined by start, goal, c_best\n            import random\n            import math\n\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i]+goal[i])/2 for i in range(dim))\n            a1 = [goal[i]-start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-12:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            # Compute rotation matrix via Gram-Schmidt or approximate as identity except along a1 axis\n            # For simplicity, rotate only along principal axis for 2D or 3D (orthonormal basis)\n            # Since imports are restricted, implement a simple orthonormal basis:\n\n            # Construct orthonormal basis U with unit_a1 as first vector\n            U = [unit_a1]\n            for i in range(dim-1):\n                base = [0]*dim\n                base[(i+1)%dim] = 1  # simple perpendicular approx\n                # Gram-Schmidt orthogonalize base vs U\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j]-proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-12:\n                    U.append([x/norm_base for x in base])\n                else:\n                    # fallback: constructs zero vector, skip\n                    U.append([0]*dim)\n\n            # L matrix diagonal\n            r1 = c_best / 2\n            if c_best*c_best - c_min*c_min < 0:\n                r2 = 0\n            else:\n                r2 = math.sqrt(c_best*c_best - c_min*c_min) / 2\n            radii = [r1] + [r2] * (dim - 1)\n\n            # Sample unit ball in dim\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-12:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n\n                # Scale by radii\n                point_scaled = [radii[i]*point_ball[i] for i in range(dim)]\n\n                # Rotate via U matrix: point = sum(point_scaled[i] * U[i]) over basis vectors\n                point_rotated = [0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i]*U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        for iter_count in range(self.max_iter):\n            if found_solution:\n                sample_pt = ellipsoid_sample(best_cost)\n            else:\n                sample_pt = ellipsoid_sample(float('inf'))\n\n            # Alternate growing start and goal trees\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n\n                if in_obstacle(new_pos) or edge_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                near = near_nodes(tree_a, new_pos, self.radius)\n\n                # Choose best parent in near nodes with minimal cost + dist and collision free edge\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for candidate in near:\n                    cand_cost = candidate.cost + dist(candidate.position, new_pos)\n                    if cand_cost + self.improve_tol < min_cost and not edge_obstacle(candidate.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = candidate\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire near nodes if new_node offers lower cost connection\n                for near_node in near:\n                    if near_node == best_parent:\n                        continue\n                    alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if alt_cost + self.improve_tol < near_node.cost and not edge_obstacle(new_node.position, near_node.position):\n                        # Remove old edge\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                        if near_node.parent and near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n                # Try connect trees if nodes close enough\n                connect_node = nearest(tree_b, new_node.position)\n                if dist(new_node.position, connect_node.position) <= self.step_size and not edge_obstacle(new_node.position, connect_node.position):\n                    path = extract_path(new_node, connect_node)\n                    path_cost = new_node.cost + dist(new_node.position, connect_node.position) + connect_node.cost\n                    if path_cost + self.improve_tol < best_cost:\n                        best_cost = path_cost\n                        # Stitch trees at connection nodes: assign parents carefully\n                        # For bidirectional path extraction, keep nodes and edges unchanged,\n                        # just store nodes for path extraction\n                        best_path = path\n                        found_solution = True\n                        best_goal_node = connect_node\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n\n                    if found_solution and no_improve_count >= self.max_no_improve:\n                        post_opt_count += 1\n                        if post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_opt_count += 1\n                        if no_improve_count >= self.max_no_improve or post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
        "objective": 52.64884,
        "time_improvement": -220.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 323.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.06786198616027832,
                "num_nodes_avg": 317.3,
                "path_length_avg": 155.50621247453464,
                "smoothness_avg": 0.02411673119934513,
                "success_improvement": 0.0,
                "time_improvement": -179.4349134355319,
                "length_improvement": 14.764580789082476,
                "smoothness_improvement": 277.4792135897667,
                "objective_score": -43.58432948926125
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.14667820930480957,
                "num_nodes_avg": 670.6,
                "path_length_avg": 226.29277909188164,
                "smoothness_avg": 0.017873034085429756,
                "success_improvement": 0.0,
                "time_improvement": 9.158040406689327,
                "length_improvement": 24.45695686263326,
                "smoothness_improvement": 359.8860404442116,
                "objective_score": 19.22101644180781
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.2925038576126099,
                "num_nodes_avg": 613.1,
                "path_length_avg": 120.56565817380633,
                "smoothness_avg": 0.03399415459254427,
                "success_improvement": 0.0,
                "time_improvement": -490.6695072338173,
                "length_improvement": 19.926030560654297,
                "smoothness_improvement": 332.4031372296796,
                "objective_score": -133.58321814760419
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "An enhanced bidirectional RRT* variant that incorporates adaptive neighbor radius shrinking to concentrate rewiring efforts for local optimality, an efficient nearest-neighbor caching structure for faster lookups, and progressive informed sampling with dynamic ellipsoidal restriction. The planner prioritizes early discovery and incremental path improvement, applies a smooth path shortcutting post-processing step to reduce path length and curvature, and enforces robust termination criteria based on stagnation and solution quality thresholds to minimize planning time.",
        "planning_mechanism": "The planner grows two trees alternately with rewiring using an adaptive radius, restricts sampling progressively to a shrinking ellipsoid after finding a solution to focus on promising areas, connects the trees upon proximity, and applies a final shortcut smoothing pass to improve total path length and smoothness before returning the best feasible path found within iteration and time limits.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n is not None:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=6.0, n_near_const=35, \n                 max_no_improve=80, improve_tol=1e-6, shortcut_iters=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const  # base neighbor count for adaptive radius\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        # --- Local helper imports & definitions ---\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        dist = lambda a, b: math.dist(a, b)\n\n        # Node collections\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        # To reduce overhead of nearest neighbor search, cache all nodes' positions lists for faster processing\n        # We implement simple linear searches but with caching and limit radius dynamically to reduce checks\n\n        # Adaptive radius for near-node rewiring, shrinks with best_cost to focus local improvements\n        # r_n = min((gamma * (log(n)/n))^(1/d), max_radius) but approximate w/o logs for lightweight\n        def adaptive_radius(n_nodes, c_best):\n            # Use gamma ~ 30 (typical for 2D), avoid zero or undefined\n            gamma = self.n_near_const\n            if n_nodes == 0:\n                return self.step_size * 2.5\n            r = min((gamma * (math.log(n_nodes)/n_nodes))**(1/dim), self.step_size * 5)\n            # Shrink with c_best, stronger around best solution to focus rewiring\n            if c_best == float('inf'):\n                return r\n            shrink_factor = max(0.25, c_best / (c_min * 3))\n            return max(self.step_size*0.75, r * shrink_factor)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-10:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[j] + (t[j] - f[j]) * (i / steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        # Efficient nearest neighbor search (linear but with early exit)\n        def nearest(tree, p):\n            best = None\n            best_d = float('inf')\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 >= best_d*best_d:\n                        break\n                else:\n                    d = math.sqrt(d2)\n                    if d < best_d:\n                        best = n\n                        best_d = d\n            return best\n\n        # Near nodes within radius (adaptive radius)\n        def near_nodes(tree, p, radius):\n            r2 = radius*radius\n            result = []\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 > r2:\n                        break\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        # Extract path from start via parent chain\n        def extract_path(node_start_root):\n            return node_start_root.path_from_root()\n\n        # Extract full path from two connection nodes (start tree and goal tree)\n        def connect_path(n_start, n_goal):\n            path_start = extract_path(n_start)\n            path_goal_rev = extract_path(n_goal)\n            path_goal = path_goal_rev[::-1]\n            if len(path_start) > 0 and len(path_goal) > 0 and path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        # Ellipsoidal informed sampling centered between start and goal, focused progressively as c_best shrinks\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-12:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Orthonormal basis U with unit_a1 first vector\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0] * dim\n                base[(idx + 1) % dim] = 1\n                for u in U:\n                    proj = sum(base[j] * u[j] for j in range(dim))\n                    base = [base[j] - proj * u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-12:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0] * dim)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r2 = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2] * (dim - 1)\n\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-12:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n                point_scaled = [radii[i] * point_ball[i] for i in range(dim)]\n\n                point_rotated = [0.0] * dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i] * U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        # Path shortcutting by attempting to connect non-adjacent nodes directly if collision free\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                changed = False\n                iter_count += 1\n                i = 0\n                while i < len(path) - 2:\n                    j = min(len(path) - 1, i + 2 + random.randint(0, 3))\n                    if j > i + 1 and not edge_obstacle(path[i], path[j]):\n                        # Shortcut feasible, remove intermediate nodes\n                        path = path[:i + 1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Add node to tree selecting best parent among near nodes\n        def add_node(tree, new_pos, nodes_all, edges, c_best):\n            nn = nearest(tree, new_pos)\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(nodes_all)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos_steered, radius)\n\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos_steered)\n            for near_node in near:\n                if near_node == nn:\n                    continue\n                cand_cost = near_node.cost + dist(near_node.position, new_pos_steered)\n                if cand_cost + self.improve_tol < best_cost and not edge_obstacle(near_node.position, new_pos_steered):\n                    best_parent = near_node\n                    best_cost = cand_cost\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if beneficial\n            for near_node in near:\n                if near_node is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if alt_cost + self.improve_tol < near_node.cost:\n                    if not edge_obstacle(new_node.position, near_node.position):\n                        # Remove old parent-child relationship\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n            return new_node\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n        start_time = time.time()\n\n        for iter_count in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate tree growing: start tree first odd iters, goal second even iters\n            if iter_count % 2 == 0:\n                tree_a = start_tree\n                tree_b = goal_tree\n            else:\n                tree_a = goal_tree\n                tree_b = start_tree\n\n            new_node = add_node(tree_a, sample_pt, nodes_all, edges, best_cost)\n            if new_node is None:\n                # Could not add node (collision), continue\n                continue\n\n            # Attempt connection to other tree\n            nearest_b = nearest(tree_b, new_node.position)\n            if dist(new_node.position, nearest_b.position) <= self.step_size:\n                if not edge_obstacle(new_node.position, nearest_b.position):\n                    # Connect path candidates\n                    path_candidate = connect_path(new_node, nearest_b)\n                    candidate_cost = new_node.cost + dist(new_node.position, nearest_b.position) + nearest_b.cost\n\n                    if candidate_cost + self.improve_tol < best_cost:\n                        best_cost = candidate_cost\n                        best_path = path_candidate\n                        found_solution = True\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n                else:\n                    no_improve_count += 1\n            else:\n                if found_solution:\n                    no_improve_count += 1\n\n            # Early termination when no meaningful improvement for long\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            # Restart no improve count if significant improvement detected\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                no_improve_count = 0\n                last_best_cost = best_cost\n\n        # Final path smoothing via shortcutting if solution found\n        if found_solution and len(best_path) > 2:\n            best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
        "objective": -12.90672,
        "time_improvement": -15.0,
        "length_improvement": 14.0,
        "smoothness_improvement": 1865.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.03639078140258789,
                "num_nodes_avg": 237.0,
                "path_length_avg": 168.02193260520104,
                "smoothness_avg": 0.04984815517379989,
                "success_improvement": 0.0,
                "time_improvement": -49.84611306639963,
                "length_improvement": 7.9045162611873945,
                "smoothness_improvement": 680.2318754714814,
                "objective_score": -6.809964785850045
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.046571874618530275,
                "num_nodes_avg": 354.8,
                "path_length_avg": 240.5937710240402,
                "smoothness_avg": 0.12631217131652547,
                "success_improvement": 0.0,
                "time_improvement": 71.15672210389786,
                "length_improvement": 19.68287412444948,
                "smoothness_improvement": 3150.1031469538016,
                "objective_score": 48.907256840608056
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.08302063941955566,
                "num_nodes_avg": 467.5,
                "path_length_avg": 130.26416789587537,
                "smoothness_avg": 0.14664374877167838,
                "success_improvement": 0.0,
                "time_improvement": -67.64825112539418,
                "length_improvement": 13.484742196660818,
                "smoothness_improvement": 1765.2976602601516,
                "objective_score": -3.377141718321006
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m1",
        "algorithm_description": "A bidirectional RRT* inspired planner that grows two trees from start and goal with rewiring and dynamic neighbor radius, incorporating path shortcutting after connection to reduce path length and improve smoothness while ensuring collision-free nodes and edges throughout. It balances exploration and optimization, seeks lowest cost connections, and maintains efficient updates for paths and parents.",
        "planning_mechanism": "The planner samples collision-free points within the map bounds, extends the nearest node of one tree towards the sample, rewires neighbors for lower-cost paths, and attempts to connect the other tree to the newly added node with rewiring as well. Upon connection, a path is extracted and post-processed with shortcutting to smooth and shorten it. The rewiring radius adapts with the tree size to balance exploration and optimization. This enables efficient bidirectional growth with asymptotic optimality and improved path quality.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, gamma=50.0, max_rewire_radius=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_rewire_radius = max_rewire_radius\n\n    def plan(self, map):\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        final_path = []\n\n        for iter in range(self.max_iter):\n            sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate trees for growth each iteration\n            if iter % 2 == 0:\n                new_node = self._extend_tree(tree_start, tree_goal, sample, obstacles, is_3d, nodes, edges, bounds)\n                if new_node:\n                    conn_node = self._connect_tree(tree_goal, new_node, obstacles, is_3d, nodes, edges, bounds)\n                    if conn_node:\n                        success = True\n                        path_start = new_node.path_from_root()\n                        path_goal = conn_node.path_from_root()\n                        if path_start and path_goal and path_start[-1] == path_goal[-1]:\n                            path_goal = path_goal[:-1]\n                        merged_path = path_start + path_goal[::-1]\n                        final_path = self._shortcut_path(merged_path, obstacles, is_3d, bounds)\n                        break\n            else:\n                new_node = self._extend_tree(tree_goal, tree_start, sample, obstacles, is_3d, nodes, edges, bounds)\n                if new_node:\n                    conn_node = self._connect_tree(tree_start, new_node, obstacles, is_3d, nodes, edges, bounds)\n                    if conn_node:\n                        success = True\n                        path_goal = new_node.path_from_root()\n                        path_start = conn_node.path_from_root()\n                        if path_goal and path_start and path_goal[-1] == path_start[-1]:\n                            path_start = path_start[:-1]\n                        merged_path = path_goal + path_start[::-1]\n                        final_path = self._shortcut_path(merged_path, obstacles, is_3d, bounds)\n                        break\n\n        return PlannerResult(success, final_path, nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near(self, tree, point, bounds):\n        n = len(tree)\n        d = len(point)\n        if n == 0:\n            return []\n        r_ddl = self.gamma * ((math.log(n) / n) ** (1.0 / d)) if n > 1 else self.step_size * 2\n        radius = max(self.step_size * 2, min(self.max_rewire_radius, r_ddl))\n        near_nodes = [node for node in tree if self._dist(node.position, point) <= radius]\n        return near_nodes\n\n    def _extend_tree(self, tree_to_extend, other_tree, sample, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree_to_extend, sample)\n        new_pos = self._steer(nearest.position, sample)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        near_nodes = self._near(tree_to_extend, new_pos, bounds)\n\n        # Choose best parent among neighbors (including nearest) with minimal cost\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in near_nodes:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost_through_nb = nb.cost + self._dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree_to_extend.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors to new node if cheaper and collision-free edge\n        for nb in near_nodes:\n            if nb == best_parent:\n                continue\n            if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                cost_through_new = new_node.cost + self._dist(new_node.position, nb.position)\n                if cost_through_new + 1e-12 < nb.cost:\n                    # Reassign parent\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = cost_through_new\n                    edges.append((new_node, nb))\n\n        return new_node\n\n    def _connect_tree(self, tree_to_connect, target_node, obstacles, is_3d, nodes, edges, bounds):\n        nearest = self._nearest(tree_to_connect, target_node.position)\n\n        new_pos = target_node.position\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        near_nodes = self._near(tree_to_connect, new_pos, bounds)\n\n        min_cost = nearest.cost + self._dist(nearest.position, new_pos)\n        best_parent = nearest\n        for nb in near_nodes:\n            if not self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                cost_through_nb = nb.cost + self._dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n        new_node = Node(new_pos, parent=None, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree_to_connect.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for nb in near_nodes:\n            if nb == best_parent:\n                continue\n            if not self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                cost_through_new = new_node.cost + self._dist(new_node.position, nb.position)\n                if cost_through_new + 1e-12 < nb.cost:\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = cost_through_new\n                    edges.append((new_node, nb))\n\n        return new_node\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path[:]\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened\n\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
        "objective": -16.5554,
        "time_improvement": -1.0,
        "length_improvement": 16.0,
        "smoothness_improvement": 1439.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.050579285621643065,
                "num_nodes_avg": 106.8,
                "path_length_avg": 164.2712937810431,
                "smoothness_avg": 0.04226815816929853,
                "success_improvement": 0.0,
                "time_improvement": -108.27003598058127,
                "length_improvement": 9.960300833383796,
                "smoothness_improvement": 561.5884621240848,
                "objective_score": -23.69688798352368
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.049871516227722165,
                "num_nodes_avg": 224.9,
                "path_length_avg": 237.86532514731707,
                "smoothness_avg": 0.10161854011327172,
                "success_improvement": 0.0,
                "time_improvement": 69.11316081994654,
                "length_improvement": 20.593707892059786,
                "smoothness_improvement": 2514.7182299904466,
                "objective_score": 45.66376413117207
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.03152651786804199,
                "num_nodes_avg": 152.6,
                "path_length_avg": 123.96994519489405,
                "smoothness_avg": 0.10533489541470797,
                "success_improvement": 0.0,
                "time_improvement": 36.33672757035219,
                "length_improvement": 17.66506521597572,
                "smoothness_improvement": 1239.8520946618717,
                "objective_score": 27.699317874000446
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "An improved bidirectional RRT* algorithm employing a spatial hashing grid for efficient nearest neighbor and near node queries, adaptive rewiring radius based on tree size and problem dimension, and incremental rewiring in both trees during node addition and connection. The planner alternates growth between start and goal trees, prunes redundant nodes during rewiring to limit tree size, and uses an efficient line-of-sight shortcutting post-processing for path smoothing and length reduction. Early termination occurs upon finding a valid path. This approach minimizes collision checks, accelerates neighbor searches, and improves path quality and smoothness while significantly reducing planning time.",
        "planning_mechanism": "The algorithm grows two trees from start and goal positions, using spatial hashing to quickly find nearest neighbors and local neighborhoods for rewiring. Each iteration it samples a free point, extends the current tree toward it, rewires locally to optimize costs, and attempts connection to the other tree. Upon connection, the path is extracted and shortcutting is applied to smooth and shorten it. Adaptive rewiring radius scales with node count and problem dimension, balancing exploration and optimization efficiently. Early exit triggers at the first feasible path to reduce planning time.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=6.0, gamma=40.0, max_rewire_radius=40.0, grid_cell_size=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_rewire_radius = max_rewire_radius\n        self.grid_cell_size = grid_cell_size  # for spatial hashing\n\n    def plan(self, map):\n        import math, random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Spatial hash grids for each tree: dict mapping cell -> list of nodes\n        def grid_hash(pos):\n            return tuple(int(pos[d] // self.grid_cell_size) for d in range(dim))\n        grid_start = {}\n        grid_goal = {}\n\n        def insert_grid(grid, node):\n            key = grid_hash(node.position)\n            if key not in grid:\n                grid[key] = []\n            grid[key].append(node)\n\n        insert_grid(grid_start, start_root)\n        insert_grid(grid_goal, goal_root)\n\n        def remove_grid(grid, node):\n            key = grid_hash(node.position)\n            if key in grid:\n                try:\n                    grid[key].remove(node)\n                    if not grid[key]:\n                        del grid[key]\n                except ValueError:\n                    pass\n\n        def neighbors_grid(grid, point, radius):\n            # Return nodes in grid cells intersecting radius ball around point\n            radius_cells = int(math.ceil(radius / self.grid_cell_size))\n            center_cell = grid_hash(point)\n            results = []\n            rsq = radius*radius\n            for dx in range(-radius_cells, radius_cells+1):\n                for dy in range(-radius_cells, radius_cells+1):\n                    if dim == 2:\n                        cell = (center_cell[0] + dx, center_cell[1] + dy)\n                        if cell in grid:\n                            for n in grid[cell]:\n                                d2 = sum((n.position[i]-point[i])**2 for i in range(dim))\n                                if d2 <= rsq:\n                                    results.append(n)\n                    else:\n                        for dz in range(-radius_cells, radius_cells+1):\n                            cell = (center_cell[0] + dx, center_cell[1] + dy, center_cell[2] + dz)\n                            if cell in grid:\n                                for n in grid[cell]:\n                                    d2 = sum((n.position[i]-point[i])**2 for i in range(dim))\n                                    if d2 <= rsq:\n                                        results.append(n)\n            return results\n\n        def dist(a, b):\n            s = 0.0\n            for i in range(dim):\n                d = a[i] - b[i]\n                s += d * d\n            return math.sqrt(s)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            return tuple(frm[i] + (to[i] - frm[i]) * self.step_size / d for i in range(dim))\n\n        def is_in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            distance = dist(f, t)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                inter = tuple(f[j] + (t[j] - f[j]) * i / steps for j in range(dim))\n                if is_in_obstacle(inter):\n                    return True\n            return False\n\n        def nearest(grid, point):\n            # Search neighbor cells expanding until at least one node found\n            radius = self.grid_cell_size\n            while True:\n                candidates = neighbors_grid(grid, point, radius)\n                if candidates:\n                    best = candidates[0]\n                    best_d = dist(best.position, point)\n                    for n in candidates[1:]:\n                        d2 = dist(n.position, point)\n                        if d2 < best_d:\n                            best = n\n                            best_d = d2\n                    return best\n                radius += self.grid_cell_size\n                if radius > max(bounds) * 2:\n                    # fallback linear search on all nodes\n                    all_nodes = []\n                    for cell_nodes in grid.values():\n                        all_nodes.extend(cell_nodes)\n                    if not all_nodes:\n                        return None\n                    best = all_nodes[0]\n                    best_d = dist(best.position, point)\n                    for n in all_nodes[1:]:\n                        d2 = dist(n.position, point)\n                        if d2 < best_d:\n                            best = n\n                            best_d = d2\n                    return best\n\n        def near_nodes(tree_grid, point, n_size):\n            # Adaptive radius per RRT*: r = min(max_rewire_radius, gamma*(log(n)/n)^{1/d})\n            if n_size <= 1:\n                radius = self.step_size * 3.0\n            else:\n                radius = self.gamma * ((math.log(n_size) / n_size) ** (1.0 / dim))\n                radius = max(radius, self.step_size * 2.0)\n                radius = min(radius, self.max_rewire_radius)\n            return neighbors_grid(tree_grid, point, radius)\n\n        def add_node(tree, tree_grid, nodes_all, edges_all, new_pos, parent_node):\n            cost_new = parent_node.cost + dist(parent_node.position, new_pos)\n            new_node = Node(new_pos, parent=parent_node, cost=cost_new)\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges_all.append((parent_node, new_node))\n            insert_grid(tree_grid, new_node)\n            return new_node\n\n        def rewire(tree, tree_grid, edges_all, nodes_all, new_node, near_nodes_list):\n            # For efficiency, rewire only nodes in near_nodes_list\n            for n in near_nodes_list:\n                if n == new_node.parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, n.position)\n                if alt_cost + 1e-12 < n.cost and not edge_obstacle(new_node.position, n.position):\n                    # Remove old edge\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        try:\n                            edges_all.remove((n.parent, n))\n                        except Exception:\n                            pass\n                    new_node.add_child(n)\n                    n.cost = alt_cost\n                    edges_all.append((new_node, n))\n                    # Propagate cost updates downstream via BFS\n                    q = [n]\n                    while q:\n                        curr = q.pop(0)\n                        for c in curr.children:\n                            old_cost = c.cost\n                            c.cost = curr.cost + dist(curr.position, c.position)\n                            if c.cost + 1e-12 < old_cost:\n                                q.append(c)\n\n        def prune_subtree(node, tree, tree_grid, edges_all, nodes_all):\n            # Remove node and all descendants to limit tree size and discard hopeless branches\n            stack = [node]\n            to_remove = []\n            while stack:\n                n = stack.pop()\n                to_remove.append(n)\n                stack.extend(n.children)\n            for n in to_remove:\n                if n.parent:\n                    n.parent.remove_child(n)\n                    try:\n                        edges_all.remove((n.parent, n))\n                    except Exception:\n                        pass\n                if n in tree:\n                    tree.remove(n)\n                if n in nodes_all:\n                    nodes_all.remove(n)\n                remove_grid(tree_grid, n)\n\n        def extract_path(n_start, n_goal):\n            path_start = n_start.path_from_root()\n            path_goal = n_goal.path_from_root()\n            # Remove duplicate join node position once\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                # Find furthest node connectable in straight line\n                j = len(path) - 1\n                while j > i + 1:\n                    if not edge_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        success = False\n        final_path = []\n\n        # Alternate growing tree: 0 for start_tree, 1 for goal_tree\n        grow_turn = 0\n\n        for _ in range(self.max_iter):\n            # Sample free point uniformly inside bounds\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    break\n\n            if grow_turn == 0:\n                tree_a, grid_a, tree_b, grid_b = tree_start, grid_start, tree_goal, grid_goal\n            else:\n                tree_a, grid_a, tree_b, grid_b = tree_goal, grid_goal, tree_start, grid_start\n\n            # Extend tree_a towards sample\n            nearest_node = nearest(grid_a, sample)\n            if nearest_node is None:\n                grow_turn = 1 - grow_turn\n                continue\n            new_pos = steer(nearest_node.position, sample)\n            if is_in_obstacle(new_pos) or edge_obstacle(nearest_node.position, new_pos):\n                grow_turn = 1 - grow_turn\n                continue\n\n            near = near_nodes(grid_a, new_pos, len(tree_a))\n            # Choose best parent among near nodes who can connect\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in near:\n                if nb == nearest_node:\n                    continue\n                if not edge_obstacle(nb.position, new_pos):\n                    cost_through_nb = nb.cost + dist(nb.position, new_pos)\n                    if cost_through_nb < min_cost:\n                        min_cost = cost_through_nb\n                        best_parent = nb\n\n            new_node = add_node(tree_a, grid_a, nodes, edges, new_pos, best_parent)\n\n            # Rewire near nodes to new node\n            rewire(tree_a, grid_a, edges, nodes, new_node, near)\n\n            # Try connect new_node to other tree\n            near_other = near_nodes(grid_b, new_node.position, len(tree_b))\n            # Find closest node in other tree connectable by edge\n            min_connect_cost = float('inf')\n            connect_node = None\n            for on in near_other:\n                if dist(on.position, new_node.position) <= self.step_size and not edge_obstacle(on.position, new_node.position):\n                    cost_connect = new_node.cost + dist(new_node.position, on.position) + on.cost\n                    if cost_connect < min_connect_cost:\n                        min_connect_cost = cost_connect\n                        connect_node = on\n            if connect_node:\n                # Extract path\n                final_path = extract_path(new_node, connect_node)\n                final_path = shortcut_path(final_path)\n                success = True\n                break\n\n            grow_turn = 1 - grow_turn  # alternate tree\n\n        return PlannerResult(success, final_path, nodes, edges)",
        "objective": -11.69807,
        "time_improvement": -21.0,
        "length_improvement": 17.0,
        "smoothness_improvement": 1526.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.028065919876098633,
                "num_nodes_avg": 86.4,
                "path_length_avg": 163.49572132394655,
                "smoothness_avg": 0.047919740128782015,
                "success_improvement": 0.0,
                "time_improvement": -15.566878230521153,
                "length_improvement": 10.385404386850459,
                "smoothness_improvement": 650.0479923966562,
                "objective_score": 4.811419124937211
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.046169471740722653,
                "num_nodes_avg": 233.7,
                "path_length_avg": 234.08993011810594,
                "smoothness_avg": 0.10042545256115583,
                "success_improvement": 0.0,
                "time_improvement": 71.40594157650585,
                "length_improvement": 21.854043421531074,
                "smoothness_improvement": 2484.019227928276,
                "objective_score": 46.95430466551178
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.10878512859344483,
                "num_nodes_avg": 414.2,
                "path_length_avg": 120.41487182477995,
                "smoothness_avg": 0.12131448482536566,
                "success_improvement": 0.0,
                "time_improvement": -119.67593461881035,
                "length_improvement": 20.026175674003266,
                "smoothness_improvement": 1443.1112924748393,
                "objective_score": -16.67151851886695
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "A Bidirectional Informed RRT* with Adaptive Radius and Progressive Rewiring integrating a balanced ellipsoidal informed sampler, efficient linear nearest neighbor search with incremental rewiring, and robust early stopping based on solution stagnation and path cost improvement. The algorithm alternately expands start and goal trees, prioritizes smoother and shorter paths by cost-aware parent selection, adaptively adjusts rewiring radius based on the number of nodes and best cost, and applies a final multi-pass shortcut smoothing to yield efficient, low-cost, and smooth paths within bounded planning time.",
        "planning_mechanism": "The planner maintains two trees grown alternately from start and goal. Sampling is initially uniform and focuses progressively within a shrinking ellipsoid around the currently best path. The nearest parent is selected by minimal cost plus a small curvature penalty. An adaptive rewiring radius shrinks as better solutions are found, enabling local optimization. Each new node attempts rewiring neighbors within radius if it improves cost. The trees connect when nodes are near and collision free. Early termination occurs if no improvements happen in prolonged iterations. After planning, a multi-pass shortcutting cleans and smooths the path to reduce length and curvature.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=5.5, n_near_const=28,\n                 max_no_improve=70, improve_tol=1e-6, shortcut_iters=300):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a, b: math.dist(a, b)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if (ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od):\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if (ox <= px <= ox + ow and oy <= py <= oy + oh):\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps +1):\n                inter = tuple(f[d] + (t[d] - f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, p):\n            best = None\n            best_d = float('inf')\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 >= best_d*best_d:\n                        break\n                else:\n                    d = math.sqrt(d2)\n                    if d < best_d:\n                        best = n\n                        best_d = d\n            return best, best_d\n\n        def near_nodes(tree, p, radius):\n            r2 = radius*radius\n            res = []\n            px = p\n            for n in tree:\n                d2 = 0.0\n                for i in range(dim):\n                    dd = n.position[i] - px[i]\n                    d2 += dd*dd\n                    if d2 > r2:\n                        break\n                if d2 <= r2:\n                    res.append(n)\n            return res\n\n        def adaptive_radius(n_nodes, c_best):\n            gamma = self.n_near_const\n            if n_nodes == 0:\n                return self.step_size * 3.0\n            radius = min((gamma * (math.log(n_nodes)/n_nodes))**(1/dim), self.step_size * 6.0)\n            if c_best == float('inf'):\n                return radius\n            shrink = max(0.3, c_best / (c_min * 3.1))\n            return max(self.step_size * 0.8, radius * shrink)\n\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                # Uniform sample in bounds avoiding boundary issues\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n            U = [unit_a1]\n            for idx in range(dim -1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j] - proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0.0]*dim)\n            r1 = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val > 0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n\n            max_attempt = 50\n            for _ in range(max_attempt):\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n                scaled = [radii[i]*point_ball[i] for i in range(dim)]\n                point_rot = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rot[j] += scaled[i]*U[i][j]\n                sample = tuple(center[i] + point_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not in_obstacle(sample):\n                    return sample\n            # fallback\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def extract_path(node):\n            return node.path_from_root()\n\n        def connect_path(n_start, n_goal):\n            path_s = extract_path(n_start)\n            path_g_rev = extract_path(n_goal)\n            path_g = path_g_rev[::-1]\n            if len(path_s) > 0 and len(path_g) > 0 and path_s[-1] == path_g[0]:\n                return path_s + path_g[1:]\n            else:\n                return path_s + path_g\n\n        def curvature_penalty(p_parent, p_child, p_new):\n            # Small curvature cost for smoother parent selection\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_child[i] - p_parent[i] for i in range(dim))\n            v2 = tuple(p_new[i] - p_child[i] for i in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))/(len1*len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        def add_node(tree, new_pos, nodes_all, edges, c_best):\n            nn, _ = nearest(tree, new_pos)\n            if nn is None:\n                return None\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(nodes_all)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = near_nodes(tree, new_pos_steered, radius)\n\n            alpha_curv = 0.04\n            best_parent = nn\n            best_cost = nn.cost + dist(nn.position, new_pos_steered)\n            best_score = best_cost + alpha_curv * curvature_penalty(nn.parent.position if nn.parent else None, nn.position, new_pos_steered)\n\n            for candidate in near:\n                if candidate == nn:\n                    continue\n                if edge_obstacle(candidate.position, new_pos_steered):\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, new_pos_steered)\n                curv_cost = alpha_curv * curvature_penalty(candidate.parent.position if candidate.parent else None, candidate.position, new_pos_steered)\n                score = candidate_cost + curv_cost\n                if score + self.improve_tol < best_score:\n                    best_parent = candidate\n                    best_cost = candidate_cost\n                    best_score = score\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = best_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node if better path found\n            near_rewire = near_nodes(tree, new_node.position, radius)\n            for near_n in near_rewire:\n                if near_n == best_parent or near_n == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost and not edge_obstacle(new_node.position, near_n.position):\n                    # Additionally check curvature penalty for rewiring\n                    curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, near_n.position)\n                    curv_old = curvature_penalty(near_n.parent.parent.position if near_n.parent and near_n.parent.parent else None, near_n.parent.position if near_n.parent else None, near_n.position)\n                    if alpha_curv * curv_new <= alpha_curv * curv_old + 0.15:  # allow slight increase for cost gain\n                        if near_n.parent:\n                            near_n.parent.remove_child(near_n)\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_n)\n                        near_n.cost = alt_cost\n                        edges.append((new_node, near_n))\n\n            return new_node\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path = list(path)\n            changed = True\n            iter_count = 0\n            while changed and iter_count < self.shortcut_iters:\n                changed = False\n                iter_count +=1\n                i=0\n                while i < len(path)-2:\n                    max_j = min(len(path)-1, i + 7 + random.randint(0,4))\n                    j = random.randint(i+2, max_j) if max_j > i+2 else i+2\n                    if j > i+1 and not edge_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        # Initialize bidirectional trees\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate growing trees: even iterations start-tree, odd goal-tree\n            if it % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            new_node = add_node(tree_a, sample_pt, nodes_all, edges, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                continue\n\n            nbr_node, nbr_dist = nearest(tree_b, new_node.position)\n            if nbr_node and nbr_dist <= self.step_size and not edge_obstacle(new_node.position, nbr_node.position):\n                candidate_path = connect_path(new_node, nbr_node)\n                candidate_cost = new_node.cost + dist(new_node.position, nbr_node.position) + nbr_node.cost\n\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            elif found_solution:\n                no_improve_count += 1\n\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                last_best_cost = best_cost\n                no_improve_count = 0\n\n        if found_solution and len(best_path) > 3:\n            # Multiple progressive shortcut passes to enhance path quality\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
        "objective": -23.40566,
        "time_improvement": 28.0,
        "length_improvement": 13.0,
        "smoothness_improvement": 1419.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.02814173698425293,
                "num_nodes_avg": 174.7,
                "path_length_avg": 170.78044027086807,
                "smoothness_avg": 0.041064375085066517,
                "success_improvement": 0.0,
                "time_improvement": -15.879069904428114,
                "length_improvement": 6.3925344982841175,
                "smoothness_improvement": 542.746642799047,
                "objective_score": 1.7855329416372712
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04101948738098145,
                "num_nodes_avg": 312.8,
                "path_length_avg": 241.95417433722574,
                "smoothness_avg": 0.08769719153831615,
                "success_improvement": 0.0,
                "time_improvement": 74.59547240955273,
                "length_improvement": 19.228732341469897,
                "smoothness_improvement": 2156.5119040147615,
                "objective_score": 44.698440647821556
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.036681413650512695,
                "num_nodes_avg": 276.1,
                "path_length_avg": 130.08856674191185,
                "smoothness_avg": 0.13041023521317593,
                "success_improvement": 0.0,
                "time_improvement": 25.927156303411085,
                "length_improvement": 13.601368121895007,
                "smoothness_improvement": 1558.8085660293298,
                "objective_score": 23.733010594306975
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "A bidirectional RRT* planner with adaptive radius rewiring, progressive heuristic ellipsoidal sampling focusing search on promising paths, and early termination on convergence stagnation. It uses dynamic neighbor radius scaled with the logarithm of current tree size, adaptive step size that balances exploration and refinement, and incremental cost-based rewiring with bidirectional tree connection attempts. Path shortcutting is performed iteratively post solution to shorten and smooth the path efficiently.",
        "planning_mechanism": "The planner grows two trees from start and goal nodes alternately, samples new points focusing inside an informed ellipsoid shaped by current best solution cost to guide exploration. New nodes are connected using parent selection minimizing path cost within a dynamically computed neighbor radius that adapts as the tree grows. Rewiring adjusts tree topology to reduce costs. When the two trees connect within step distance, the combined path is saved if better. Early termination triggers if no cost improvement occurs over a configurable window, reducing runtime. Post processing shortcuts the path to remove unnecessary waypoints and improves path smoothness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, neighbor_factor=2.0, no_improve_limit=60, improve_tol=1e-7, shortcut_iters=250):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor\n        self.no_improve_limit = no_improve_limit\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def dist(a,b):\n            return math.sqrt(sum((a[i]-b[i])**2 for i in range(dim)))\n\n        def in_obstacle(p):\n            px = p + (0.0,)*(3-dim) if dim<3 else p\n            for obs in obstacles:\n                if dim == 2:\n                    x,y,w,h = obs\n                    if x <= px[0] <= x+w and y <= px[1] <= y+h:\n                        return True\n                else:\n                    x,y,z,w,h,d = obs\n                    if x <= px[0] <= x+w and y <= px[1] <= y+h and z <= px[2] <= z+d:\n                        return True\n            return False\n\n        def edge_obstacle(f,t,resolution=0.4):\n            length = dist(f,t)\n            if length < 1e-12:\n                return False\n            steps = max(2,int(length/resolution))\n            for i in range(steps+1):\n                interp = tuple(f[j] + (t[j]-f[j])*(i/steps) for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm,to,max_step):\n            d = dist(frm,to)\n            if d <= max_step:\n                return to\n            ratio = max_step/d\n            return tuple(frm[i]+(to[i]-frm[i])*ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d += diff*diff\n                    if d > best_dist*best_dist:\n                        break\n                else:\n                    d = math.sqrt(d)\n                    if d < best_dist:\n                        best = node\n                        best_dist = d\n            return best\n\n        def neighbor_radius(tree_len):\n            # Adaptive neighbor radius based on tree size, theoretical RRT* scaling\n            if tree_len < 2:\n                return self.step_size * 2.0\n            return min(self.step_size*5.0, self.neighbor_factor * (math.log(tree_len)/tree_len)**(1.0/dim)*max(bounds))\n\n        def neighbors(tree, point, radius):\n            neigh = []\n            r_sq = radius*radius\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d_sq += diff*diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    neigh.append(node)\n            return neigh\n\n        c_min = dist(start, goal)\n\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            center = tuple((start[i]+goal[i])*0.5 for i in range(dim))\n            a1 = [goal[i]-start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            # Orthonormal basis U via Gram-Schmidt (dim x dim)\n            U = [unit_a1]\n            for idx in range(dim-1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j]-proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    base = [x/norm_base for x in base]\n                else:\n                    base = [0.0]*dim\n                U.append(base)\n\n            r1 = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val>0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x/norm_ball for x in x_ball]\n                u_rand = random.random()**(1.0/dim)\n                point_ball = [coord*u_rand for coord in unit_ball]\n\n                point_scaled = [radii[i]*point_ball[i] for i in range(dim)]\n\n                # Rotate by U matrix transpose\n                point_rot = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rot[j] += point_scaled[i]*U[i][j]\n\n                sample = tuple(center[i]+point_rot[i] for i in range(dim))\n                if all(0.0<=sample[i]<=bounds[i] for i in range(dim)):\n                    return sample\n\n        def add_node(tree, sample, all_nodes, edges, best_cost):\n            nn = nearest(tree, sample)\n            new_pos = steer(nn.position, sample, self.step_size)\n            if in_obstacle(new_pos) or edge_obstacle(nn.position,new_pos):\n                return None\n            radius = neighbor_radius(len(tree))\n            near = neighbors(tree, new_pos, radius)\n            best_parent = nn\n            min_cost = nn.cost + dist(nn.position,new_pos)\n            for candidate in near:\n                cand_cost = candidate.cost + dist(candidate.position,new_pos)\n                if cand_cost + self.improve_tol < min_cost and not edge_obstacle(candidate.position,new_pos):\n                    best_parent = candidate\n                    min_cost = cand_cost\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent,new_node))\n\n            # Rewire neighbors through new node if beneficial\n            for neighbor in near:\n                if neighbor is best_parent: \n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost + self.improve_tol < neighbor.cost and not edge_obstacle(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        neighbor.parent.remove_child(neighbor)\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n                    new_node.add_child(neighbor)\n                    neighbor.cost = alt_cost\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def extract_path(node_s, node_g):\n            path_s = node_s.path_from_root()\n            path_g = node_g.path_from_root()\n            # Avoid duplicate duplicate connecting node\n            if path_s and path_g and path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            else:\n                return path_s + path_g[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            count = 0\n            changed = True\n            while changed and count < self.shortcut_iters:\n                changed = False\n                count += 1\n                i = 0\n                while i < len(path)-2:\n                    max_jump = min(len(path)-1, i+6)\n                    j = random.randint(i+2, max_jump)\n                    if not edge_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        start_node = Node(start)\n        goal_node = Node(goal)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        found = False\n        no_improve_count = 0\n        last_best = best_cost\n\n        for itr in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost)\n\n            if itr % 2 == 0:\n                main_tree, other_tree = tree_start, tree_goal\n            else:\n                main_tree, other_tree = tree_goal, tree_start\n\n            new_node = add_node(main_tree, sample_pt, all_nodes, edges, best_cost)\n            if new_node is None:\n                continue\n\n            near_connect = nearest(other_tree, new_node.position)\n            step_dist = dist(near_connect.position, new_node.position)\n            if step_dist <= self.step_size and not edge_obstacle(new_node.position, near_connect.position):\n                candidate_cost = new_node.cost + near_connect.cost + step_dist\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = extract_path(new_node, near_connect)\n                    found = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            else:\n                if found:\n                    no_improve_count += 1\n\n            if found:\n                # Early stopping on stagnation of improvement\n                if best_cost + self.improve_tol < last_best:\n                    last_best = best_cost\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                if no_improve_count >= self.no_improve_limit:\n                    break\n\n        if found and len(best_path) > 3:\n            best_path = shortcut_path(best_path)\n\n        if found:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
        "objective": 6.30946,
        "time_improvement": -81.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1172.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.08813977241516113,
                "num_nodes_avg": 171.3,
                "path_length_avg": 155.94724987804915,
                "smoothness_avg": 0.037895327969512546,
                "success_improvement": 0.0,
                "time_improvement": -262.9326382650782,
                "length_improvement": 14.522841199531285,
                "smoothness_improvement": 493.1441737446706,
                "objective_score": -67.70036589108133
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.08728914260864258,
                "num_nodes_avg": 314.3,
                "path_length_avg": 226.58476458100463,
                "smoothness_avg": 0.07942344506505501,
                "success_improvement": 0.0,
                "time_improvement": 45.93936752179157,
                "length_improvement": 24.35948370202769,
                "smoothness_improvement": 1943.6224479190457,
                "objective_score": 38.11561271734931
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.061713361740112306,
                "num_nodes_avg": 259.4,
                "path_length_avg": 118.83941821204158,
                "smoothness_avg": 0.09275591661871693,
                "success_improvement": 0.0,
                "time_improvement": -24.621265737464196,
                "length_improvement": 21.072516948544795,
                "smoothness_improvement": 1079.8484128604985,
                "objective_score": 10.65637251219011
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that combines efficient nearest neighbor approximation with an adaptive rewiring radius and incremental pruning to reduce redundant nodes. It alternately grows two trees from start and goal, uses approximate KD-tree-like spatial hashing for faster nearest and near node searches, performs rewiring for local path optimization, and incorporates a fast path shortcutting step at connection to improve path length and smoothness. The planner also dynamically adjusts its rewiring radius based on tree size and dimensionality to limit rewiring overhead and integrates early stopping when improvement stalls, all designed to minimize planning time and path length without excessive computational effort.",
        "planning_mechanism": "The planner alternately grows two trees towards randomly sampled free points, selecting optimal parents from nearby nodes with fast approximate neighbor queries. After each extension, it attempts to connect the opposite tree. Upon successful connection, it extracts the path and performs shortcutting to remove unnecessary waypoints. Adaptive neighbor radius and incremental pruning keep the trees efficient, while an early stopping condition prevents wasteful iterations once no meaningful improvements occur.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=5.0, gamma=35.0,\n                 max_rewire_radius=40.0, early_stop_no_improve=80,\n                 shortcut_iter=160):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.gamma = gamma\n        self.max_rewire_radius = max_rewire_radius\n        self.early_stop_no_improve = early_stop_no_improve\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        # Spatial hashing grid params for approximate neighbors\n        cell_size = max(self.step_size, 5.0)\n        def grid_hash(pos):\n            return tuple(int(p // cell_size) for p in pos)\n\n        # Spatial hash maps: cell => list of nodes\n        start_grid = {}\n        goal_grid = {}\n\n        def insert_node(grid, node):\n            cell = grid_hash(node.position)\n            if cell not in grid:\n                grid[cell] = []\n            grid[cell].append(node)\n\n        insert_node(start_grid, start_root)\n        insert_node(goal_grid, goal_root)\n\n        def get_near_nodes(grid, pos, radius):\n            cell_coords = grid_hash(pos)\n            r_cells = int(math.ceil(radius / cell_size))\n            candidates = []\n            for dx in range(-r_cells, r_cells + 1):\n                for dy in range(-r_cells, r_cells + 1):\n                    if dim == 2:\n                        cell = (cell_coords[0]+dx, cell_coords[1]+dy)\n                        if cell in grid:\n                            candidates.extend(grid[cell])\n                    else:\n                        for dz in range(-r_cells, r_cells + 1):\n                            cell = (cell_coords[0]+dx, cell_coords[1]+dy, cell_coords[2]+dz)\n                            if cell in grid:\n                                candidates.extend(grid[cell])\n            radius_sq = radius * radius\n            return [n for n in candidates if self._dist_sq(n.position, pos) <= radius_sq]\n\n        def remove_node(grid, node):\n            cell = grid_hash(node.position)\n            if cell in grid and node in grid[cell]:\n                grid[cell].remove(node)\n                if not grid[cell]:\n                    del grid[cell]\n\n        def update_node_grid(grid, node, old_pos):\n            old_cell = grid_hash(old_pos)\n            new_cell = grid_hash(node.position)\n            if old_cell != new_cell:\n                if old_cell in grid and node in grid[old_cell]:\n                    grid[old_cell].remove(node)\n                    if not grid[old_cell]:\n                        del grid[old_cell]\n                if new_cell not in grid:\n                    grid[new_cell] = []\n                grid[new_cell].append(node)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_counter = 0\n\n        # Precompute c_min distance between start and goal for radius calc\n        c_min = self._dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            # Adaptive rewiring radius based on total nodes and dimension\n            total_nodes = len(tree_start) + len(tree_goal)\n            if total_nodes > 1:\n                radius = min(self.max_rewire_radius,\n                             self.gamma * ((math.log(total_nodes) / total_nodes) ** (1/dim)))\n                radius = max(radius, self.step_size * 2.0)\n            else:\n                radius = self.step_size * 2.0\n\n            # Sample collision-free point uniformly\n            sample = self._sample_free(bounds, obstacles, is_3d)\n\n            # Alternate tree extension\n            extend_tree, connect_tree = (tree_start, tree_goal) if it % 2 == 0 else (tree_goal, tree_start)\n            extend_grid = start_grid if it % 2 == 0 else goal_grid\n            connect_grid = goal_grid if it % 2 == 0 else start_grid\n\n            # Extend phase\n            nearest_node = self._approx_nearest(extend_tree, extend_grid, sample, radius, is_3d)\n            if nearest_node is None:\n                continue  # safety\n\n            new_pos = self._steer(nearest_node.position, sample)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            near_nodes = get_near_nodes(extend_grid, new_pos, radius)\n\n            # Select best parent\n            min_cost = nearest_node.cost + self._dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nb in near_nodes:\n                if nb == nearest_node:\n                    continue\n                if self._is_edge_in_obstacle(nb.position, new_pos, obstacles, is_3d):\n                    continue\n                cost_through_nb = nb.cost + self._dist(nb.position, new_pos)\n                if cost_through_nb < min_cost:\n                    min_cost = cost_through_nb\n                    best_parent = nb\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            extend_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            insert_node(extend_grid, new_node)\n\n            # Rewire neighbors to new_node if cheaper and collision free\n            for nb in near_nodes:\n                if nb == best_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, nb.position, obstacles, is_3d):\n                    continue\n                alt_cost = new_node.cost + self._dist(new_node.position, nb.position)\n                if alt_cost + 1e-12 < nb.cost:\n                    # Reassign parent, update edges\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except Exception:\n                            pass\n                    new_node.add_child(nb)\n                    nb.cost = alt_cost\n                    edges.append((new_node, nb))\n\n            # Try connect other tree\n            nearest_connect = self._approx_nearest(connect_tree, connect_grid, new_node.position, radius, is_3d)\n            if nearest_connect is None:\n                continue\n\n            dist_connect = self._dist(new_node.position, nearest_connect.position)\n            if dist_connect <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_connect.position, obstacles, is_3d):\n                    path_cost = new_node.cost + dist_connect + nearest_connect.cost\n                    if path_cost + 1e-12 < best_cost:\n                        best_cost = path_cost\n                        # Extract path:\n                        path_start = new_node.path_from_root()\n                        path_goal = nearest_connect.path_from_root()\n                        # Merge paths, avoiding repeated node\n                        if path_start[-1] == path_goal[-1]:\n                            path_goal = path_goal[:-1]\n                        raw_path = path_start + path_goal[::-1]\n                        # Shortcut to improve path\n                        best_path = self._shortcut_path(raw_path, obstacles, is_3d, bounds, iter_lim=self.shortcut_iter)\n                        found_solution = True\n                        no_improve_counter = 0\n                    else:\n                        no_improve_counter += 1\n            else:\n                # No connection improvement this iteration\n                no_improve_counter += 1\n\n            # Early stop if no improvement for long\n            if found_solution and no_improve_counter >= self.early_stop_no_improve:\n                break\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _approx_nearest(self, tree, grid, point, radius, is_3d):\n        # Use spatial hash to get candidates in vicinity\n        # Combine exact nearest from candidates\n        candidates = []\n        # Get candidates from surrounding cells (3x3 or 3x3x3)\n        dim = len(point)\n        cell_size = max(self.step_size, 5.0)\n        cell = tuple(int(p // cell_size) for p in point)\n        r_cells = 1  # radius small enough, consider nearby grid cells only\n        for dx in range(-r_cells, r_cells+1):\n            for dy in range(-r_cells, r_cells+1):\n                if dim == 2:\n                    c = (cell[0]+dx, cell[1]+dy)\n                    if c in grid:\n                        candidates.extend(grid[c])\n                else:\n                    for dz in range(-r_cells, r_cells+1):\n                        c = (cell[0]+dx, cell[1]+dy, cell[2]+dz)\n                        if c in grid:\n                            candidates.extend(grid[c])\n        if not candidates:\n            # fallback linear search if no candidates found\n            candidates = tree\n\n        best = None\n        best_dist = float('inf')\n        for n in candidates:\n            d = self._dist(n.position, point)\n            if d < best_dist:\n                best = n\n                best_dist = d\n        return best\n\n    def _steer(self, from_pos, to_pos):\n        dist = self._dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _dist(self, a, b):\n        return math.dist(a, b)\n\n    def _dist_sq(self, a, b):\n        return sum((a[i] - b[i])**2 for i in range(len(a)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = self._dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, iter_lim=160):\n        if len(path) < 3:\n            return list(path)\n        path_new = list(path)\n        iters = 0\n        while iters < iter_lim:\n            if len(path_new) < 3:\n                break\n            i = random.randint(0, len(path_new) - 3)\n            j = random.randint(i + 2, len(path_new) -1)\n            if not self._is_edge_in_obstacle(path_new[i], path_new[j], obstacles, is_3d):\n                # shortcut by removing intermediate nodes between i and j\n                del path_new[i+1:j]\n            iters += 1\n        return path_new",
        "objective": 2.70963,
        "time_improvement": -68.0,
        "length_improvement": 18.0,
        "smoothness_improvement": 1359.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.06853735446929932,
                "num_nodes_avg": 226.7,
                "path_length_avg": 162.4933129975047,
                "smoothness_avg": 0.04033359017827268,
                "success_improvement": 0.0,
                "time_improvement": -182.2158736703629,
                "length_improvement": 10.934840274749654,
                "smoothness_improvement": 531.3082720828986,
                "objective_score": -45.44731657584458
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.10013775825500489,
                "num_nodes_avg": 463.7,
                "path_length_avg": 231.6140031793218,
                "smoothness_avg": 0.10057505556673607,
                "success_improvement": 0.0,
                "time_improvement": 37.98185679876864,
                "length_improvement": 22.680579099302726,
                "smoothness_improvement": 2487.868621016545,
                "objective_score": 37.442247604294955
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.07947943210601807,
                "num_nodes_avg": 412.2,
                "path_length_avg": 118.59985783137168,
                "smoothness_avg": 0.09098141231233955,
                "success_improvement": 0.0,
                "time_improvement": -60.49729183216582,
                "length_improvement": 21.23162154674627,
                "smoothness_improvement": 1057.2768490636613,
                "objective_score": -0.12383037628367877
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "An enhanced bidirectional RRT* planner with adaptive variable step steering, relaxed curvature-aware rewiring, and dynamic pruning thresholds preserving promising shortcuts and global path optimality. The planner balances exploration and exploitation via alternate tree growth, ellipsoidal informed sampling post initial solution, and accelerated neighbor search via spatial hashing. It updates parents and rewires neighbors based on combined cost and softened curvature penalties, while dynamically adjusting pruning to maintain connectivity and prevent premature subtree removal. Multi-stage iterative global shortcutting with curvature checks refines path smoothness and length.",
        "planning_mechanism": "The planner grows start and goal trees alternately using spatial hashing for efficient neighbor queries. Sampling transitions from uniform to ellipsoidal informed after a first feasible path is found. Steering step size adapts per local edge length and obstacle distance to allow finer refinement when needed. Parent selection and rewiring minimize sum of Euclidean cost plus a softened curvature penalty, favoring shorter, smoother connections. Pruning thresholds adapt dynamically to preserve potentially beneficial subtrees and maintain tree connectivity, preventing degradation of path quality. The final solution undergoes progressive global shortcutting smoothing with curvature checks to optimize length and smoothness before returning.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 initial_step=6.5,\n                 min_step=1.2,\n                 max_step=12.0,\n                 n_near_const=25,\n                 max_no_improve=75,\n                 improve_tol=1e-7,\n                 shortcut_iters=450,\n                 prune_factor_init=1.8,\n                 prune_factor_min=1.2):\n        self.max_iter = max_iter\n        self.initial_step = initial_step\n        self.min_step = min_step\n        self.max_step = max_step\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n        self.prune_factor_init = prune_factor_init\n        self.prune_factor_min = prune_factor_min\n\n    def plan(self, map):\n        import math, random, time\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is3d = (dim == 3)\n        dist = lambda a,b: math.dist(a,b)\n\n        # Collision checking\n        def in_obstacle(p):\n            px = (p + (0,0,0))[:3]\n            for o in obstacles:\n                if is3d:\n                    ox, oy, oz, ow, oh, od = o\n                    if ox <= px[0] <= ox+ow and oy <= px[1] <= oy+oh and oz <= px[2] <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = o\n                    if ox <= px[0] <= ox+ow and oy <= px[1] <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,res=1.0):\n            d = dist(a,b)\n            if d < 1e-14:\n                return False\n            steps = max(2,int(d/res))\n            for i in range(steps+1):\n                interp = tuple(a[j] + (b[j]-a[j]) * i/steps for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def in_bounds(pos):\n            for i in range(dim):\n                if pos[i] < 0 or pos[i] > bounds[i]:\n                    return False\n            return True\n\n        # Spatial hashing neighbor search\n        class SpatialHash:\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.inv = 1.0 / cell_size\n                self.dim = len(bounds)\n                self.bounds = bounds\n                self.cells = {}\n            def _coords(self,pos):\n                return tuple(int(pos[i]*self.inv) for i in range(self.dim))\n            def insert(self,n):\n                c = self._coords(n.position)\n                self.cells.setdefault(c, []).append(n)\n            def remove(self,n):\n                c = self._coords(n.position)\n                if c in self.cells and n in self.cells[c]:\n                    self.cells[c].remove(n)\n                    if not self.cells[c]:\n                        del self.cells[c]\n            def nearby(self,pos,radius):\n                c = self._coords(pos)\n                r_cells = int(math.ceil(radius*self.inv))\n                neighbors = []\n                deltas = []\n                def gen_deltas(dim,r):\n                    if dim == 1:\n                        return [(dx,) for dx in range(-r,r+1)]\n                    else:\n                        prev = gen_deltas(dim-1,r)\n                        full = []\n                        for dx in range(-r,r+1):\n                            for p in prev:\n                                full.append((dx,)+p)\n                        return full\n                deltas = gen_deltas(self.dim,r_cells)\n                r_sq = radius*radius\n                for d in deltas:\n                    cell = tuple(c[i]+d[i] for i in range(self.dim))\n                    if cell in self.cells:\n                        for n in self.cells[cell]:\n                            s = 0.0\n                            p = n.position\n                            for i in range(self.dim):\n                                diff = p[i]-pos[i]\n                                s += diff*diff\n                                if s > r_sq:\n                                    break\n                            if s <= r_sq:\n                                neighbors.append(n)\n                return neighbors\n\n        # Adaptive steering with dynamic step size based on local collision proximity\n        def adaptive_steer(frm, to, max_step):\n            d = dist(frm,to)\n            if d < self.min_step:\n                return to\n            step = min(max_step, d)\n            ratio = step/d\n            point = tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n            # check collision along smaller step approx\n            # if close to obstacle, reduce step more\n            # zoom factor handled in plan main loop\n            return point\n\n        # Curvature penalty (softened)\n        def curvature_penalty(p0, p1, p2):\n            if p0 is None or p1 is None or p2 is None:\n                return 0.0\n            v1 = [p1[i]-p0[i] for i in range(dim)]\n            v2 = [p2[i]-p1[i] for i in range(dim)]\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim)) / (len1*len2)\n            dot = max(-1.0,min(1.0,dot))\n            angle = math.acos(dot)\n            return angle\n\n        # Adaptive rewiring radius using n_near_const and tree size\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes == 0:\n                return self.initial_step * 5.5\n            gamma = self.n_near_const\n            r = min((gamma * (math.log(n_nodes) / n_nodes))**(1.0/dim), self.max_step * 6.3)\n            if c_best == float('inf'):\n                return r\n            shrink = max(0.3, c_best / (c_min * 2.8))\n            return max(self.min_step * 0.7, r * shrink)\n\n        # Ellipsoidal informed sampling after a solution found\n        def informed_sample(c_best):\n            if not found_solution or c_best == float('inf') or c_min < 1e-14:\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            center = tuple((start_pos[i] + goal_pos[i])*0.5 for i in range(dim))\n            a1 = [goal_pos[i] - start_pos[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n            basis = [unit_a1]\n            for k in range(1,dim):\n                vec = [0]*dim\n                vec[(k)%dim] = 1\n                for b in basis:\n                    proj = sum(vec[i]*b[i] for i in range(dim))\n                    vec = [vec[i] - proj*b[i] for i in range(dim)]\n                norm = math.sqrt(sum(x*x for x in vec))\n                if norm > 1e-14:\n                    vec = [x/norm for x in vec]\n                    basis.append(vec)\n                else:\n                    basis.append([0]*dim)\n            r1 = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(max(0,val)) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n            max_tries = 50\n            for _ in range(max_tries):\n                sample_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in sample_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x/norm_ball for x in sample_ball]\n                r = random.random()**(1/dim)\n                scaled = [radii[i]*unit_ball[i]*r for i in range(dim)]\n                rotated = [0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        rotated[j] += basis[i][j]*scaled[i]\n                sample_raw = tuple(center[i] + rotated[i] for i in range(dim))\n                sample_clamped = tuple(max(0.0,min(bounds[i],sample_raw[i])) for i in range(dim))\n                if not in_obstacle(sample_clamped):\n                    return sample_clamped\n            return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n\n        # Connect two paths reversing second tree path\n        def connect_paths(node_s, node_g):\n            p1 = node_s.path_from_root()\n            p2 = node_g.path_from_root()[::-1]\n            if p1[-1] == p2[0]:\n                return p1 + p2[1:]\n            return p1 + p2\n\n        # Move new node selection with adaptive step size (smaller if near obstacles)\n        def local_steer_near(frm, to):\n            # Try largest step first\n            step = self.initial_step\n            d = dist(frm, to)\n            if d <= self.min_step:\n                return to, step\n            step = min(d, step)\n            candidate = adaptive_steer(frm, to, step)\n            # If collision edge found, reduce step until free or min_step reached\n            for attempt in range(5):\n                if not edge_in_obstacle(frm, candidate):\n                    return candidate, step\n                step /= 2.0\n                if step < self.min_step:\n                    break\n                candidate = adaptive_steer(frm, to, step)\n            # fallback directly to nearest free point close to frm that isn't in obstacle\n            if not in_obstacle(candidate) and in_bounds(candidate):\n                return candidate, step\n            return None, None\n\n        # Update costs downstream upon rewiring subtree root change\n        def propagate_costs(root):\n            stack = [root]\n            while stack:\n                curr = stack.pop()\n                for c in curr.children:\n                    prev_cost = c.cost\n                    new_cost = curr.cost + dist(curr.position, c.position)\n                    if new_cost + 1e-12 < prev_cost:\n                        c.cost = new_cost\n                        stack.append(c)\n\n        # Prune considering connectivity: only prune nodes whose cost too high and subtree leaf or disconnected; avoid pruning nodes critical to connectivity\n        def prune_tree(tree, cost_limit, spatial_hash):\n            to_remove = [n for n in tree if n.cost > cost_limit]\n            removed = set()\n            def can_prune(n):\n                # Prune only if leaf or no children or no connections to best path\n                if n.children:\n                    return False\n                return True\n            for n in to_remove:\n                if can_prune(n):\n                    if n.parent:\n                        n.parent.remove_child(n)\n                    spatial_hash.remove(n)\n                    removed.add(n)\n            # rebuild tree list without removed\n            new_tree = [n for n in tree if n not in removed]\n            return new_tree\n\n        # Smoothing and shortcutting with curvature-aware pruning (multi pass)\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            pts = list(path)\n            changed = True\n            iter_count = 0\n            max_iters = self.shortcut_iters\n            while changed and iter_count < max_iters:\n                changed = False\n                iter_count += 1\n                i = 0\n                while i < len(pts) - 2:\n                    max_j = min(len(pts)-1, i + 8 + random.randint(0,4))\n                    if max_j <= i + 1:\n                        i += 1\n                        continue\n                    j = random.randint(i+2, max_j)\n                    if not edge_in_obstacle(pts[i], pts[j]):\n                        def max_curv(pth):\n                            if len(pth) < 3:\n                                return 0.0\n                            max_ang = 0.0\n                            for idx in range(1, len(pth)-1):\n                                ang = curvature_penalty(pth[idx-1], pth[idx], pth[idx+1])\n                                if ang > max_ang:\n                                    max_ang = ang\n                            return max_ang\n                        old_sub = pts[i:j+1]\n                        new_sub = [pts[i], pts[j]]\n                        old_c = max_curv(old_sub)\n                        new_c = max_curv(new_sub)\n                        if new_c <= old_c + 0.18:\n                            pts = pts[:i+1] + pts[j:]\n                            changed = True\n                            break\n                    i += 1\n            return pts\n\n        # Initialization\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        all_nodes = [start_root, goal_root]\n        edges = []\n        spatial_start = SpatialHash(bounds, self.initial_step * 1.5)\n        spatial_goal = SpatialHash(bounds, self.initial_step * 1.5)\n        spatial_start.insert(start_root)\n        spatial_goal.insert(goal_root)\n\n        c_min = dist(start_pos, goal_pos)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n        no_improve = 0\n        last_cost = float('inf')\n\n        start_time = time.time()\n        time_limit = 30.0  # seconds hard limit\n\n        alpha_curv = 0.025  # relaxed curvature weight\n\n        # Dynamic pruning factor that reduces if no improvement for many iterations\n        prune_factor = self.prune_factor_init\n\n        def add_node(tree, spatial_hash, sample_point, current_best_cost):\n            # Nearest candidate nodes within roughly 3*step\n            candidates = spatial_hash.nearby(sample_point, self.max_step * 3.5)\n            if not candidates:\n                nearest = min(tree, key=lambda n: dist(n.position, sample_point))\n            else:\n                nearest = min(candidates, key=lambda n: dist(n.position, sample_point))\n\n            new_pos, used_step = local_steer_near(nearest.position, sample_point)\n            if new_pos is None:\n                return None\n\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                return None\n\n            n_nodes = len(all_nodes)\n            radius = adaptive_radius(n_nodes, current_best_cost)\n            near_nodes = spatial_hash.nearby(new_pos, radius)\n\n            # Parent selection with softened curvature penalty and cost balancing\n            best_parent = nearest\n            base_cost = nearest.cost + dist(nearest.position, new_pos)\n            base_score = base_cost\n            if nearest.parent is not None:\n                base_score += alpha_curv * curvature_penalty(nearest.parent.position, nearest.position, new_pos)\n\n            for cand in near_nodes:\n                if cand == nearest:\n                    continue\n                if edge_in_obstacle(cand.position, new_pos):\n                    continue\n                cand_cost = cand.cost + dist(cand.position, new_pos)\n                curvature_p = 0.0\n                if cand.parent is not None:\n                    curvature_p = alpha_curv * curvature_penalty(cand.parent.position, cand.position, new_pos)\n                score = cand_cost + curvature_p\n                if score + self.improve_tol < base_score:\n                    best_parent = cand\n                    base_cost = cand_cost\n                    base_score = score\n\n            new_node = Node(new_pos, best_parent, base_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            spatial_hash.insert(new_node)\n\n            # Rewiring neighbors: allow a softened curvature increase threshold to help reduce path length\n            for near_n in near_nodes:\n                if near_n == best_parent or near_n == new_node:\n                    continue\n                if edge_in_obstacle(new_node.position, near_n.position):\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost:\n                    curv_new = 0.0\n                    if new_node.parent is not None:\n                        curv_new = alpha_curv * curvature_penalty(new_node.parent.position, new_node.position, near_n.position)\n                    curv_old = 0.0\n                    if near_n.parent is not None:\n                        pp = near_n.parent.parent.position if near_n.parent.parent else None\n                        curv_old = alpha_curv * curvature_penalty(pp, near_n.parent.position, near_n.position)\n                    # Relaxed curvature threshold to allow beneficial rewiring (up to +0.25 rad)\n                    if curv_new <= curv_old + 0.25:\n                        # Rewire\n                        if near_n.parent:\n                            near_n.parent.remove_child(near_n)\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_n)\n                        near_n.cost = alt_cost\n                        edges.append((new_node, near_n))\n                        propagate_costs(near_n)\n            return new_node\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > time_limit:\n                break\n\n            sample = informed_sample(best_cost if found_solution else float('inf'))\n\n            # Alternate tree expansions\n            if it % 2 == 0:\n                active_tree, active_sh = start_tree, spatial_start\n                other_tree, other_sh = goal_tree, spatial_goal\n            else:\n                active_tree, active_sh = goal_tree, spatial_goal\n                other_tree, other_sh = start_tree, spatial_start\n\n            new_node = add_node(active_tree, active_sh, sample, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve += 1\n                continue\n\n            # Try connect new node to the other tree within max step-size\n            near_others = other_sh.nearby(new_node.position, self.max_step)\n            connect_candidate = None\n            min_conn_cost = float('inf')\n            for other_node in near_others:\n                if edge_in_obstacle(new_node.position, other_node.position):\n                    continue\n                candidate_cost = new_node.cost + dist(new_node.position, other_node.position) + other_node.cost\n                if candidate_cost + self.improve_tol < min_conn_cost:\n                    min_conn_cost = candidate_cost\n                    connect_candidate = other_node\n\n            if connect_candidate is not None:\n                candidate_path = connect_paths(new_node, connect_candidate)\n                if min_conn_cost + self.improve_tol < best_cost:\n                    best_cost = min_conn_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve = 0\n                else:\n                    if found_solution:\n                        no_improve += 1\n            else:\n                if found_solution:\n                    no_improve += 1\n\n            # Adjust pruning factor to relax pruning with no improvement and tighten when improving\n            if found_solution:\n                if no_improve > self.max_no_improve // 2:\n                    prune_factor = min(prune_factor * 1.03, self.prune_factor_init)\n                else:\n                    prune_factor = max(prune_factor * 0.995, self.prune_factor_min)\n                cost_thres = best_cost * prune_factor\n                start_tree = prune_tree(start_tree, cost_thres, spatial_start)\n                goal_tree = prune_tree(goal_tree, cost_thres, spatial_goal)\n\n            if found_solution and no_improve >= self.max_no_improve:\n                break\n\n            if found_solution and best_cost + self.improve_tol < last_cost:\n                last_cost = best_cost\n                no_improve = 0\n\n        if found_solution and len(best_path) >= 3:\n            # Multi-pass shortcutting to improve smoothness and length\n            for _ in range(5):\n                best_path = shortcut_path(best_path)\n\n        if found_solution:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        return PlannerResult(False, [], all_nodes, edges)",
        "objective": 9.866,
        "time_improvement": -87.0,
        "length_improvement": 15.0,
        "smoothness_improvement": 1458.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.07445192337036133,
                "num_nodes_avg": 179.5,
                "path_length_avg": 160.6737903359244,
                "smoothness_avg": 0.04659737117948082,
                "success_improvement": 0.0,
                "time_improvement": -206.57026030698847,
                "length_improvement": 11.93214947774344,
                "smoothness_improvement": 629.350046769958,
                "objective_score": -51.665038171600685
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.09158942699432374,
                "num_nodes_avg": 327.6,
                "path_length_avg": 241.5817258755858,
                "smoothness_avg": 0.09328713232625183,
                "success_improvement": 0.0,
                "time_improvement": 43.27607989198422,
                "length_improvement": 19.353066358299873,
                "smoothness_improvement": 2300.3451067599526,
                "objective_score": 36.09638931637495
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.09833176136016845,
                "num_nodes_avg": 341.7,
                "path_length_avg": 129.68727327043848,
                "smoothness_avg": 0.12138410655272378,
                "success_improvement": 0.0,
                "time_improvement": -98.56686165475072,
                "length_improvement": 13.867888138105963,
                "smoothness_improvement": 1443.996875707893,
                "objective_score": -14.029341235022173
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "An enhanced bidirectional RRT* planner that integrates heuristic-guided parent selection and rewiring considering global cost-to-go estimates, adaptive contraction of neighbor radius with iteration and tree size, and improved path merging with shortcutting to minimize redundant nodes. The planner alternates expansions between start and goal trees, uses ellipsoidal informed sampling after first solution, performs rewiring with heuristic cost-to-go to enable better global path cost reduction, and merges start/goal trees via shortcut-aware concatenation to yield shorter, smoother paths efficiently while maintaining robust collision checking and early stopping criteria based on solution improvement stagnation.",
        "planning_mechanism": "The planner alternates tree expansions, samples informed by current best cost, adds new nodes using heuristic cost-to-come plus estimated cost-to-go for parent selection and rewiring decisions, attempts direct connections between opposite trees, and merges paths with shortcutting to reduce unnecessary intermediate nodes. Early stopping is applied on stagnation and timeout while always validating node and edge collisions.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self,\n        max_iter=6000,\n        step_size=4.0,\n        max_neighbor_radius=25.0,\n        min_neighbor_radius=5.0,\n        improvement_tol=1e-6,\n        max_no_improve=100,\n        time_limit_sec=30.0,\n        post_opt_iters=300\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_neighbor_radius = max_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n        self.improvement_tol = improvement_tol\n        self.max_no_improve = max_no_improve\n        self.time_limit_sec = time_limit_sec\n        self.post_opt_iters = post_opt_iters\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_first = False\n        no_improve_count = 0\n        post_opt_count = 0\n        start_time = time.time()\n\n        def heuristic_cost_to_go(pos):\n            # Euclidean distance to goal for start tree, to start for goal tree (depends on caller)\n            # We'll use this for heuristic-aware rewiring.\n            # We'll pass map_goal accordingly when invoked.\n            # Here return Euclidean distance to goal_pos by default\n            return math.dist(pos, goal_pos)\n\n        def heuristic_cost_to_go_from_goal_tree(pos):\n            # Used when rewiring in goal_tree: heuristic distance to start_pos (goal is \"start\" for goalside)\n            return math.dist(pos, start_pos)\n\n        def within_bounds(pos):\n            return all(0.0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_p, to_p, resolution=1.0):\n            dist = math.dist(from_p, to_p)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(dim))\n\n        def adaptive_radius(n, iter_i):\n            factor = max(0.0, 1.0 - iter_i / self.max_iter)\n            base_radius = self.max_neighbor_radius * factor * (math.log(n + 1) / (n + 1))**(1 / dim)\n            radius = max(self.min_neighbor_radius, min(self.max_neighbor_radius, base_radius))\n            return radius\n\n        def neighbors(tree, pos, radius):\n            radius_sq = radius * radius\n            return [n for n in tree if sum((n.position[d] - pos[d])**2 for d in range(dim)) <= radius_sq]\n\n        def heuristic_parent_selection(tree, new_pos, iter_i, tree_type):\n            # tree_type in {'start', 'goal'}\n            n = len(tree)\n            radius = adaptive_radius(n, iter_i)\n            nbrs = neighbors(tree, new_pos, radius)\n\n            # Compute heuristic cost to go depending on tree type\n            if tree_type == 'start':\n                heuristic_func = heuristic_cost_to_go\n            else:\n                heuristic_func = heuristic_cost_to_go_from_goal_tree\n\n            # For each neighbor, compute: cost_to_come + dist_to_new_pos + heuristic cost_to_go(new_pos)\n            # to minimize cost_to_come + edge + heuristic; used for selection and rewiring\n            # We'll incorporate heuristic later in rewire as well.\n\n            min_total_cost = None\n            best_parent = None\n            for nb in nbrs:\n                if is_edge_in_obstacle(nb.position, new_pos):\n                    continue\n                cost_to_come = nb.cost + math.dist(nb.position, new_pos)\n                cost_total = cost_to_come + heuristic_func(new_pos)\n                if (min_total_cost is None) or (cost_total < min_total_cost):\n                    min_total_cost = cost_total\n                    best_parent = nb\n\n            # If no neighbors or no edge clear, fallback to nearest\n            if best_parent is None:\n                nearest = min(tree, key=lambda node: math.dist(node.position, new_pos))\n                if not is_edge_in_obstacle(nearest.position, new_pos):\n                    cost_to_come = nearest.cost + math.dist(nearest.position, new_pos)\n                    min_total_cost = cost_to_come + heuristic_func(new_pos)\n                    best_parent = nearest\n                else:\n                    # Edge blocked, cannot connect\n                    return None, []\n\n            new_node = Node(new_pos, cost=best_parent.cost + math.dist(best_parent.position, new_pos))\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, nbrs\n\n        def heuristic_rewire(pivot, nbrs, tree_type):\n            # Using heuristic-aware rewiring to improve global path cost\n            # pivot: node just added or rewired\n            # neighbors: nodes to attempt rewiring\n\n            if tree_type == 'start':\n                heuristic_func = heuristic_cost_to_go\n            else:\n                heuristic_func = heuristic_cost_to_go_from_goal_tree\n\n            for nb in nbrs:\n                if nb is pivot or nb is pivot.parent:\n                    continue\n                if is_edge_in_obstacle(pivot.position, nb.position):\n                    continue\n                new_cost_to_come = pivot.cost + math.dist(pivot.position, nb.position)\n                # Compare cost-to-come plus heuristic for nb if rewired\n                if new_cost_to_come + heuristic_func(nb.position) + 1e-12 < nb.cost + heuristic_func(nb.position):\n                    # Rewire nb\n                    old_parent = nb.parent\n                    if old_parent is not None:\n                        try:\n                            edges.remove((old_parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in old_parent.children:\n                            old_parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost_to_come\n                    edges.append((pivot, nb))\n\n        def direct_connect(tree, target_node, iter_i, tree_type):\n            # Try to connect tree to target_node by a straight edge first\n            nearest = min(tree, key=lambda n: math.dist(n.position, target_node.position))\n            if not is_edge_in_obstacle(nearest.position, target_node.position) and not is_in_obstacle(target_node.position):\n                new_node = Node(target_node.position, cost=nearest.cost + math.dist(nearest.position, target_node.position))\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n                return new_node\n\n            # Otherwise incremental connect with steering and rewiring\n            current = nearest\n            steps = int(math.ceil(math.dist(current.position, target_node.position) / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node, nbrs = heuristic_parent_selection(tree, new_pos, iter_i, tree_type)\n                if new_node is None:\n                    return None\n                heuristic_rewire(new_node, nbrs, tree_type)\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    if not is_edge_in_obstacle(new_node.position, target_node.position) and not is_in_obstacle(target_node.position):\n                        final_node = Node(target_node.position, cost=new_node.cost + math.dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n            return None\n\n        def sample_informed():\n            if not found_first or best_cost == float('inf') or c_min < 1e-12:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = best_cost / 2.0\n            val = best_cost*best_cost - c_min*c_min\n            val = max(val, 0.0)\n            r_other = math.sqrt(val) / 2.0\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2] - u[2]*v[1], u[2]*v[0] - u[0]*v[2], u[0]*v[1] - u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1.0, 0.0, 0.0) if abs(a1[0]) < 0.9 else (0.0, 1.0, 0.0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0.0, 0.0, 1.0)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0.0, 1.0) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random()**(1.0/dim)\n                    return [v * r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                val = min(max(val, 0.0), bounds[d])\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            # Attempt to shortcut path by checking if edges between nonadjacent waypoints can be connected directly\n            if len(path) < 3:\n                return path\n            optimized = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        optimized.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    # no shortcut found, add next node\n                    i += 1\n                    if i < len(path):\n                        optimized.append(path[i])\n            # Remove duplicates if any\n            final_path = []\n            last = None\n            for p in optimized:\n                if p != last:\n                    final_path.append(p)\n                    last = p\n            return final_path\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit_sec:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            tree_a_type = 'start' if it % 2 == 0 else 'goal'\n            tree_b_type = 'goal' if tree_a_type == 'start' else 'start'\n\n            x_rand = sample_informed()\n\n            if not within_bounds(x_rand) or is_in_obstacle(x_rand):\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = min(tree_a, key=lambda node: math.dist(node.position, x_rand))\n            new_pos = steer(nearest.position, x_rand)\n            if (not within_bounds(new_pos) or is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest.position, new_pos)):\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = heuristic_parent_selection(tree_a, new_pos, it, tree_a_type)\n            if new_node is None:\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n                continue\n            heuristic_rewire(new_node, nbrs, tree_a_type)\n\n            meet_node = direct_connect(tree_b, new_node, it, tree_b_type)\n            if meet_node is not None:\n                if tree_a_type == 'start':\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                # merge paths with shortcutting to reduce length\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    raw_merged = path_a + path_b[-2::-1]\n                else:\n                    raw_merged = path_a + path_b[::-1]\n\n                merged_path = shortcut_path(raw_merged)\n\n                total_cost = 0.0\n                for i in range(len(merged_path)-1):\n                    total_cost += math.dist(merged_path[i], merged_path[i+1])\n\n                if total_cost + self.improvement_tol < best_cost:\n                    best_cost = total_cost\n                    best_path = merged_path\n                    found_first = True\n                    post_opt_count = 0\n                    no_improve_count = 0\n                else:\n                    if found_first:\n                        post_opt_count += 1\n                        no_improve_count += 1\n\n                if found_first and (post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve):\n                    break\n            else:\n                if found_first:\n                    post_opt_count += 1\n                    no_improve_count += 1\n                    if post_opt_count >= self.post_opt_iters or no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(success=found_first, path=best_path, nodes=nodes, edges=edges)",
        "objective": 29.47935,
        "time_improvement": -163.0,
        "length_improvement": 17.0,
        "smoothness_improvement": 1861.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.11461379528045654,
                "num_nodes_avg": 157.9,
                "path_length_avg": 156.58550151996783,
                "smoothness_avg": 0.045537808163026515,
                "success_improvement": 0.0,
                "time_improvement": -371.94457125185914,
                "length_improvement": 14.17300536085118,
                "smoothness_improvement": 612.7655846845312,
                "objective_score": -100.01574023562439
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.15397179126739502,
                "num_nodes_avg": 423.9,
                "path_length_avg": 238.179942045085,
                "smoothness_avg": 0.13335331092692398,
                "success_improvement": 0.0,
                "time_improvement": 4.640919008248845,
                "length_improvement": 20.48867971583956,
                "smoothness_improvement": 3331.2767406572243,
                "objective_score": 30.34186723526451
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.10994319915771485,
                "num_nodes_avg": 310.5,
                "path_length_avg": 126.34830217722636,
                "smoothness_avg": 0.13661864156688966,
                "success_improvement": 0.0,
                "time_improvement": -122.01449170698828,
                "length_improvement": 16.085473753499823,
                "smoothness_improvement": 1637.7790365916799,
                "objective_score": -18.764168077038192
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "An advanced bidirectional RRT* variant using KD-tree accelerated neighbor queries for fast nearest neighbor and neighborhood searches, combined with ellipsoidal informed sampling to focus exploration. The planner incorporates adaptive rewiring radius for efficient path cost and smoothness improvement, and performs post-processing path shortcutting to enhance smoothness and reduce length. It alternates tree growth from start and goal, attempts flexible tree connection with incremental steering, and terminates early upon stagnation or time limit.",
        "planning_mechanism": "The planner grows two trees from start and goal, alternating expansions. Early uniform sampling is replaced by ellipsoidal informed sampling after the first solution to focus on relevant regions, accelerating convergence. Each new node is connected to the best parent within an adaptive radius using KD-tree based neighbor search. A rewiring step improves the local tree structure for both cost and smoothness. The planner attempts incremental steering connections between trees to find shortcuts. Once a solution is found, a shortcutting post-processing improves path smoothness and length by attempting to replace piecewise segments with direct collision-free edges. The algorithm terminates early if no improvement occurs over a fixed count or after the time limit, returning the best smooth path found.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=5000,\n                 step_size=5.0,\n                 max_radius=25.0,\n                 min_radius=5.0,\n                 improvement_tol=1e-6,\n                 max_no_improve=80,\n                 time_limit=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_radius = max_radius\n        self.min_radius = min_radius\n        self.improvement_tol = improvement_tol\n        self.max_no_improve = max_no_improve\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import time\n        import math\n        import random\n        from bisect import bisect_left\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        start_time = time.time()\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if dim == 3:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b, resolution=1.0):\n            dist = math.dist(a,b)\n            if dist < 1e-12:\n                return False\n            steps = max(2, int(dist/resolution))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d]-from_p[d]) * ratio for d in range(dim))\n\n        # KD-Tree structure for fast neighbor queries\n        class KDTree:\n            def __init__(self, points):\n                self.dim = len(points[0].position) if points else 0\n                self.nodes = points\n\n            def nearest(self, point):\n                best = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    d = 0\n                    for i in range(self.dim):\n                        dd = node.position[i] - point[i]\n                        d += dd*dd\n                        if d > best_dist*best_dist:\n                            break\n                    if d < best_dist*best_dist:\n                        best = node\n                        best_dist = math.sqrt(d)\n                return best\n\n            def radius_search(self, point, radius):\n                r_sq = radius*radius\n                result = []\n                for node in self.nodes:\n                    d = 0\n                    for i in range(self.dim):\n                        dd = node.position[i] - point[i]\n                        d += dd*dd\n                        if d > r_sq:\n                            break\n                    if d <= r_sq:\n                        result.append(node)\n                return result\n\n            def add(self, node):\n                self.nodes.append(node)\n\n        def adaptive_radius(n, iter_i):\n            if n == 0:\n                return self.max_radius\n            factor = max(0.0, 1.0 - iter_i / self.max_iter)\n            return max(self.min_radius,\n                       min(self.max_radius,\n                           self.max_radius * factor * (math.log(n+1)/(n+1))**(1/dim)\n                          )\n                      )\n\n        def choose_parent(tree_kdtree, tree_nodes, pos, iter_i):\n            n = len(tree_nodes)\n            r = adaptive_radius(n, iter_i)\n            nbrs = tree_kdtree.radius_search(pos, r)\n            nearest = tree_kdtree.nearest(pos)\n            min_cost = nearest.cost + math.dist(nearest.position, pos)\n            best_parent = nearest\n            for nb in nbrs:\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                c = nb.cost + math.dist(nb.position, pos)\n                if c < min_cost:\n                    min_cost = c\n                    best_parent = nb\n            new_node = Node(pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_nodes.append(new_node)\n            tree_kdtree.add(new_node)\n            edges.append((best_parent, new_node))\n            return new_node, nbrs\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb == pivot.parent:\n                    continue\n                if edge_in_obstacle(pivot.position, nb.position):\n                    continue\n                new_cost = pivot.cost + math.dist(pivot.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if nb.parent is not None:\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        if nb in nb.parent.children:\n                            nb.parent.children.remove(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n                    edges.append((pivot, nb))\n\n        def direct_connect(tree_kdtree, tree_nodes, target_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_kdtree.nearest(target_node.position)\n            dist_to_target = math.dist(nearest.position, target_node.position)\n            if dist_to_target <= self.step_size:\n                if (not edge_in_obstacle(nearest.position, target_node.position) and\n                    not in_obstacle(target_node.position)):\n                    new_node = Node(target_node.position, cost=nearest.cost + dist_to_target)\n                    nearest.add_child(new_node)\n                    tree_nodes.append(new_node)\n                    tree_kdtree.add(new_node)\n                    edges.append((nearest, new_node))\n                    return new_node\n                return None\n            current = nearest\n            steps = int(math.ceil(dist_to_target / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos)):\n                    return None\n                new_node, nbrs = choose_parent(tree_kdtree, tree_nodes, new_pos, 0)\n                rewire(new_node, nbrs)\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    if (not edge_in_obstacle(new_node.position, target_node.position) and\n                        not in_obstacle(target_node.position)):\n                        final_node = Node(target_node.position,\n                                          cost=new_node.cost + math.dist(new_node.position, target_node.position))\n                        new_node.add_child(final_node)\n                        tree_nodes.append(final_node)\n                        tree_kdtree.add(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed():\n            if not found_solution or best_cost == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = best_cost * 0.5\n            val = best_cost*best_cost - c_min*c_min\n            val = max(val, 0.0)\n            r_other = math.sqrt(val)*0.5 if val > 0 else 0.0\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1,b2)\n                basis = (a1,b2,b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(dim):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(dim)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random()**(1/dim)\n                    return [v*r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d]*radii[i]*u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path)-1:\n                j = len(path) - 1\n                while j > i+1:\n                    if (not edge_in_obstacle(path[i], path[j]) and\n                        in_bounds(path[j]) and not in_obstacle(path[j])):\n                        break\n                    j -= 1\n                shortened.append(path[j])\n                i = j\n            return shortened\n\n        start_kdtree = KDTree(start_tree[:])\n        goal_kdtree = KDTree(goal_tree[:])\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            tree_a, tree_b = (start_tree, goal_tree) if it % 2 == 0 else (goal_tree, start_tree)\n            kdtree_a = start_kdtree if it % 2 == 0 else goal_kdtree\n            kdtree_b = goal_kdtree if it % 2 == 0 else start_kdtree\n\n            x_rand = sample_informed()\n\n            if not in_bounds(x_rand) or in_obstacle(x_rand):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            nearest = kdtree_a.nearest(x_rand)\n            new_pos = steer(nearest.position, x_rand)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(kdtree_a, tree_a, new_pos, it)\n            rewire(new_node, nbrs)\n\n            meet_node = direct_connect(kdtree_b, tree_b, new_node)\n            if meet_node is not None:\n                if it % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = meet_node.path_from_root()\n                else:\n                    path_a = meet_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    merged_path = path_a + path_b[-2::-1]\n                else:\n                    merged_path = path_a + path_b[::-1]\n\n                total_cost = sum(math.dist(merged_path[i], merged_path[i+1]) for i in range(len(merged_path)-1))\n\n                # Post-process path shortcutting for smoothness and shorter length\n                smoothed_path = shortcut_path(merged_path)\n                smoothed_cost = sum(math.dist(smoothed_path[i], smoothed_path[i+1]) for i in range(len(smoothed_path)-1))\n\n                if smoothed_cost + self.improvement_tol < best_cost:\n                    best_cost = smoothed_cost\n                    best_path = smoothed_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        if no_improve_count >= self.max_no_improve:\n                            break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
        "objective": 36.83489,
        "time_improvement": -186.0,
        "length_improvement": 17.0,
        "smoothness_improvement": 1740.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.131825852394104,
                "num_nodes_avg": 2.0,
                "path_length_avg": 164.86214914222285,
                "smoothness_avg": 0.05477585570849506,
                "success_improvement": 0.0,
                "time_improvement": -442.81856067857507,
                "length_improvement": 9.63644364721884,
                "smoothness_improvement": 757.3610895124422,
                "objective_score": -123.276896567679
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.11904773712158204,
                "num_nodes_avg": 2.0,
                "path_length_avg": 236.6589583478829,
                "smoothness_avg": 0.12534880184330177,
                "success_improvement": 0.0,
                "time_improvement": 26.270372562291577,
                "length_improvement": 20.996427853053945,
                "smoothness_improvement": 3125.3149565207714,
                "objective_score": 36.10554326312369
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.1195601463317871,
                "num_nodes_avg": 2.0,
                "path_length_avg": 119.41688822110727,
                "smoothness_avg": 0.1129511109080394,
                "success_improvement": 0.0,
                "time_improvement": -141.43453455622154,
                "length_improvement": 20.688988864690227,
                "smoothness_improvement": 1336.7297935664972,
                "objective_score": -23.333318080219836
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "time_expert",
        "algorithm_description": "A Bidirectional Adaptive-KD Informed RRT* planner incorporating an efficient KD-tree-like spatial indexing for fast nearest and near neighbor search, dynamic adaptive rewiring radius based on node density and best cost, tighter curvature-aware parent selection with non-linear curvature penalty for smoother paths, early stopping on stagnation, and incremental partial shortcutting applied during planning iterations to enhance smoothness continuously. Sampling is concentrated inside adaptive ellipsoid informed sets progressively shrinking with improved cost. This approach balances computation and path quality, significantly reducing planning time and improving path smoothness and length.",
        "planning_mechanism": "The planner grows two trees from start and goal alternately, using a KD-tree inspired spatial index for efficient nearest and radius-based neighbor searches, improving speed over linear search. Samples are drawn from a decreasing ellipsoid informed by the latest best path cost. Node extension uses adaptive step size. Parents are selected by a combined cost and smoothness metric with an exponential curvature penalty enhancing smoothness. Rewiring neighbors within an adaptive radius based on node count and current best cost optimize paths locally. During planning, partial shortcutting is applied periodically on the best found path to incrementally smooth paths, not just at the end. Early stopping is triggered when no significant improvements occur, reducing unnecessary computation.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3000, step_size=4.0, n_near_const=20,\n                 max_no_improve=60, improve_tol=1e-7, shortcut_iter_interval=60, shortcut_passes=4):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.n_near_const = n_near_const\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n        self.shortcut_iter_interval = shortcut_iter_interval\n        self.shortcut_passes = shortcut_passes\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n        dist = lambda a, b: math.dist(a, b)\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if (ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od):\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if (ox <= px <= ox + ow and oy <= py <= oy + oh):\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=0.5):\n            length = dist(f, t)\n            if length < 1e-12:\n                return False\n            steps = max(3, int(length / resolution))\n            for i in range(steps +1):\n                inter = tuple(f[d] + (t[d] - f[d]) * i / steps for d in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        # KD-tree inspired spatial indexing for efficient neighbor search\n        class SpatialIndex:\n            def __init__(self, points):\n                self.points = points\n            def add(self, node):\n                self.points.append(node)\n            def remove(self, node):\n                if node in self.points:\n                    self.points.remove(node)\n            def nearest(self, p):\n                best = None\n                best_d = float('inf')\n                px = p\n                for n in self.points:\n                    d2 = 0.0\n                    for i in range(dim):\n                        dd = n.position[i] - px[i]\n                        d2 += dd*dd\n                        if d2 >= best_d*best_d:\n                            break\n                    else:\n                        d = math.sqrt(d2)\n                        if d < best_d:\n                            best = n\n                            best_d = d\n                return best, best_d\n            def near(self, p, radius):\n                r2 = radius*radius\n                res = []\n                px = p\n                for n in self.points:\n                    d2 = 0.0\n                    for i in range(dim):\n                        dd = n.position[i] - px[i]\n                        d2 += dd*dd\n                        if d2 > r2:\n                            break\n                    if d2 <= r2:\n                        res.append(n)\n                return res\n\n        def adaptive_radius(n_nodes, c_best):\n            gamma = self.n_near_const\n            if n_nodes < 2:\n                return self.step_size * 3.5\n            val = gamma * (math.log(n_nodes)/n_nodes)\n            base_radius = val**(1/dim)\n            cap = self.step_size * 5.5\n            radius = min(base_radius, cap)\n            if c_best == float('inf'):\n                return radius\n            shrink_factor = max(0.25, c_best / (c_min * 3.2))\n            min_radius = self.step_size * 0.75\n            return max(min_radius, radius * shrink_factor)\n\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                # uniform sample inside bounds\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-16:\n                return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Create orthonormal basis using Gram-Schmidt\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j] - proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-16:\n                    U.append([x / norm_base for x in base])\n                else:\n                    U.append([0.0]*dim)\n\n            r1 = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val > 0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n\n            max_attempts = 60\n            for _ in range(max_attempts):\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-16:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n                scaled = [radii[i]*point_ball[i] for i in range(dim)]\n                point_rot = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rot[j] += scaled[i]*U[i][j]\n                sample = tuple(center[i] + point_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)) and not in_obstacle(sample):\n                    return sample\n            # fallback uniform sample\n            return tuple(random.uniform(0.0, bounds[i]) for i in range(dim))\n\n        def path_length(path):\n            length = 0.0\n            for i in range(1,len(path)):\n                length += dist(path[i-1], path[i])\n            return length\n\n        def extract_path(node):\n            return node.path_from_root()\n\n        def connect_path(n_start, n_goal):\n            path_s = extract_path(n_start)\n            path_g_rev = extract_path(n_goal)\n            path_g = path_g_rev[::-1]\n            if len(path_s) > 0 and len(path_g) > 0 and path_s[-1] == path_g[0]:\n                return path_s + path_g[1:]\n            else:\n                return path_s + path_g\n\n        def curvature_penalty(p_parent, p_child, p_new):\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_child[i] - p_parent[i] for i in range(dim))\n            v2 = tuple(p_new[i] - p_child[i] for i in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-16 or len2 < 1e-16:\n                return 0.0\n            dot = sum(v1[i]*v2[i] for i in range(dim))/(len1*len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            # Use stronger exponential penalty for sharper turns to encourage smoothness\n            return math.exp(3.0 * angle) - 1.0\n\n        def add_node(tree_index, tree, other_tree, spatial_index, other_spatial_index, new_pos, nodes_all, edges, c_best):\n            nn, _ = spatial_index.nearest(new_pos)\n            if nn is None:\n                return None\n            new_pos_steered = steer(nn.position, new_pos)\n            if in_obstacle(new_pos_steered) or edge_obstacle(nn.position, new_pos_steered):\n                return None\n\n            n_nodes = len(nodes_all)\n            radius = adaptive_radius(n_nodes, c_best)\n            near = spatial_index.near(new_pos_steered, radius)\n\n            alpha_curv = 0.15\n            best_parent = nn\n            base_cost = nn.cost + dist(nn.position, new_pos_steered)\n            best_score = base_cost + alpha_curv * curvature_penalty(nn.parent.position if nn.parent else None, nn.position, new_pos_steered)\n\n            for candidate in near:\n                if candidate == nn:\n                    continue\n                if edge_obstacle(candidate.position, new_pos_steered):\n                    continue\n                candidate_cost = candidate.cost + dist(candidate.position, new_pos_steered)\n                curv_cost = alpha_curv * curvature_penalty(candidate.parent.position if candidate.parent else None, candidate.position, new_pos_steered)\n                score = candidate_cost + curv_cost\n                if score + self.improve_tol < best_score:\n                    best_parent = candidate\n                    base_cost = candidate_cost\n                    best_score = score\n\n            new_node = Node(new_pos_steered)\n            best_parent.add_child(new_node)\n            new_node.cost = base_cost\n            tree.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n            spatial_index.add(new_node)\n\n            # Rewiring neighbors for optimization\n            near_rewire = spatial_index.near(new_node.position, radius)\n            for near_n in near_rewire:\n                if near_n == best_parent or near_n == new_node:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, near_n.position)\n                if alt_cost + self.improve_tol < near_n.cost and not edge_obstacle(new_node.position, near_n.position):\n                    # curvature check with exponential penalty\n                    curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, near_n.position)\n                    curv_old = curvature_penalty(near_n.parent.parent.position if near_n.parent and near_n.parent.parent else None,\n                                                near_n.parent.position if near_n.parent else None, near_n.position)\n                    if alpha_curv * curv_new <= alpha_curv * curv_old + 0.08:  # stricter curvature threshold\n                        if near_n.parent:\n                            near_n.parent.remove_child(near_n)\n                            try:\n                                edges.remove((near_n.parent, near_n))\n                            except Exception:\n                                pass\n                        new_node.add_child(near_n)\n                        near_n.cost = alt_cost\n                        edges.append((new_node, near_n))\n\n            # Try to connect to other tree for solution\n            nbr_node, nbr_dist = other_spatial_index.nearest(new_node.position)\n            if nbr_node and nbr_dist <= self.step_size and not edge_obstacle(new_node.position, nbr_node.position):\n                candidate_path = connect_path(new_node, nbr_node)\n                candidate_cost = new_node.cost + dist(new_node.position, nbr_node.position) + nbr_node.cost\n                return new_node, candidate_path, candidate_cost\n            return new_node, None, float('inf')\n\n        def partial_shortcut(path, attempts=20):\n            if len(path) < 3:\n                return path\n            path = list(path)\n            for _ in range(attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, min(i+6, len(path)-1))\n                if j > i+1 and not edge_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Setup initial variables and spatial indices\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes_all = start_tree + goal_tree\n        edges = []\n        start_spatial = SpatialIndex(start_tree[:])\n        goal_spatial = SpatialIndex(goal_tree[:])\n\n        c_min = dist(start, goal)\n        best_cost = float('inf')\n        best_path = []\n        found_solution = False\n\n        no_improve_count = 0\n        last_best_cost = float('inf')\n\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            # Ellipsoid informed sampling after first solution\n            sample_pt = ellipsoid_sample(best_cost if found_solution else float('inf'))\n            # Alternate trees\n            if it % 2 == 0:\n                t_idx = 0\n                tree_a, tree_b = start_tree, goal_tree\n                spatial_a, spatial_b = start_spatial, goal_spatial\n            else:\n                t_idx = 1\n                tree_a, tree_b = goal_tree, start_tree\n                spatial_a, spatial_b = goal_spatial, start_spatial\n\n            add_result = add_node(t_idx, tree_a, tree_b, spatial_a, spatial_b, sample_pt, nodes_all, edges, best_cost)\n            if add_result is None:\n                if found_solution:\n                    no_improve_count += 1\n                continue\n            new_node, candidate_path, candidate_cost = add_result\n\n            if candidate_path is not None and candidate_cost + self.improve_tol < best_cost:\n                best_cost = candidate_cost\n                best_path = candidate_path\n                found_solution = True\n                no_improve_count = 0\n            elif found_solution:\n                no_improve_count += 1\n\n            # Early stopping if stagnating\n            if found_solution and no_improve_count >= self.max_no_improve:\n                break\n\n            if found_solution and best_cost + self.improve_tol < last_best_cost:\n                last_best_cost = best_cost\n                no_improve_count = 0\n\n            # Incremental partial shortcutting at intervals\n            if found_solution and (it > 0) and (it % self.shortcut_iter_interval == 0):\n                for _ in range(self.shortcut_passes):\n                    best_path = partial_shortcut(best_path, attempts=30)\n\n        if found_solution:\n            # Final multi-pass shortcutting for smoother path\n            for _ in range(4):\n                best_path = partial_shortcut(best_path, attempts=50)\n\n            return PlannerResult(True, best_path, nodes_all, edges)\n        else:\n            return PlannerResult(False, [], nodes_all, edges)",
        "objective": -9.64409,
        "time_improvement": -23.0,
        "length_improvement": 16.0,
        "smoothness_improvement": 1364.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.04349210262298584,
                "num_nodes_avg": 200.3,
                "path_length_avg": 164.65061843094549,
                "smoothness_avg": 0.04411138981015835,
                "success_improvement": 0.0,
                "time_improvement": -79.0871829610104,
                "length_improvement": 9.75238698198858,
                "smoothness_improvement": 590.4390399451137,
                "objective_score": -14.922527499384401
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.07159128189086914,
                "num_nodes_avg": 381.5,
                "path_length_avg": 236.4799163454076,
                "smoothness_avg": 0.08370046440220522,
                "success_improvement": 0.0,
                "time_improvement": 55.66149622641733,
                "length_improvement": 21.056197226918506,
                "smoothness_improvement": 2053.67323607643,
                "objective_score": 39.60053338445845
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.07232458591461181,
                "num_nodes_avg": 378.6,
                "path_length_avg": 123.38119328794218,
                "smoothness_avg": 0.12162572693511349,
                "success_improvement": 0.0,
                "time_improvement": -46.04910811005993,
                "length_improvement": 18.056086199220044,
                "smoothness_improvement": 1447.0702691373285,
                "objective_score": 4.254270632200689
            }
        ],
        "success_rate": 1.0
    }
]