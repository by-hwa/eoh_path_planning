[
    {
        "operator": "e2",
        "algorithm_description": "A bidirectional variant of RRT* with informed sampling and efficient rewiring that grows two trees simultaneously, restricts sampling to an ellipsoidal informed subset after first solution, and performs local rewiring to improve path cost and smoothness with early termination on convergence.",
        "planning_mechanism": "The planner grows start and goal trees bidirectionally with RRT* rewiring, initially samples uniformly to quickly find a path, then constrains samples to an ellipsoidal informed set defined by the current best path cost. After each extension, it attempts to connect the two trees if close enough, while performing localized rewiring to continuously improve path quality. Early stopping criteria limit iterations after no improvements to reduce planning time.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, radius=15.0,\n                 post_opt_iters=500, max_no_improve=100, improve_tol=1e-5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.post_opt_iters = post_opt_iters\n        self.max_no_improve = max_no_improve\n        self.improve_tol = improve_tol\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start)]\n        goal_tree = [Node(goal)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        best_goal_node = None\n\n        c_min = math.dist(start, goal)\n        found_solution = False\n\n        no_improve_count = 0\n        post_opt_count = 0\n\n        def dist(a,b): return math.dist(a,b)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            return tuple(frm[i] + (to[i]-frm[i]) * self.step_size / d for i in range(dim))\n\n        def in_obstacle(p):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d_ = obs\n                    px,py,pz = p\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d_:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = p\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def edge_obstacle(f, t, resolution=1.0):\n            distance = dist(f, t)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps+1):\n                inter = tuple(f[j] + (t[j]-f[j])*(i/steps) for j in range(dim))\n                if in_obstacle(inter):\n                    return True\n            return False\n\n        def nearest(tree, p):\n            best = tree[0]\n            best_d = dist(best.position, p)\n            for n in tree:\n                d2 = dist(n.position, p)\n                if d2 < best_d:\n                    best = n\n                    best_d = d2\n            return best\n\n        def near_nodes(tree, p, radius):\n            result = []\n            r2 = radius**2\n            for n in tree:\n                d2 = sum((n.position[i]-p[i])**2 for i in range(dim))\n                if d2 <= r2:\n                    result.append(n)\n            return result\n\n        def extract_path(n_start, n_goal):\n            path_start, node = [], n_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n            path_goal = []\n            node = n_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start + path_goal\n\n        def ellipsoid_sample(c_best):\n            # Sample inside prolate hyperspheroid defined by start, goal, c_best\n            import random\n            import math\n\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            center = tuple((start[i]+goal[i])/2 for i in range(dim))\n            a1 = [goal[i]-start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-12:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            # Compute rotation matrix via Gram-Schmidt or approximate as identity except along a1 axis\n            # For simplicity, rotate only along principal axis for 2D or 3D (orthonormal basis)\n            # Since imports are restricted, implement a simple orthonormal basis:\n\n            # Construct orthonormal basis U with unit_a1 as first vector\n            U = [unit_a1]\n            for i in range(dim-1):\n                base = [0]*dim\n                base[(i+1)%dim] = 1  # simple perpendicular approx\n                # Gram-Schmidt orthogonalize base vs U\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j]-proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-12:\n                    U.append([x/norm_base for x in base])\n                else:\n                    # fallback: constructs zero vector, skip\n                    U.append([0]*dim)\n\n            # L matrix diagonal\n            r1 = c_best / 2\n            if c_best*c_best - c_min*c_min < 0:\n                r2 = 0\n            else:\n                r2 = math.sqrt(c_best*c_best - c_min*c_min) / 2\n            radii = [r1] + [r2] * (dim - 1)\n\n            # Sample unit ball in dim\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-12:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u = random.random() ** (1.0/dim)\n                point_ball = [coord * u for coord in unit_ball]\n\n                # Scale by radii\n                point_scaled = [radii[i]*point_ball[i] for i in range(dim)]\n\n                # Rotate via U matrix: point = sum(point_scaled[i] * U[i]) over basis vectors\n                point_rotated = [0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rotated[j] += point_scaled[i]*U[i][j]\n\n                sample = tuple(center[i] + point_rotated[i] for i in range(dim))\n\n                if all(0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        for iter_count in range(self.max_iter):\n            if found_solution:\n                sample_pt = ellipsoid_sample(best_cost)\n            else:\n                sample_pt = ellipsoid_sample(float('inf'))\n\n            # Alternate growing start and goal trees\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample_pt)\n                new_pos = steer(nearest_node.position, sample_pt)\n\n                if in_obstacle(new_pos) or edge_obstacle(nearest_node.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                near = near_nodes(tree_a, new_pos, self.radius)\n\n                # Choose best parent in near nodes with minimal cost + dist and collision free edge\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for candidate in near:\n                    cand_cost = candidate.cost + dist(candidate.position, new_pos)\n                    if cand_cost + self.improve_tol < min_cost and not edge_obstacle(candidate.position, new_pos):\n                        min_cost = cand_cost\n                        best_parent = candidate\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire near nodes if new_node offers lower cost connection\n                for near_node in near:\n                    if near_node == best_parent:\n                        continue\n                    alt_cost = new_node.cost + dist(new_node.position, near_node.position)\n                    if alt_cost + self.improve_tol < near_node.cost and not edge_obstacle(new_node.position, near_node.position):\n                        # Remove old edge\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except Exception:\n                            pass\n                        if near_node.parent and near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n\n                        new_node.add_child(near_node)\n                        near_node.cost = alt_cost\n                        edges.append((new_node, near_node))\n\n                # Try connect trees if nodes close enough\n                connect_node = nearest(tree_b, new_node.position)\n                if dist(new_node.position, connect_node.position) <= self.step_size and not edge_obstacle(new_node.position, connect_node.position):\n                    path = extract_path(new_node, connect_node)\n                    path_cost = new_node.cost + dist(new_node.position, connect_node.position) + connect_node.cost\n                    if path_cost + self.improve_tol < best_cost:\n                        best_cost = path_cost\n                        # Stitch trees at connection nodes: assign parents carefully\n                        # For bidirectional path extraction, keep nodes and edges unchanged,\n                        # just store nodes for path extraction\n                        best_path = path\n                        found_solution = True\n                        best_goal_node = connect_node\n                        no_improve_count = 0\n                    else:\n                        no_improve_count += 1\n\n                    if found_solution and no_improve_count >= self.max_no_improve:\n                        post_opt_count += 1\n                        if post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n                else:\n                    if found_solution:\n                        no_improve_count += 1\n                        post_opt_count += 1\n                        if no_improve_count >= self.max_no_improve or post_opt_count >= self.post_opt_iters:\n                            return PlannerResult(True, best_path, nodes, edges)\n\n        if found_solution:\n            return PlannerResult(True, best_path, nodes, edges)\n        else:\n            return PlannerResult(False, [], nodes, edges)",
        "objective": 52.64884,
        "time_improvement": -220.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 323.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.06786198616027832,
                "num_nodes_avg": 317.3,
                "path_length_avg": 155.50621247453464,
                "smoothness_avg": 0.02411673119934513,
                "success_improvement": 0.0,
                "time_improvement": -179.4349134355319,
                "length_improvement": 14.764580789082476,
                "smoothness_improvement": 277.4792135897667,
                "objective_score": -43.58432948926125
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.14667820930480957,
                "num_nodes_avg": 670.6,
                "path_length_avg": 226.29277909188164,
                "smoothness_avg": 0.017873034085429756,
                "success_improvement": 0.0,
                "time_improvement": 9.158040406689327,
                "length_improvement": 24.45695686263326,
                "smoothness_improvement": 359.8860404442116,
                "objective_score": 19.22101644180781
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.2925038576126099,
                "num_nodes_avg": 613.1,
                "path_length_avg": 120.56565817380633,
                "smoothness_avg": 0.03399415459254427,
                "success_improvement": 0.0,
                "time_improvement": -490.6695072338173,
                "length_improvement": 19.926030560654297,
                "smoothness_improvement": 332.4031372296796,
                "objective_score": -133.58321814760419
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "A bidirectional RRT* planner with adaptive radius rewiring, progressive heuristic ellipsoidal sampling focusing search on promising paths, and early termination on convergence stagnation. It uses dynamic neighbor radius scaled with the logarithm of current tree size, adaptive step size that balances exploration and refinement, and incremental cost-based rewiring with bidirectional tree connection attempts. Path shortcutting is performed iteratively post solution to shorten and smooth the path efficiently.",
        "planning_mechanism": "The planner grows two trees from start and goal nodes alternately, samples new points focusing inside an informed ellipsoid shaped by current best solution cost to guide exploration. New nodes are connected using parent selection minimizing path cost within a dynamically computed neighbor radius that adapts as the tree grows. Rewiring adjusts tree topology to reduce costs. When the two trees connect within step distance, the combined path is saved if better. Early termination triggers if no cost improvement occurs over a configurable window, reducing runtime. Post processing shortcuts the path to remove unnecessary waypoints and improves path smoothness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, neighbor_factor=2.0, no_improve_limit=60, improve_tol=1e-7, shortcut_iters=250):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_factor = neighbor_factor\n        self.no_improve_limit = no_improve_limit\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def dist(a,b):\n            return math.sqrt(sum((a[i]-b[i])**2 for i in range(dim)))\n\n        def in_obstacle(p):\n            px = p + (0.0,)*(3-dim) if dim<3 else p\n            for obs in obstacles:\n                if dim == 2:\n                    x,y,w,h = obs\n                    if x <= px[0] <= x+w and y <= px[1] <= y+h:\n                        return True\n                else:\n                    x,y,z,w,h,d = obs\n                    if x <= px[0] <= x+w and y <= px[1] <= y+h and z <= px[2] <= z+d:\n                        return True\n            return False\n\n        def edge_obstacle(f,t,resolution=0.4):\n            length = dist(f,t)\n            if length < 1e-12:\n                return False\n            steps = max(2,int(length/resolution))\n            for i in range(steps+1):\n                interp = tuple(f[j] + (t[j]-f[j])*(i/steps) for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm,to,max_step):\n            d = dist(frm,to)\n            if d <= max_step:\n                return to\n            ratio = max_step/d\n            return tuple(frm[i]+(to[i]-frm[i])*ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d += diff*diff\n                    if d > best_dist*best_dist:\n                        break\n                else:\n                    d = math.sqrt(d)\n                    if d < best_dist:\n                        best = node\n                        best_dist = d\n            return best\n\n        def neighbor_radius(tree_len):\n            # Adaptive neighbor radius based on tree size, theoretical RRT* scaling\n            if tree_len < 2:\n                return self.step_size * 2.0\n            return min(self.step_size*5.0, self.neighbor_factor * (math.log(tree_len)/tree_len)**(1.0/dim)*max(bounds))\n\n        def neighbors(tree, point, radius):\n            neigh = []\n            r_sq = radius*radius\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    d_sq += diff*diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    neigh.append(node)\n            return neigh\n\n        c_min = dist(start, goal)\n\n        def ellipsoid_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            center = tuple((start[i]+goal[i])*0.5 for i in range(dim))\n            a1 = [goal[i]-start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x*x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0,bounds[i]) for i in range(dim))\n            unit_a1 = [x/norm_a1 for x in a1]\n\n            # Orthonormal basis U via Gram-Schmidt (dim x dim)\n            U = [unit_a1]\n            for idx in range(dim-1):\n                base = [0.0]*dim\n                base[(idx+1)%dim] = 1.0\n                for u in U:\n                    proj = sum(base[j]*u[j] for j in range(dim))\n                    base = [base[j]-proj*u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x*x for x in base))\n                if norm_base > 1e-14:\n                    base = [x/norm_base for x in base]\n                else:\n                    base = [0.0]*dim\n                U.append(base)\n\n            r1 = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r2 = math.sqrt(val)*0.5 if val>0 else 0.0\n            radii = [r1] + [r2]*(dim-1)\n\n            while True:\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x*x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x/norm_ball for x in x_ball]\n                u_rand = random.random()**(1.0/dim)\n                point_ball = [coord*u_rand for coord in unit_ball]\n\n                point_scaled = [radii[i]*point_ball[i] for i in range(dim)]\n\n                # Rotate by U matrix transpose\n                point_rot = [0.0]*dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rot[j] += point_scaled[i]*U[i][j]\n\n                sample = tuple(center[i]+point_rot[i] for i in range(dim))\n                if all(0.0<=sample[i]<=bounds[i] for i in range(dim)):\n                    return sample\n\n        def add_node(tree, sample, all_nodes, edges, best_cost):\n            nn = nearest(tree, sample)\n            new_pos = steer(nn.position, sample, self.step_size)\n            if in_obstacle(new_pos) or edge_obstacle(nn.position,new_pos):\n                return None\n            radius = neighbor_radius(len(tree))\n            near = neighbors(tree, new_pos, radius)\n            best_parent = nn\n            min_cost = nn.cost + dist(nn.position,new_pos)\n            for candidate in near:\n                cand_cost = candidate.cost + dist(candidate.position,new_pos)\n                if cand_cost + self.improve_tol < min_cost and not edge_obstacle(candidate.position,new_pos):\n                    best_parent = candidate\n                    min_cost = cand_cost\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent,new_node))\n\n            # Rewire neighbors through new node if beneficial\n            for neighbor in near:\n                if neighbor is best_parent: \n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost + self.improve_tol < neighbor.cost and not edge_obstacle(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        neighbor.parent.remove_child(neighbor)\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n                    new_node.add_child(neighbor)\n                    neighbor.cost = alt_cost\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def extract_path(node_s, node_g):\n            path_s = node_s.path_from_root()\n            path_g = node_g.path_from_root()\n            # Avoid duplicate duplicate connecting node\n            if path_s and path_g and path_s[-1] == path_g[-1]:\n                return path_s + path_g[-2::-1]\n            else:\n                return path_s + path_g[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            count = 0\n            changed = True\n            while changed and count < self.shortcut_iters:\n                changed = False\n                count += 1\n                i = 0\n                while i < len(path)-2:\n                    max_jump = min(len(path)-1, i+6)\n                    j = random.randint(i+2, max_jump)\n                    if not edge_obstacle(path[i], path[j]):\n                        path = path[:i+1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        start_node = Node(start)\n        goal_node = Node(goal)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        found = False\n        no_improve_count = 0\n        last_best = best_cost\n\n        for itr in range(self.max_iter):\n            sample_pt = ellipsoid_sample(best_cost)\n\n            if itr % 2 == 0:\n                main_tree, other_tree = tree_start, tree_goal\n            else:\n                main_tree, other_tree = tree_goal, tree_start\n\n            new_node = add_node(main_tree, sample_pt, all_nodes, edges, best_cost)\n            if new_node is None:\n                continue\n\n            near_connect = nearest(other_tree, new_node.position)\n            step_dist = dist(near_connect.position, new_node.position)\n            if step_dist <= self.step_size and not edge_obstacle(new_node.position, near_connect.position):\n                candidate_cost = new_node.cost + near_connect.cost + step_dist\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = extract_path(new_node, near_connect)\n                    found = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n            else:\n                if found:\n                    no_improve_count += 1\n\n            if found:\n                # Early stopping on stagnation of improvement\n                if best_cost + self.improve_tol < last_best:\n                    last_best = best_cost\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                if no_improve_count >= self.no_improve_limit:\n                    break\n\n        if found and len(best_path) > 3:\n            best_path = shortcut_path(best_path)\n\n        if found:\n            return PlannerResult(True, best_path, all_nodes, edges)\n        else:\n            return PlannerResult(False, [], all_nodes, edges)",
        "objective": 6.30946,
        "time_improvement": -81.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1172.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.08813977241516113,
                "num_nodes_avg": 171.3,
                "path_length_avg": 155.94724987804915,
                "smoothness_avg": 0.037895327969512546,
                "success_improvement": 0.0,
                "time_improvement": -262.9326382650782,
                "length_improvement": 14.522841199531285,
                "smoothness_improvement": 493.1441737446706,
                "objective_score": -67.70036589108133
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.08728914260864258,
                "num_nodes_avg": 314.3,
                "path_length_avg": 226.58476458100463,
                "smoothness_avg": 0.07942344506505501,
                "success_improvement": 0.0,
                "time_improvement": 45.93936752179157,
                "length_improvement": 24.35948370202769,
                "smoothness_improvement": 1943.6224479190457,
                "objective_score": 38.11561271734931
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.061713361740112306,
                "num_nodes_avg": 259.4,
                "path_length_avg": 118.83941821204158,
                "smoothness_avg": 0.09275591661871693,
                "success_improvement": 0.0,
                "time_improvement": -24.621265737464196,
                "length_improvement": 21.072516948544795,
                "smoothness_improvement": 1079.8484128604985,
                "objective_score": 10.65637251219011
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "A refined bidirectional RRT* inspired planner with consistent adaptive neighbor radius scaling, prioritized rewiring, and iterative shortcutting for improved path length, smoothness, and efficiency. The planner balances exploration and exploitation by incrementally searching with a well-defined neighbor radius proportional to tree size and dimensionality, performs rewiring for cost minimization, and uses early stopping on cost stagnation. The final path undergoes aggressive shortcutting for length and smoothness improvements.",
        "planning_mechanism": "The algorithm alternates growing two trees from start and goal nodes, samples adaptively inside an informed ellipsoid once a solution exists, extends by steering towards samples within a fixed step size, and performs rewiring of neighbors inside a radius defined by a consistent formula to optimize path costs. Trees attempt connection at every iteration, updating best solution and stopping early when improvements stagnate. A shortcutting routine improves final path length and smoothness.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=6000, step_size=5.0, neighbor_const=2.4, no_improve_stop=60,\n                 improve_tol=1e-6, shortcut_iters=300, shortcut_max_jump=7, time_limit=18.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_const = neighbor_const\n        self.no_improve_stop = no_improve_stop\n        self.improve_tol = improve_tol\n        self.shortcut_iters = shortcut_iters\n        self.shortcut_max_jump = shortcut_max_jump\n        self.time_limit = time_limit\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n\n        def dist(a, b):\n            return math.sqrt(sum((a[i] - b[i]) ** 2 for i in range(dim)))\n\n        def in_obstacle(p):\n            px = p + (0.0,) * (3 - dim) if dim < 3 else p\n            for obs in obstacles:\n                if dim == 2:\n                    x, y, w, h = obs\n                    if x <= px[0] <= x + w and y <= px[1] <= y + h:\n                        return True\n                else:\n                    x, y, z, w, h, d = obs\n                    if x <= px[0] <= x + w and y <= px[1] <= y + h and z <= px[2] <= z + d:\n                        return True\n            return False\n\n        def edge_obstacle(p1, p2, resolution=0.4):\n            length = dist(p1, p2)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * (i / steps) for j in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to, max_step):\n            d = dist(frm, to)\n            if d <= max_step:\n                return to\n            ratio = max_step / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            best = None\n            best_d_sq = float('inf')\n            for node in tree:\n                dd = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    dd += diff * diff\n                    if dd > best_d_sq:\n                        break\n                else:\n                    if dd < best_d_sq:\n                        best = node\n                        best_d_sq = dd\n            return best\n\n        def neighbors(tree, point, radius):\n            r_sq = radius * radius\n            result = []\n            for node in tree:\n                dd = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - point[i]\n                    dd += diff * diff\n                    if dd > r_sq:\n                        break\n                else:\n                    result.append(node)\n            return result\n\n        def neighbor_radius(tree_len):\n            if tree_len < 2:\n                return self.step_size * 3.0\n            # Consistent radius scaling based on RRT* theory:\n            val = (math.log(tree_len) / tree_len) ** (1.0 / dim)\n            radius = min(self.neighbor_const * val * max(bounds), self.step_size * 7.5)\n            return max(radius, self.step_size * 2.0)\n\n        c_min = dist(start, goal)\n\n        def informed_sample(c_best):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            center = tuple((start[i] + goal[i]) * 0.5 for i in range(dim))\n            a1 = [goal[i] - start[i] for i in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-14:\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # Construct an orthonormal basis:\n            U = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0.0] * dim\n                base[(idx + 1) % dim] = 1.0\n                for u in U:\n                    proj = sum(base[j] * u[j] for j in range(dim))\n                    base = [base[j] - proj * u[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-14:\n                    base = [x / norm_base for x in base]\n                else:\n                    base = [0.0] * dim\n                U.append(base)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r_rest = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r_rest] * (dim - 1)\n\n            while True:\n                x_ball = [random.gauss(0, 1) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-14:\n                    continue\n                unit_ball = [x / norm_ball for x in x_ball]\n                u_rand = random.random() ** (1.0 / dim)\n                point_ball = [coord * u_rand for coord in unit_ball]\n\n                point_scaled = [radii[i] * point_ball[i] for i in range(dim)]\n\n                point_rot = [0.0] * dim\n                for i in range(dim):\n                    for j in range(dim):\n                        point_rot[j] += point_scaled[i] * U[i][j]\n\n                sample = tuple(center[i] + point_rot[i] for i in range(dim))\n                if all(0.0 <= sample[i] <= bounds[i] for i in range(dim)):\n                    return sample\n\n        def add_node(tree, sample, all_nodes, edges, c_best):\n            nn = nearest(tree, sample)\n            new_pos = steer(nn.position, sample, self.step_size)\n            if in_obstacle(new_pos) or edge_obstacle(nn.position, new_pos):\n                return None\n            radius = neighbor_radius(len(tree))\n            near = neighbors(tree, new_pos, radius)\n\n            best_parent = nn\n            min_cost = nn.cost + dist(nn.position, new_pos)\n            for cand in near:\n                cand_cost = cand.cost + dist(cand.position, new_pos)\n                if cand_cost + self.improve_tol < min_cost and not edge_obstacle(cand.position, new_pos):\n                    best_parent = cand\n                    min_cost = cand_cost\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for potential improvements\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                alt_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if alt_cost + self.improve_tol < neighbor.cost and not edge_obstacle(new_node.position, neighbor.position):\n                    if neighbor.parent is not None:\n                        neighbor.parent.remove_child(neighbor)\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    new_node.add_child(neighbor)\n                    neighbor.cost = alt_cost\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def extract_path(node_s, node_g):\n            path_s = node_s.path_from_root()\n            path_g = node_g.path_from_root()\n            if path_s and path_g and path_s[-1] == path_g[-1]:\n                # Overlapping connection node, so skip duplicate last\n                return path_s + path_g[-2::-1]\n            return path_s + path_g[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            count = 0\n            changed = True\n            while changed and count < self.shortcut_iters:\n                changed = False\n                count += 1\n                i = 0\n                while i < len(path) - 2:\n                    max_jump_idx = min(len(path) - 1, i + self.shortcut_max_jump)\n                    j = random.randint(i + 2, max_jump_idx)\n                    if not edge_obstacle(path[i], path[j]):\n                        # Remove intermediate points between i and j\n                        path = path[:i + 1] + path[j:]\n                        changed = True\n                        break\n                    i += 1\n            return path\n\n        start_node = Node(start)\n        goal_node = Node(goal)\n        tree_start = [start_node]\n        tree_goal = [goal_node]\n        all_nodes = tree_start + tree_goal\n        edges = []\n\n        best_cost = float('inf')\n        best_path = []\n        found = False\n        no_improve_count = 0\n        last_cost = best_cost\n        t_start = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - t_start > self.time_limit:\n                break\n            sample_pt = informed_sample(best_cost)\n            main_tree, other_tree = (tree_start, tree_goal) if (it % 2 == 0) else (tree_goal, tree_start)\n\n            new_node = add_node(main_tree, sample_pt, all_nodes, edges, best_cost)\n            if new_node is None:\n                if found:\n                    no_improve_count += 1\n                continue\n\n            near_other = nearest(other_tree, new_node.position)\n            d_connect = dist(new_node.position, near_other.position)\n            if d_connect <= self.step_size and not edge_obstacle(new_node.position, near_other.position):\n                candidate_cost = new_node.cost + near_other.cost + d_connect\n                if candidate_cost + self.improve_tol < best_cost:\n                    best_cost = candidate_cost\n                    best_path = extract_path(new_node, near_other)\n                    found = True\n                    no_improve_count = 0\n                else:\n                    if found:\n                        no_improve_count += 1\n            else:\n                if found:\n                    no_improve_count += 1\n\n            if found:\n                if best_cost + self.improve_tol < last_cost:\n                    last_cost = best_cost\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                if no_improve_count >= self.no_improve_stop:\n                    break\n\n        if found and len(best_path) > 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(found, best_path, all_nodes, edges)",
        "objective": 39.15867,
        "time_improvement": -188.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1088.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.11048943996429443,
                "num_nodes_avg": 134.5,
                "path_length_avg": 157.18071287891655,
                "smoothness_avg": 0.04972884232498757,
                "success_improvement": 0.0,
                "time_improvement": -354.96173688524993,
                "length_improvement": 13.846760583283842,
                "smoothness_improvement": 678.3643702955704,
                "objective_score": -94.78864286412681
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.10013914108276367,
                "num_nodes_avg": 271.3,
                "path_length_avg": 229.07299233276945,
                "smoothness_avg": 0.06740144740588477,
                "success_improvement": 0.0,
                "time_improvement": 37.981000374464145,
                "length_improvement": 23.528841658823822,
                "smoothness_improvement": 1634.2877890536852,
                "objective_score": 33.68304405290196
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.17249653339385987,
                "num_nodes_avg": 312.2,
                "path_length_avg": 117.01505065920387,
                "smoothness_avg": 0.08268411140396412,
                "success_improvement": 0.0,
                "time_improvement": -248.331961194964,
                "length_improvement": 22.2841750100922,
                "smoothness_improvement": 951.735793952172,
                "objective_score": -56.37040438267303
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m3",
        "algorithm_description": "A streamlined bidirectional RRT* planner that employs a fixed-radius neighbor search combined with uniform and informed sampling, early termination on improvement stagnation, and post-planning progressive shortcutting for efficient and smooth path finding. It performs consistent collision checks for nodes and edges, incrementally rewires locally to reduce path cost, and attempts to connect the two trees after each insertion to find feasible paths more quickly. The fixed radius provides stable local connectivity without complex adaptive decay, improving runtime and path quality balance.",
        "planning_mechanism": "The planner grows two trees from start and goal positions alternately by sampling points within the map bounds, switching to informed sampling after a solution is found. New nodes are added by steering towards samples with collision avoidance. Parent selection minimizes cost within a fixed-radius neighborhood, and rewiring locally reduces path costs further. After each insertion, it tries to connect the opposite tree to form a path. It terminates early if improvements stagnate for a set number of iterations. Finally, a randomized shortcutting pass smooths the best found path before returning it.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=5.0,\n                 neighbor_radius=20.0,\n                 max_no_improve=60,\n                 shortcut_iter=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.max_no_improve = max_no_improve\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n        import time\n\n        bounds = map.size\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            dist_ab = math.dist(a, b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / resolution))\n            for i in range(steps + 1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            ratio = self.step_size / dist\n            return tuple(frm[d] + (to[d] - frm[d]) * ratio for d in range(dim))\n\n        def neighbors(tree, point, radius):\n            rad_sq = radius * radius\n            res = []\n            for node in tree:\n                d_sq = 0.0\n                for i_ in range(dim):\n                    diff = node.position[i_] - point[i_]\n                    d_sq += diff * diff\n                    if d_sq > rad_sq:\n                        break\n                else:\n                    res.append(node)\n            return res\n\n        def choose_parent(tree, new_pos):\n            nbrs = neighbors(tree, new_pos, self.neighbor_radius)\n            valid_parents = [n for n in nbrs if not edge_in_obstacle(n.position, new_pos)]\n            if not valid_parents:\n                # fallback: nearest with collision-free edge\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = math.dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None:\n                    return None, []\n                cost = nearest.cost + nearest_dist\n                new_node = Node(new_pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            best_parent = min(valid_parents, key=lambda p: p.cost + math.dist(p.position, new_pos))\n            cost_min = best_parent.cost + math.dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=cost_min)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, neighbors_):\n            for nb in neighbors_:\n                if nb == pivot.parent:\n                    continue\n                dist_pivot_nb = math.dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_pivot_nb\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(pivot.position, nb.position):\n                        continue\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree_from, target_node):\n            if not tree_from:\n                return None\n            nearest = min(tree_from, key=lambda n: math.dist(n.position, target_node.position))\n            dist_near = math.dist(nearest.position, target_node.position)\n            if dist_near <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + dist_near)\n                nearest.add_child(new_node)\n                tree_from.append(new_node)\n                return new_node\n            # incremental steering\n            current = nearest\n            steps = int(math.ceil(dist_near / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + math.dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree_from.append(new_node)\n                current = new_node\n                if math.dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current,\n                                      cost=current.cost + math.dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree_from.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d] + goal_pos[d]) * 0.5 for d in range(dim))\n            unit_dir = []\n            for d in range(dim):\n                unit_dir.append((goal_pos[d] - start_pos[d]) / c_min)\n            r1 = c_best * 0.5\n            val = max(c_best*c_best - c_min*c_min, 0.0)\n            r_other = math.sqrt(val)*0.5\n\n            if dim == 2:\n                a1 = unit_dir\n                a2 = (-a1[1], a1[0])\n                basis = (a1, a2)\n                radii = (r1, r_other)\n            else:\n                def cross(u,v):\n                    return (u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0])\n                def norm(v):\n                    return math.sqrt(sum(x*x for x in v))\n                a1 = unit_dir\n                ref = (1,0,0) if abs(a1[0]) < 0.9 else (0,1,0)\n                b2 = cross(a1, ref)\n                n_b2 = norm(b2)\n                if n_b2 < 1e-12:\n                    ref = (0,0,1)\n                    b2 = cross(a1, ref)\n                    n_b2 = norm(b2)\n                b2 = tuple(x / n_b2 for x in b2)\n                b3 = cross(a1, b2)\n                basis = (a1, b2, b3)\n                radii = (r1, r_other, r_other)\n\n            def sample_unit_ball(d):\n                while True:\n                    vec = [random.gauss(0,1) for _ in range(d)]\n                    nrm = math.sqrt(sum(v*v for v in vec))\n                    if nrm < 1e-12:\n                        continue\n                    vec = [v/nrm for v in vec]\n                    r = random.random() ** (1/d)\n                    return [v*r for v in vec]\n\n            u = sample_unit_ball(dim)\n            mapped = []\n            for d in range(dim):\n                val = center[d]\n                for i in range(dim):\n                    val += basis[i][d] * radii[i] * u[i]\n                val = max(0.0, min(val, bounds[d]))\n                mapped.append(val)\n            return tuple(mapped)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _ in range(self.shortcut_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not edge_in_obstacle(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        found_solution = False\n        no_improve_count = 0\n\n        for iter_i in range(self.max_iter):\n            if found_solution:\n                sample = sample_informed(best_cost, c_min)\n                # small chance to sample uniform for exploration\n                if random.random() < 0.15:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            tree_a, tree_b = (start_tree, goal_tree) if iter_i % 2 == 0 else (goal_tree, start_tree)\n\n            nearest_n = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest_n.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_n.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node:\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path)-1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i+1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.max_no_improve:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
        "objective": 3.22489,
        "time_improvement": -72.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1323.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.06798641681671143,
                "num_nodes_avg": 123.4,
                "path_length_avg": 158.25975576767524,
                "smoothness_avg": 0.041266763987781445,
                "success_improvement": 0.0,
                "time_improvement": -179.94728083997234,
                "length_improvement": 13.255320077426443,
                "smoothness_improvement": 545.9144686210723,
                "objective_score": -43.30141986243047
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.08122842311859131,
                "num_nodes_avg": 252.4,
                "path_length_avg": 226.73791300031098,
                "smoothness_avg": 0.090667552008909,
                "success_improvement": 0.0,
                "time_improvement": 49.69294235496602,
                "length_improvement": 24.308358351530394,
                "smoothness_improvement": 2232.9414183872846,
                "objective_score": 40.65760480934446
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.09193034172058105,
                "num_nodes_avg": 257.6,
                "path_length_avg": 118.69005639372278,
                "smoothness_avg": 0.10154385768895954,
                "success_improvement": 0.0,
                "time_improvement": -85.64011458559013,
                "length_improvement": 21.171715956426652,
                "smoothness_improvement": 1191.6303746156489,
                "objective_score": -7.0308529287428
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "m2",
        "algorithm_description": "An improved bidirectional RRT* planner that integrates adaptive informed sampling, dynamic rewiring with efficient neighbor querying via spatial hashing, and a curvature-aware smoothing post-process. The planner alternates tree growth from start and goal, uses a tempered early stopping mechanism based on improvement stagnation, and refines the final path by combining shortcutting with a lightweight curvature smoothing pass to produce collision-free, shorter, and smoother trajectories while reducing planning time.",
        "planning_mechanism": "The planner performs bidirectional tree expansion with alternating growth and connection attempts, samples points biased by a mix of goal, uniform, and informed strategies restricted to a reshaped ellipsoid for focusing search as better solutions emerge. It maintains spatial hashed structures for efficient neighbor retrieval and performs adaptive radius rewiring to optimize path cost and structure locally. Early stopping prevents unnecessary computation. The final extracted path goes through multi-pass shortcutting combined with a curvature-based moving average smoothing to improve smoothness of the trajectory while preserving obstacle clearance and path length gains.",
        "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=4.5,\n                 base_radius=18.0,\n                 min_radius=7.5,\n                 time_limit=15.0,\n                 no_improve_limit=40,\n                 shortcut_passes=6,\n                 shortcut_attempts=600,\n                 uniform_sample_chance=0.12,\n                 goal_sample_chance=0.07,\n                 grid_cell_size=12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_chance = uniform_sample_chance\n        self.goal_sample_chance = goal_sample_chance\n        self.grid_cell_size = grid_cell_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import time\n        import random\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,) * (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a,b,res=1.0):\n            dist = math.dist(a,b)\n            if dist < 1e-12:\n                return False\n            steps = max(2,int(dist/res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm,to):\n            dist = math.dist(frm,to)\n            if dist <= self.step_size:\n                return to\n            r = self.step_size/dist\n            return tuple(frm[d] + (to[d]-frm[d])*r for d in range(dim))\n\n        class SpatialGrid:\n            __slots__ = ('cell_size','dim','grid')\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self,pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self,node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self,node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self,pos,radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                result = []\n                rng = range(-cr,cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx,base[1]+dy)\n                            if cell in self.grid:\n                                result.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx,base[1]+dy,base[2]+dz)\n                                if cell in self.grid:\n                                    result.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for node in result:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        dist_sq += (node.position[d]-pos[d])**2\n                    if dist_sq <= r2:\n                        filtered.append(node)\n                return filtered\n            def nearest(self,pos):\n                base = self._hash(pos)\n                search_range = 0\n                candidates = []\n                max_search = 7\n                while not candidates and search_range <= max_search:\n                    rng = range(-search_range, search_range+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        candidates.extend(self.grid[cell])\n                    search_range += 1\n                if not candidates:\n                    return None\n                nearest_node = min(candidates,key=lambda n:math.dist(n.position,pos))\n                return nearest_node\n\n        # Sampling strategies\n        def sample_uniform():\n            for _ in range(30):\n                p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n            center = tuple(0.5*(start_pos[d]+goal_pos[d]) for d in range(dim))\n            a1 = [(goal_pos[d]-start_pos[d])/c_min for d in range(dim)]\n            # Radii of ellipse axes:\n            r1 = c_best*0.5\n            squared = max(0.0, c_best*c_best - c_min*c_min)\n            r_others = math.sqrt(squared)*0.5 if dim > 1 else 0\n            radii = [r1] + [r_others]*(dim-1)\n            # Build orthonormal basis with a1 as first vector\n            basis = []\n            basis.append(a1)\n            for i in range(1,dim):\n                v = [0.0]*dim\n                v[i] = 1.0\n                # Gram-Schmidt\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j] - proj*b[j] for j in range(dim)]\n                norm_v = math.sqrt(sum(x*x for x in v))\n                if norm_v > 1e-10:\n                    v = [x/norm_v for x in v]\n                else:\n                    v = [0.0]*dim\n                basis.append(v)\n            for _ in range(40):\n                vec = [random.gauss(0,1) for _ in range(dim)]\n                norm_vec = math.sqrt(sum(x*x for x in vec))\n                if norm_vec < 1e-10:\n                    continue\n                unit_vec = [x/norm_vec for x in vec]\n                r = random.random()**(1/dim)\n                scale = [radii[i]*unit_vec[i]*r for i in range(dim)]\n                p = [center[j] + sum(basis[i][j]*scale[i] for i in range(dim)) for j in range(dim)]\n                clamped = tuple(max(0.0,min(bounds[d],p[d])) for d in range(dim))\n                if not in_obstacle(clamped):\n                    return clamped\n            return sample_uniform()\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def adaptive_radius(n_nodes):\n            if n_nodes < 2:\n                return self.base_radius\n            val = self.base_radius * (math.log(n_nodes+1)/(n_nodes+1))**(1/dim)\n            return max(self.min_radius, min(val, self.base_radius))\n\n        def choose_parent(nodes, grid, pos, radius):\n            neighbors = grid.query_radius(pos, radius)\n            candidates = [n for n in neighbors if n and not edge_in_obstacle(n.position, pos)]\n            if not candidates:\n                nearest = grid.nearest(pos)\n                if nearest is None or edge_in_obstacle(nearest.position, pos) or in_obstacle(pos):\n                    return None, []\n                candidates = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in candidates:\n                c = nb.cost + math.dist(nb.position, pos)\n                if c < best_cost:\n                    best_cost = c\n                    best_parent = nb\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, candidates\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, nb.position)\n                if new_cost + 1e-12 < nb.cost:\n                    if edge_in_obstacle(new_node.position, nb.position):\n                        continue\n                    if nb.parent is not None:\n                        nb.parent.remove_child(nb)\n                    new_node.add_child(nb)\n                    nb.cost = new_cost\n                    stack = [nb]\n                    while stack:\n                        curr = stack.pop()\n                        for ch in curr.children:\n                            new_ch_cost = curr.cost + math.dist(curr.position, ch.position)\n                            if new_ch_cost + 1e-12 < ch.cost:\n                                ch.cost = new_ch_cost\n                                ch.parent = curr\n                                stack.append(ch)\n\n        def try_connect(tree_nodes, tree_grid, other_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_grid.nearest(other_node.position)\n            if nearest is None:\n                return None\n            dist = math.dist(nearest.position, other_node.position)\n            if dist <= self.step_size:\n                if edge_in_obstacle(nearest.position, other_node.position) or in_obstacle(other_node.position):\n                    return None\n                new_node = Node(other_node.position, parent=nearest, cost=nearest.cost+dist)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                return new_node\n            current = nearest\n            max_steps = int(math.ceil(dist/self.step_size))\n            for _ in range(max_steps):\n                new_pos = steer(current.position, other_node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos) or \n                    edge_in_obstacle(current.position, new_pos)):\n                    return None\n                d = math.dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=current.cost+d)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, other_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, other_node.position) or in_obstacle(other_node.position):\n                        return None\n                    final_node = Node(other_node.position, parent=current, cost=current.cost + math.dist(current.position, other_node.position))\n                    tree_nodes.append(final_node)\n                    tree_grid.insert(final_node)\n                    return final_node\n            return None\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _pass in range(self.shortcut_passes):\n                changed = True\n                attempt = 0\n                while changed and attempt < self.shortcut_attempts:\n                    changed = False\n                    attempt += 1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path) - 3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1, p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        def smooth_path(path):\n            # Curvature-aware lightweight smoothing by iterative averaging without entering obstacles\n            if len(path) < 4:\n                return path[:]\n            smoothed = list(path)\n            alpha = 0.15  # blending factor\n            for _ in range(7):\n                for i in range(1, len(smoothed)-1):\n                    prev_p = smoothed[i-1]\n                    curr_p = smoothed[i]\n                    next_p = smoothed[i+1]\n                    new_pt = tuple(\n                        curr_p[d] + alpha * (prev_p[d] + next_p[d] - 2 * curr_p[d])\n                        for d in range(dim)\n                    )\n                    # Clamp to bounds\n                    clamped = tuple(max(0.0, min(bounds[d], new_pt[d])) for d in range(dim))\n                    if (not in_obstacle(clamped) and\n                        not edge_in_obstacle(smoothed[i-1], clamped) and\n                        not edge_in_obstacle(clamped, smoothed[i+1])):\n                        smoothed[i] = clamped\n            return smoothed\n\n        # Initialize trees and grids\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found = False\n        no_improve_count = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n\n            r = random.random()\n            if r < self.goal_sample_chance:\n                sample_pt = sample_goal()\n            elif found and r < self.goal_sample_chance + (1 - self.goal_sample_chance) * (1 - self.uniform_sample_chance):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid_a.nearest(sample_pt)\n            if nearest is None:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if (not in_bounds(new_pos) or in_obstacle(new_pos) or \n                edge_in_obstacle(nearest.position, new_pos)):\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            radius = adaptive_radius(len(tree_a))\n            new_node, neighbors = choose_parent(tree_a, grid_a, new_pos, radius)\n            if new_node is None:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid_a)\n\n            connect_node = try_connect(tree_b, grid_b, new_node)\n            if connect_node is not None:\n                if it % 2 == 0:\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = connect_node.path_from_root()\n                else:\n                    path_from_start = connect_node.path_from_root()\n                    path_from_goal = new_node.path_from_root()\n\n                if path_from_start and path_from_goal and (path_from_start[-1] == path_from_goal[0]):\n                    merged = path_from_start + path_from_goal[1:]\n                else:\n                    merged = path_from_start + path_from_goal[::-1]\n\n                # Calculate cost\n                total_cost = 0.0\n                for i in range(len(merged)-1):\n                    total_cost += math.dist(merged[i], merged[i+1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = merged\n                    found = True\n                    no_improve_count = 0\n                else:\n                    if found:\n                        no_improve_count += 1\n                        if no_improve_count >= self.no_improve_limit:\n                            break\n            else:\n                if found:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n        if found and len(best_path) > 3:\n            best_path = shortcut_path(best_path)\n            best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found, path=best_path,\n                             nodes=start_tree + goal_tree,\n                             edges=[])",
        "objective": -22.47355,
        "time_improvement": 31.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 210.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.02435743808746338,
                "num_nodes_avg": 134.9,
                "path_length_avg": 150.0151772566704,
                "smoothness_avg": 0.011776657899457267,
                "success_improvement": 0.0,
                "time_improvement": -0.2964839167292523,
                "length_improvement": 17.77430420301498,
                "smoothness_improvement": 84.3302695484517,
                "objective_score": 10.997288694532472
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.034082865715026854,
                "num_nodes_avg": 318.3,
                "path_length_avg": 236.9473194012731,
                "smoothness_avg": 0.010060586508523858,
                "success_improvement": 0.0,
                "time_improvement": 78.89151820994326,
                "length_improvement": 20.900164633419585,
                "smoothness_improvement": 158.8661372118814,
                "objective_score": 37.00188492909413
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.0427628755569458,
                "num_nodes_avg": 416.9,
                "path_length_avg": 116.96333679077054,
                "smoothness_avg": 0.038308683773727,
                "success_improvement": 0.0,
                "time_improvement": 13.64651789798031,
                "length_improvement": 22.318520899155825,
                "smoothness_improvement": 387.283629948907,
                "objective_score": 19.421486058632123
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "A Bidirectional Adaptive Informed RRT* planner integrating spatial hashing for accelerated nearest neighbor search, dynamic adaptive rewiring with curvature-aware cost propagation, integrated pruning of suboptimal nodes to constrain tree size, and an enhanced multi-pass shortcutting and curvature-aware smoothing during planning and post-processing. The planner balances exploration and informed focused sampling within ellipsoidal regions shrinking with best path cost, alternates tree expansions from start and goal, and aggressively optimizes path length and smoothness while controlling computational cost via pruning and efficient collision checks.",
        "planning_mechanism": "The planner maintains two trees grown alternately from start and goal positions. Sampling shifts from uniform to ellipsoidal informed sampling focused around the current best solution, with fallback uniform sampling. Spatial hashing accelerates nearest and neighbor searches allowing efficient adaptive rewiring within a radius that diminishes with tree size and best path cost. New nodes integrate curvature penalties directly into cost evaluation to favor smooth transitions. Rewiring triggers downstream cost propagation and curvature checks to enhance smoothness. Suboptimal branches exceeding cost and curvature thresholds are pruned dynamically to reduce overhead. Finally, multi-pass shortcutting and curvature-aware smoothing\u2014executed both during planning and after termination\u2014refine the extracted path into a shorter, smoother trajectory while ensuring collision-free continuity. Early stopping occurs based on improvement stagnation or time limit, resulting in robust, efficient planning with high-quality paths.",
        "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4000,\n                 step_size=5.0,\n                 base_radius=20.0,\n                 min_radius=5.0,\n                 time_limit=15.0,\n                 no_improve_limit=60,\n                 shortcut_passes=5,\n                 shortcut_attempts=400,\n                 uniform_sample_prob=0.1,\n                 goal_sample_prob=0.08,\n                 grid_cell_size=15.0,\n                 curvature_w=0.06,\n                 max_curvature_increase=0.12,\n                 prune_cost_factor=1.8):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_prob = uniform_sample_prob\n        self.goal_sample_prob = goal_sample_prob\n        self.grid_cell_size = grid_cell_size\n        self.curvature_w = curvature_w\n        self.max_curvature_increase = max_curvature_increase\n        self.prune_cost_factor = prune_cost_factor\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,) * (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a,b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(2, int(dist_ab / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist_f_t = math.dist(frm, to)\n            if dist_f_t <= self.step_size:\n                return to\n            r = self.step_size / dist_f_t\n            return tuple(frm[d] + (to[d] - frm[d]) * r for d in range(dim))\n\n        # Curvature penalty: angle between vectors (parent->current) and (current->new)\n        def curvature_penalty(p_parent, p_curr, p_new):\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_curr[d] - p_parent[d] for d in range(dim))\n            v2 = tuple(p_new[d] - p_curr[d] for d in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[d]*v2[d] for d in range(dim)) / (len1 * len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        # Spatial hashing for fast neighbor queries\n        class SpatialGrid:\n            __slots__ = ('cell_size', 'dim', 'grid')\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self, pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self, node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self, node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self, pos, radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                result = []\n                rng = range(-cr, cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx, base[1]+dy)\n                            if cell in self.grid:\n                                result.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                if cell in self.grid:\n                                    result.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for node in result:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        diff = node.position[d] - pos[d]\n                        dist_sq += diff*diff\n                        if dist_sq > r2:\n                            break\n                    else:\n                        filtered.append(node)\n                return filtered\n            def nearest(self, pos):\n                base = self._hash(pos)\n                search_range = 0\n                candidates = []\n                max_search = 8\n                while not candidates and search_range <= max_search:\n                    rng = range(-search_range, search_range+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        candidates.extend(self.grid[cell])\n                    search_range += 1\n                if not candidates:\n                    return None\n                nearest_node = min(candidates, key=lambda n: math.dist(n.position,pos))\n                return nearest_node\n\n        # Sampling methods\n        def sample_uniform():\n            for _ in range(30):\n                p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d]+goal_pos[d])*0.5 for d in range(dim))\n            # Unit vector from start to goal:\n            dvec = [(goal_pos[d]-start_pos[d]) / c_min for d in range(dim)]\n            # Build orthonormal basis\n            basis = [dvec]\n            for i in range(1, dim):\n                v = [0.0]*dim\n                v[i] = 1.0\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j]-proj*b[j] for j in range(dim)]\n                normv = math.sqrt(sum(x*x for x in v))\n                basis.append([x/normv if normv>1e-14 else 0.0 for x in v])\n            r_long = c_best * 0.5\n            val = c_best*c_best - c_min*c_min\n            r_short = math.sqrt(max(0.0,val))*0.5 if dim > 1 else 0.0\n            radii = [r_long] + [r_short]*(dim-1)\n            for _ in range(40):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                unit_x = [x / norm_x for x in x_ball]\n                u = random.random()**(1/dim)\n                scaled = [radii[i]*unit_x[i]*u for i in range(dim)]\n                sample = [center[d] + sum(basis[i][d]*scaled[i] for i in range(dim)) for d in range(dim)]\n                sample = tuple(max(0.0, min(bounds[d], sample[d])) for d in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes < 2:\n                return self.base_radius\n            val = self.base_radius * (math.log(n_nodes+1) / (n_nodes+1))**(1/dim)\n            radius = max(self.min_radius, min(val, self.base_radius))\n            if c_best == float('inf'):\n                return radius\n            # Shrink radius with best solution cost to focus rewiring locally\n            shrink_factor = c_best / (math.dist(start_pos, goal_pos) * 2.8)\n            return max(self.min_radius, radius * max(0.4, shrink_factor))\n\n        def choose_parent(nodes, grid, pos, radius, c_best):\n            neighbors = grid.query_radius(pos, radius)\n            candidates = []\n            for nb in neighbors:\n                if in_obstacle(pos) or edge_in_obstacle(nb.position, pos):\n                    continue\n                candidates.append(nb)\n            if not candidates:\n                nearest = grid.nearest(pos)\n                if nearest is None or in_obstacle(pos) or edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                candidates = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in candidates:\n                c = nb.cost + math.dist(nb.position, pos)\n                curv = curvature_penalty(nb.parent.position if nb.parent else None, nb.position, pos)\n                score = c + self.curvature_w * curv\n                if score < best_cost:\n                    best_cost = score\n                    best_parent = nb\n            if best_parent is None:\n                return None, []\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, candidates\n\n        def propagate_costs(node, grid):\n            # DFS propagate improved costs downstream\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for ch in curr.children[:]:\n                    new_cost = curr.cost + math.dist(curr.position, ch.position)\n                    curv = curvature_penalty(curr.parent.position if curr.parent else None, curr.position, ch.position)\n                    new_score = new_cost + self.curvature_w * curv\n                    old_score = ch.cost + (self.curvature_w * curvature_penalty(ch.parent.parent.position if ch.parent and ch.parent.parent else None, ch.parent.position if ch.parent else None, ch.position) if ch.parent else 0)\n                    if new_score + 1e-10 < old_score:\n                        if edge_in_obstacle(curr.position, ch.position):\n                            continue\n                        ch.cost = new_cost\n                        ch.parent.remove_child(ch)\n                        curr.add_child(ch)\n                        stack.append(ch)\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                dist_new_nb = math.dist(new_node.position, nb.position)\n                new_cost = new_node.cost + dist_new_nb\n                if new_cost + 1e-12 >= nb.cost:\n                    continue\n                if edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                # Curvature penalty with parent-child relation check\n                curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, nb.position)\n                curv_old = curvature_penalty(nb.parent.parent.position if nb.parent and nb.parent.parent else None,\n                                            nb.parent.position if nb.parent else None, nb.position)\n                if self.curvature_w * curv_new > self.curvature_w * curv_old + self.max_curvature_increase:\n                    continue\n                if nb.parent is not None:\n                    nb.parent.remove_child(nb)\n                new_node.add_child(nb)\n                nb.cost = new_cost\n                propagate_costs(nb, grid)\n\n        def try_connect(tree_nodes, tree_grid, other_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_grid.nearest(other_node.position)\n            if nearest is None:\n                return None\n            dist_n_o = math.dist(nearest.position, other_node.position)\n            if dist_n_o <= self.step_size:\n                if edge_in_obstacle(nearest.position, other_node.position) or in_obstacle(other_node.position):\n                    return None\n                new_node = Node(other_node.position, parent=nearest, cost=nearest.cost+dist_n_o)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                return new_node\n            current = nearest\n            max_steps = int(math.ceil(dist_n_o / self.step_size))\n            for _ in range(max_steps):\n                new_pos = steer(current.position, other_node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos)):\n                    return None\n                dist_c_np = math.dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=current.cost+dist_c_np)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, other_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, other_node.position) or in_obstacle(other_node.position):\n                        return None\n                    final_node = Node(other_node.position, parent=current, cost=current.cost + math.dist(current.position, other_node.position))\n                    tree_nodes.append(final_node)\n                    tree_grid.insert(final_node)\n                    return final_node\n            return None\n\n        # Prune nodes that are far above best_path cost to keep tree small\n        def prune_tree(nodes, grid, cost_limit):\n            remove_nodes = []\n            for n in nodes:\n                if n.cost > cost_limit:\n                    remove_nodes.append(n)\n            for n in remove_nodes:\n                # Remove from parent's children list\n                if n.parent:\n                    n.parent.remove_child(n)\n                # Remove from grid and nodes list\n                grid.remove(n)\n                if n in nodes:\n                    nodes.remove(n)\n                # Post removal descendants are unreachable, no direct deletion here (could be improved)\n            return len(remove_nodes)\n\n        # Shortcutting path by removing intermediate nodes with collision-free chords\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _pass in range(self.shortcut_passes):\n                changed = True\n                attempts = 0\n                while changed and attempts < self.shortcut_attempts:\n                    changed = False\n                    attempts +=1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path)-3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1, p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        # Curvature-aware smoothing by iterative averaging during and after planning\n        def smooth_path(path):\n            if len(path) < 4:\n                return list(path)\n            smoothed = list(path)\n            alpha = 0.17\n            for _ in range(9):\n                for i in range(1, len(smoothed)-1):\n                    prev_p, curr_p, next_p = smoothed[i-1], smoothed[i], smoothed[i+1]\n                    new_pt = tuple(curr_p[d] + alpha*(prev_p[d] + next_p[d] - 2*curr_p[d]) for d in range(dim))\n                    # Clamp and collision check\n                    new_pt = tuple(max(0.0, min(bounds[d], new_pt[d])) for d in range(dim))\n                    if (not in_obstacle(new_pt) and not edge_in_obstacle(smoothed[i-1], new_pt) and not edge_in_obstacle(new_pt, smoothed[i+1])):\n                        smoothed[i] = new_pt\n            return smoothed\n\n        # Extract combined path from start_node to goal_node by reversing one branch and concatenating\n        def combine_paths(start_node, goal_node, reverse_start):\n            path_start = start_node.path_from_root()\n            path_goal = goal_node.path_from_root()\n            if reverse_start:\n                # path_start reversed, so goal_node tree is forward\n                path_start.reverse()\n                full_path = path_goal + path_start[1:]\n            else:\n                # start_node forward, goal_node reversed\n                path_goal.reverse()\n                full_path = path_start + path_goal[1:]\n            return full_path\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n        start_time = time.time()\n        c_min = math.dist(start_pos, goal_pos)\n\n        for it in range(self.max_iter):\n            if time.time() - start_time > self.time_limit:\n                break\n\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n                reverse_start = False\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n                reverse_start = True\n\n            r = random.random()\n            if r < self.goal_sample_prob:\n                sample_pt = sample_goal()\n            elif found_solution and r < self.goal_sample_prob + (1 - self.goal_sample_prob - self.uniform_sample_prob):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid_a.nearest(sample_pt)\n            if nearest is None:\n                if found_solution:\n                    no_improve_count +=1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            radius = adaptive_radius(len(tree_a), best_cost)\n            new_node, neighbors = choose_parent(tree_a, grid_a, new_pos, radius, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid_a)\n\n            connect_node = try_connect(tree_b, grid_b, new_node)\n            if connect_node:\n                candidate_path = combine_paths(new_node, connect_node, reverse_start)\n                total_cost = 0.0\n                for i in range(len(candidate_path) -1):\n                    total_cost += math.dist(candidate_path[i], candidate_path[i+1])\n                if total_cost + 1e-10 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                    # Prune both trees aggressively to trim nodes far away from best cost\n                    cost_limit = best_cost * self.prune_cost_factor\n                    prune_tree(start_tree, start_grid, cost_limit)\n                    prune_tree(goal_tree, goal_grid, cost_limit)\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count +=1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n            # Early abort if improvement stagnates heavily\n            if found_solution and no_improve_count >= self.no_improve_limit:\n                break\n\n        if found_solution and len(best_path) > 3:\n            # Multi-pass shortcutting and smoothing post-planning\n            for _ in range(2):\n                best_path = shortcut_path(best_path)\n                best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path,\n                             nodes=start_tree + goal_tree,\n                             edges=[])",
        "objective": -21.94032,
        "time_improvement": 27.0,
        "length_improvement": 21.0,
        "smoothness_improvement": 218.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.033988142013549806,
                "num_nodes_avg": 152.2,
                "path_length_avg": 155.0029124627248,
                "smoothness_avg": 0.013386992872664144,
                "success_improvement": 0.0,
                "time_improvement": -39.95277855498452,
                "length_improvement": 15.040447500854501,
                "smoothness_improvement": 109.53550877750344,
                "objective_score": -2.413887522095137
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.03955721855163574,
                "num_nodes_avg": 342.0,
                "path_length_avg": 225.80758202741654,
                "smoothness_avg": 0.014658329875318548,
                "success_improvement": 0.0,
                "time_improvement": 75.50109681374721,
                "length_improvement": 24.618929608374863,
                "smoothness_improvement": 277.16938566019917,
                "objective_score": 38.80753373745007
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.027274346351623534,
                "num_nodes_avg": 269.3,
                "path_length_avg": 113.89325843043791,
                "smoothness_avg": 0.02886494217452123,
                "success_improvement": 0.0,
                "time_improvement": 44.923376904744714,
                "length_improvement": 24.357520764667115,
                "smoothness_improvement": 267.15993387150496,
                "objective_score": 29.427325199581208
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "cross_over",
        "algorithm_description": "A bidirectional informed RRT* planner with dynamically scaled neighbor radius based on sample density and cost, efficient spatial hashing for fast nearest and neighbor lookups, curvature-penalized cost for smoothness, iterative rewiring with cost improvement propagation, focused informed sampling after initial solution, adaptive pruning to maintain tree compactness, and enhanced multi-pass adaptive shortcutting and smoothing employing curvature-aware node updates. Early stopping on stagnation and improved parent choosing considering combined cost-curvature measure lead to faster convergence to shorter, smoother paths.",
        "planning_mechanism": "A bidirectional RRT* that alternately grows start and goal trees, efficiently finding near neighbors via spatial hashing with dynamically scaled radii supporting rewiring and cost propagation; it employs an ellipsoidal informed sampler once a solution is found to expedite convergence. Curvature penalties are integrated in parent choosing and rewiring steps for smoothness, complemented by adaptive multi-pass shortcutting and smoothing including curvature-based node adjustments. The planner prunes nodes exceeding adaptively updated cost thresholds to limit search space growth and uses stagnation detection to stop early, achieving improved path length and reduced planning times.",
        "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        p = []\n        n = self\n        while n:\n            p.append(n.position)\n            n = n.parent\n        return p[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3000,\n                 step_size=4.5,\n                 base_radius=20.0,\n                 min_radius=3.5,\n                 time_limit=10.0,\n                 no_improve_limit=40,\n                 shortcut_passes=4,\n                 shortcut_attempts=400,\n                 uniform_sample_prob=0.12,\n                 goal_sample_prob=0.06,\n                 grid_cell_size=12.0,\n                 curvature_w=0.07,\n                 max_curv_increase=0.12,\n                 prune_factor=1.6):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_prob = uniform_sample_prob\n        self.goal_sample_prob = goal_sample_prob\n        self.grid_cell_size = grid_cell_size\n        self.curvature_w = curvature_w\n        self.max_curv_increase = max_curv_increase\n        self.prune_factor = prune_factor\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,) * (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a,b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(3, int(dist_ab / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d]) * i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            r = self.step_size / dist\n            return tuple(frm[d] + (to[d]-frm[d])*r for d in range(dim))\n\n        def curvature_penalty(p_parent, p_curr, p_new):\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_curr[d]-p_parent[d] for d in range(dim))\n            v2 = tuple(p_new[d]-p_curr[d] for d in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-16 or len2 < 1e-16:\n                return 0.0\n            dot = sum(v1[d]*v2[d] for d in range(dim)) / (len1 * len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        class SpatialGrid:\n            __slots__ = ('cell_size','dim','grid')\n            def __init__(self,bounds,cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self,pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self,node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self,node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self,pos,radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                candidates = []\n                rng = range(-cr,cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx, base[1]+dy)\n                            if cell in self.grid:\n                                candidates.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for n in candidates:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        diff = n.position[d] - pos[d]\n                        dist_sq += diff*diff\n                        if dist_sq > r2:\n                            break\n                    else:\n                        filtered.append(n)\n                return filtered\n            def nearest(self,pos):\n                base = self._hash(pos)\n                rng_lim = 8\n                search_r = 0\n                cand = []\n                while not cand and search_r <= rng_lim:\n                    rng = range(-search_r,search_r+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    cand.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        cand.extend(self.grid[cell])\n                    search_r += 1\n                if not cand:\n                    return None\n                nearest_node = min(cand, key=lambda n: math.dist(n.position,pos))\n                return nearest_node\n\n        def sample_uniform():\n            for _ in range(20):\n                p = tuple(random.uniform(0.0,bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0.0,bounds[d]) for d in range(dim))\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-14:\n                return sample_uniform()\n            center = tuple((start_pos[d]+goal_pos[d])*0.5 for d in range(dim))\n            dvec = [(goal_pos[d]-start_pos[d]) / c_min for d in range(dim)]\n            basis = [dvec]\n            for i in range(1,dim):\n                v = [0.0]*dim\n                v[i] = 1.0\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j]-proj*b[j] for j in range(dim)]\n                normv = math.sqrt(sum(x*x for x in v))\n                basis.append([x/normv if normv>1e-14 else 0.0 for x in v])\n            r_long = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r_short = math.sqrt(max(0.0,val))*0.5 if dim>1 else 0.0\n            radii = [r_long] + [r_short]*(dim-1)\n            for _ in range(30):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                unit_x = [x / norm_x for x in x_ball]\n                u = random.random()**(1/dim)\n                scaled = [radii[i]*unit_x[i]*u for i in range(dim)]\n                sample = [center[d] + sum(basis[i][d]*scaled[i] for i in range(dim)) for d in range(dim)]\n                sample = tuple(max(0.0,min(bounds[d], sample[d])) for d in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def neighbor_radius(n_nodes, c_best):\n            if n_nodes < 2:\n                return self.base_radius\n            val = self.base_radius * (math.log(n_nodes+1)/(n_nodes+1))**(1/dim)\n            radius = max(self.min_radius, min(val, self.base_radius))\n            if c_best == float('inf'):\n                return radius\n            shrinkf = c_best / (math.dist(start_pos, goal_pos)*2.5)\n            return max(self.min_radius, radius * max(0.38, shrinkf))\n\n        def choose_parent(nodes, grid, pos, radius, c_best):\n            neighbors = grid.query_radius(pos, radius)\n            good_neighbors = []\n            for nb in neighbors:\n                if in_obstacle(pos) or edge_in_obstacle(nb.position, pos):\n                    continue\n                good_neighbors.append(nb)\n            if not good_neighbors:\n                nearest = grid.nearest(pos)\n                if nearest is None or in_obstacle(pos) or edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                good_neighbors = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in good_neighbors:\n                dist_ = math.dist(nb.position, pos)\n                c = nb.cost + dist_\n                curv = curvature_penalty(nb.parent.position if nb.parent else None, nb.position, pos)\n                score = c + self.curvature_w*curv\n                if score < best_cost:\n                    best_cost = score\n                    best_parent = nb\n            if best_parent is None:\n                return None, []\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, good_neighbors\n\n        def propagate_costs(node,grid):\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for ch in curr.children[:]:\n                    new_cost = curr.cost + math.dist(curr.position, ch.position)\n                    curv = curvature_penalty(curr.parent.position if curr.parent else None, curr.position, ch.position)\n                    new_score = new_cost + self.curvature_w*curv\n                    old_score = ch.cost + (self.curvature_w*curvature_penalty(ch.parent.parent.position if ch.parent and ch.parent.parent else None,\n                                                                            ch.parent.position if ch.parent else None, ch.position) if ch.parent else 0)\n                    if new_score + 1e-11 < old_score:\n                        if edge_in_obstacle(curr.position, ch.position):\n                            continue\n                        ch.cost = new_cost\n                        if ch.parent:\n                            ch.parent.remove_child(ch)\n                        curr.add_child(ch)\n                        stack.append(ch)\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb is new_node.parent:\n                    continue\n                dist_ = math.dist(new_node.position, nb.position)\n                new_cost = new_node.cost + dist_\n                if new_cost + 1e-12 >= nb.cost:\n                    continue\n                if edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, nb.position)\n                curv_old = curvature_penalty(nb.parent.parent.position if nb.parent and nb.parent.parent else None,\n                                            nb.parent.position if nb.parent else None, nb.position)\n                if self.curvature_w*curv_new > self.curvature_w*curv_old + self.max_curv_increase:\n                    continue\n                if nb.parent is not None:\n                    nb.parent.remove_child(nb)\n                new_node.add_child(nb)\n                nb.cost = new_cost\n                propagate_costs(nb, grid)\n\n        def try_connect(tree_nodes, tree_grid, other_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_grid.nearest(other_node.position)\n            if nearest is None:\n                return None\n            dist_no = math.dist(nearest.position, other_node.position)\n            if dist_no <= self.step_size:\n                if edge_in_obstacle(nearest.position, other_node.position) or in_obstacle(other_node.position):\n                    return None\n                new_node = Node(other_node.position, parent=nearest, cost=nearest.cost + dist_no)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                return new_node\n            current = nearest\n            max_steps = int(math.ceil(dist_no/self.step_size))\n            for _ in range(max_steps):\n                new_pos = steer(current.position, other_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                dist_cnp = math.dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=current.cost + dist_cnp)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, other_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, other_node.position) or in_obstacle(other_node.position):\n                        return None\n                    final_node = Node(other_node.position, parent=current, cost=current.cost + math.dist(current.position, other_node.position))\n                    tree_nodes.append(final_node)\n                    tree_grid.insert(final_node)\n                    return final_node\n            return None\n\n        def prune_tree(nodes, grid, cost_limit):\n            to_remove = [n for n in nodes if n.cost > cost_limit]\n            for n in to_remove:\n                if n.parent:\n                    n.parent.remove_child(n)\n                grid.remove(n)\n                if n in nodes:\n                    nodes.remove(n)\n            return len(to_remove)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _ in range(self.shortcut_passes):\n                changed = True\n                attempts = 0\n                while changed and attempts < self.shortcut_attempts:\n                    changed = False\n                    attempts += 1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path)-3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1,p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        def smooth_path(path):\n            if len(path) < 4:\n                return list(path)\n            smoothed = list(path)\n            alpha = 0.22\n            for _ in range(14):\n                for i in range(1, len(smoothed)-1):\n                    prev_p, curr_p, next_p = smoothed[i-1], smoothed[i], smoothed[i+1]\n                    cand = tuple(curr_p[d] + alpha*(prev_p[d]+next_p[d]-2*curr_p[d]) for d in range(dim))\n                    cand_clamped = tuple(max(0.0,min(bounds[d], cand[d])) for d in range(dim))\n                    if (not in_obstacle(cand_clamped) and not edge_in_obstacle(smoothed[i-1], cand_clamped)\n                        and not edge_in_obstacle(cand_clamped, smoothed[i+1])):\n                        smoothed[i] = cand_clamped\n            return smoothed\n\n        def combine_paths(snode, gnode, reverse_start):\n            pstart = snode.path_from_root()\n            pgoal = gnode.path_from_root()\n            if reverse_start:\n                pstart.reverse()\n                return pgoal + pstart[1:]\n            else:\n                pgoal.reverse()\n                return pstart + pgoal[1:]\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found = False\n        no_improve = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n                rev_start = False\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n                rev_start = True\n\n            r = random.random()\n            if r < self.goal_sample_prob:\n                sample_pt = sample_goal()\n            elif found and r < self.goal_sample_prob + (1 - self.goal_sample_prob - self.uniform_sample_prob):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid_a.nearest(sample_pt)\n            if nearest is None:\n                if found:\n                    no_improve +=1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            radius = neighbor_radius(len(tree_a), best_cost)\n            new_node, neighbors = choose_parent(tree_a, grid_a, new_pos, radius, best_cost)\n            if new_node is None:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid_a)\n\n            conn_node = try_connect(tree_b, grid_b, new_node)\n            if conn_node:\n                candidate = combine_paths(new_node, conn_node, rev_start)\n                cost_cand = 0.0\n                for i in range(len(candidate)-1):\n                    cost_cand += math.dist(candidate[i], candidate[i+1])\n                if cost_cand + 1e-11 < best_cost:\n                    best_cost = cost_cand\n                    best_path = candidate\n                    found = True\n                    no_improve = 0\n                    prune_tree(start_tree, start_grid, best_cost*self.prune_factor)\n                    prune_tree(goal_tree, goal_grid, best_cost*self.prune_factor)\n                else:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n            else:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n\n            if found and no_improve >= self.no_improve_limit:\n                break\n\n        if found and len(best_path) > 3:\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n                best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found, path=best_path,\n                             nodes=start_tree+goal_tree,\n                             edges=[])",
        "objective": -11.31881,
        "time_improvement": -13.0,
        "length_improvement": 24.0,
        "smoothness_improvement": 215.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.047393965721130374,
                "num_nodes_avg": 134.6,
                "path_length_avg": 146.99009020142267,
                "smoothness_avg": 0.013619690044331782,
                "success_improvement": 0.0,
                "time_improvement": -95.15386239022978,
                "length_improvement": 19.43240235356819,
                "smoothness_improvement": 113.17772482409802,
                "objective_score": -16.32082868080753
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.058544158935546875,
                "num_nodes_avg": 352.1,
                "path_length_avg": 219.06274328066283,
                "smoothness_avg": 0.0147639358316728,
                "success_improvement": 0.0,
                "time_improvement": 63.741948134944124,
                "length_improvement": 26.87055092146022,
                "smoothness_improvement": 279.88670298208984,
                "objective_score": 36.64434850826982
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.05396511554718018,
                "num_nodes_avg": 434.3,
                "path_length_avg": 112.77420988956904,
                "smoothness_avg": 0.027750346540338443,
                "success_improvement": 0.0,
                "time_improvement": -8.974795984689827,
                "length_improvement": 25.10073952214698,
                "smoothness_improvement": 252.9823596755917,
                "objective_score": 13.632916716259198
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "A bidirectional RRT* planner with fixed-radius neighbor search to improve local rewiring consistency, strict cost-based parent selection minimizing path length, balanced sampling between uniform, goal, and informed sampling to avoid local minima and accelerate convergence, early termination upon stagnation to reduce planning time, incremental rewiring with efficient collision checks, and extended multi-pass shortcutting and smoothing for shorter, smoother paths. This approach avoids aggressive pruning and dynamic radius shrinking, promoting globally optimized shorter paths with improved planning efficiency.",
        "planning_mechanism": "A bidirectional RRT* planner alternates growth between start and goal trees using a fixed neighbor radius for stable connectivity. Parent selection chooses minimal cost neighbors within radius ensuring locally optimal attachments. Sampling combines uniform, goal bias, and ellipsoidal informed samples after initial solution for balanced exploration and exploitation. Rewiring propagates cost improvements, and early stop occurs on stagnation. Post-planning applies multiple shortcutting and smoothing passes to produce short, smooth paths efficiently.",
        "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=2500,\n                 step_size=5.0,\n                 neighbor_radius=15.0,\n                 time_limit=10.0,\n                 no_improve_limit=30,\n                 shortcut_passes=6,\n                 shortcut_attempts=500,\n                 uniform_sample_prob=0.2,\n                 goal_sample_prob=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_prob = uniform_sample_prob\n        self.goal_sample_prob = goal_sample_prob\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,) * (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a,b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(3, int(dist_ab / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d]) * i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            r = self.step_size / dist\n            return tuple(frm[d] + (to[d]-frm[d])*r for d in range(dim))\n\n        class SpatialGrid:\n            __slots__ = ('cell_size','dim','grid')\n            def __init__(self,bounds,cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self,pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self,node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self,node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self,pos,radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                candidates = []\n                rng = range(-cr,cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx, base[1]+dy)\n                            if cell in self.grid:\n                                candidates.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for n in candidates:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        diff = n.position[d] - pos[d]\n                        dist_sq += diff*diff\n                        if dist_sq > r2:\n                            break\n                    else:\n                        filtered.append(n)\n                return filtered\n            def nearest(self,pos):\n                base = self._hash(pos)\n                rng_lim = 10\n                search_r = 0\n                cand = []\n                while not cand and search_r <= rng_lim:\n                    rng = range(-search_r,search_r+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    cand.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        cand.extend(self.grid[cell])\n                    search_r += 1\n                if not cand:\n                    return None\n                nearest_node = min(cand, key=lambda n: math.dist(n.position,pos))\n                return nearest_node\n\n        def sample_uniform():\n            for _ in range(30):\n                p = tuple(random.uniform(0.0,bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0.0,bounds[d]) for d in range(dim))\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-14:\n                return sample_uniform()\n            center = tuple((start_pos[d]+goal_pos[d])*0.5 for d in range(dim))\n            dvec = [(goal_pos[d]-start_pos[d]) / c_min for d in range(dim)]\n            basis = [dvec]\n            for i in range(1,dim):\n                v = [0.0]*dim\n                v[i] = 1.0\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j]-proj*b[j] for j in range(dim)]\n                normv = math.sqrt(sum(x*x for x in v))\n                basis.append([x/normv if normv>1e-14 else 0.0 for x in v])\n            r_long = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r_short = math.sqrt(max(0.0,val))*0.5 if dim>1 else 0.0\n            radii = [r_long] + [r_short]*(dim-1)\n            for _ in range(40):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                unit_x = [x / norm_x for x in x_ball]\n                u = random.random()**(1/dim)\n                scaled = [radii[i]*unit_x[i]*u for i in range(dim)]\n                sample = [center[d] + sum(basis[i][d]*scaled[i] for i in range(dim)) for d in range(dim)]\n                sample = tuple(max(0.0,min(bounds[d], sample[d])) for d in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def choose_parent(nodes, grid, pos, radius):\n            neighbors = grid.query_radius(pos, radius)\n            good_neighbors = []\n            for nb in neighbors:\n                if in_obstacle(pos) or edge_in_obstacle(nb.position, pos):\n                    continue\n                good_neighbors.append(nb)\n            if not good_neighbors:\n                nearest = grid.nearest(pos)\n                if nearest is None or in_obstacle(pos) or edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                good_neighbors = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in good_neighbors:\n                c = nb.cost + math.dist(nb.position, pos)\n                if c < best_cost:\n                    best_cost = c\n                    best_parent = nb\n            if best_parent is None:\n                return None, []\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, good_neighbors\n\n        def propagate_costs(node,grid):\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for ch in curr.children[:]:\n                    new_cost = curr.cost + math.dist(curr.position, ch.position)\n                    if new_cost + 1e-12 < ch.cost:\n                        if edge_in_obstacle(curr.position, ch.position):\n                            continue\n                        ch.cost = new_cost\n                        if ch.parent:\n                            ch.parent.remove_child(ch)\n                        curr.add_child(ch)\n                        stack.append(ch)\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb is new_node.parent:\n                    continue\n                dist_ = math.dist(new_node.position, nb.position)\n                new_cost = new_node.cost + dist_\n                if new_cost + 1e-12 >= nb.cost:\n                    continue\n                if edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                if nb.parent is not None:\n                    nb.parent.remove_child(nb)\n                new_node.add_child(nb)\n                nb.cost = new_cost\n                propagate_costs(nb, grid)\n\n        def try_connect(tree_nodes, tree_grid, other_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_grid.nearest(other_node.position)\n            if nearest is None:\n                return None\n            dist_no = math.dist(nearest.position, other_node.position)\n            if dist_no <= self.step_size:\n                if edge_in_obstacle(nearest.position, other_node.position) or in_obstacle(other_node.position):\n                    return None\n                new_node = Node(other_node.position, parent=nearest, cost=nearest.cost + dist_no)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                return new_node\n            current = nearest\n            max_steps = int(math.ceil(dist_no/self.step_size))\n            for _ in range(max_steps):\n                new_pos = steer(current.position, other_node.position)\n                if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                dist_cnp = math.dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=current.cost + dist_cnp)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, other_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, other_node.position) or in_obstacle(other_node.position):\n                        return None\n                    final_node = Node(other_node.position, parent=current, cost=current.cost + math.dist(current.position, other_node.position))\n                    tree_nodes.append(final_node)\n                    tree_grid.insert(final_node)\n                    return final_node\n            return None\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _ in range(self.shortcut_passes):\n                changed = True\n                attempts = 0\n                while changed and attempts < self.shortcut_attempts:\n                    changed = False\n                    attempts += 1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path)-3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1,p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        def smooth_path(path):\n            if len(path) < 4:\n                return list(path)\n            smoothed = list(path)\n            alpha = 0.22\n            for _ in range(20):\n                for i in range(1, len(smoothed)-1):\n                    prev_p, curr_p, next_p = smoothed[i-1], smoothed[i], smoothed[i+1]\n                    cand = tuple(curr_p[d] + alpha*(prev_p[d]+next_p[d]-2*curr_p[d]) for d in range(dim))\n                    cand_clamped = tuple(max(0.0,min(bounds[d], cand[d])) for d in range(dim))\n                    if (not in_obstacle(cand_clamped) and not edge_in_obstacle(smoothed[i-1], cand_clamped)\n                        and not edge_in_obstacle(cand_clamped, smoothed[i+1])):\n                        smoothed[i] = cand_clamped\n            return smoothed\n\n        def combine_paths(snode, gnode, reverse_start):\n            pstart = snode.path_from_root()\n            pgoal = gnode.path_from_root()\n            if reverse_start:\n                pstart.reverse()\n                return pgoal + pstart[1:]\n            else:\n                pgoal.reverse()\n                return pstart + pgoal[1:]\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialGrid(bounds, self.neighbor_radius*0.75)\n        goal_grid = SpatialGrid(bounds, self.neighbor_radius*0.75)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found = False\n        no_improve = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            # Alternate trees\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n                rev_start = False\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n                rev_start = True\n\n            r = random.random()\n            if r < self.goal_sample_prob:\n                sample_pt = sample_goal()\n            elif found and r < self.goal_sample_prob + (1 - self.goal_sample_prob - self.uniform_sample_prob):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid_a.nearest(sample_pt)\n            if nearest is None:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            new_node, neighbors = choose_parent(tree_a, grid_a, new_pos, self.neighbor_radius)\n            if new_node is None:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid_a)\n\n            conn_node = try_connect(tree_b, grid_b, new_node)\n            if conn_node:\n                candidate = combine_paths(new_node, conn_node, rev_start)\n                cost_cand = 0.0\n                for i in range(len(candidate)-1):\n                    cost_cand += math.dist(candidate[i], candidate[i+1])\n                if cost_cand + 1e-11 < best_cost:\n                    best_cost = cost_cand\n                    best_path = candidate\n                    found = True\n                    no_improve = 0\n                else:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n            else:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n\n            if found and no_improve >= self.no_improve_limit:\n                break\n\n        if found and len(best_path) > 3:\n            for _ in range(4):\n                best_path = shortcut_path(best_path)\n                best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found, path=best_path, nodes=start_tree+goal_tree, edges=[])",
        "objective": 15.07987,
        "time_improvement": -108.0,
        "length_improvement": 23.0,
        "smoothness_improvement": 711.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.08491573333740235,
                "num_nodes_avg": 147.6,
                "path_length_avg": 146.67545264996258,
                "smoothness_avg": 0.02461913743788308,
                "success_improvement": 0.0,
                "time_improvement": -249.657030939373,
                "length_improvement": 19.60486018127452,
                "smoothness_improvement": 285.34296221549454,
                "objective_score": -61.707478361969706
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.0883143663406372,
                "num_nodes_avg": 289.0,
                "path_length_avg": 223.23869095650394,
                "smoothness_avg": 0.04821963224132819,
                "success_improvement": 0.0,
                "time_improvement": 45.30441749562633,
                "length_improvement": 25.47649938927517,
                "smoothness_improvement": 1140.7258687666322,
                "objective_score": 34.58085422608617
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.10864276885986328,
                "num_nodes_avg": 328.8,
                "path_length_avg": 115.00662291698129,
                "smoothness_avg": 0.06340760577908858,
                "success_improvement": 0.0,
                "time_improvement": -119.38845959413591,
                "length_improvement": 23.618077085424666,
                "smoothness_improvement": 706.5400652473944,
                "objective_score": -18.112991300748998
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "An Enhanced Bidirectional Curvature-Aware Informed RRT* Planner with Efficient Spatial Hashing, Cost-Driven Adaptive Rewiring, Strategic Node Pruning, and Integrated Multi-Stage Shortcutting and Progressive Smoothing applied both intermittently during planning and in post-processing to deliver superior path length minimization, smoothness, and computational efficiency. The planner dynamically adjusts its sampling domain and rewiring radius based on the current best cost, leverages curvature penalties consistently in cost updates and rewiring decisions for smooth transitions, accelerates neighbor searches via spatial hashing, purges suboptimal nodes to keep trees lean, and continuously improves solution quality through phased shortcutting and smoothing passes. It alternately grows two trees from start and goal, attempts connection by incrementally approaching sampled points, and aggressively prunes and optimizes to converge rapidly to shorter, smoother collision-free paths within a time budget.",
        "planning_mechanism": "This planner implements a bidirectional RRT* with informed and adaptive sampling that focuses search regions to ellipsoidal domains based on the best path length found so far. A spatial hash accelerates neighbor queries allowing adaptive rewiring with curvature penalties consistently incorporated into cost evaluations. It prunes subtrees exceeding acceptable cost thresholds to bound computational load. Connections between start and goal trees are incrementally built and rewired. Multi-stage shortcutting and curvature-guided smoothing are performed not only after planning but also intermittently during planning iterations, yielding progressively shorter and smoother paths. Early stopping occurs on stagnation of improvements.",
        "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=4500,\n                 step_size=5.0,\n                 base_radius=18.0,\n                 min_radius=5.0,\n                 time_limit=15.0,\n                 no_improve_limit=60,\n                 shortcut_passes=6,\n                 shortcut_attempts=500,\n                 uniform_sample_prob=0.07,\n                 goal_sample_prob=0.09,\n                 grid_cell_size=14.0,\n                 curvature_w=0.075,\n                 max_curvature_increase=0.11,\n                 prune_cost_factor=1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_prob = uniform_sample_prob\n        self.goal_sample_prob = goal_sample_prob\n        self.grid_cell_size = grid_cell_size\n        self.curvature_w = curvature_w\n        self.max_curvature_increase = max_curvature_increase\n        self.prune_cost_factor = prune_cost_factor\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,) * (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a,b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(3, int(dist_ab / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d])*i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            r = self.step_size / dist\n            return tuple(frm[d] + (to[d] - frm[d]) * r for d in range(dim))\n\n        def curvature_penalty(p_parent, p_curr, p_new):\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_curr[d] - p_parent[d] for d in range(dim))\n            v2 = tuple(p_new[d] - p_curr[d] for d in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[d]*v2[d] for d in range(dim)) / (len1 * len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        class SpatialGrid:\n            __slots__ = ('cell_size', 'dim', 'grid')\n            def __init__(self, bounds, cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self, pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self, node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self, node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self, pos, radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                result = []\n                rng = range(-cr, cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx, base[1]+dy)\n                            if cell in self.grid:\n                                result.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                if cell in self.grid:\n                                    result.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for node in result:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        diff = node.position[d] - pos[d]\n                        dist_sq += diff*diff\n                        if dist_sq > r2:\n                            break\n                    else:\n                        filtered.append(node)\n                return filtered\n            def nearest(self, pos):\n                base = self._hash(pos)\n                search_range = 0\n                candidates = []\n                max_search = 8\n                while not candidates and search_range <= max_search:\n                    rng = range(-search_range, search_range+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        candidates.extend(self.grid[cell])\n                    search_range += 1\n                if not candidates:\n                    return None\n                nearest_node = min(candidates, key=lambda n: math.dist(n.position,pos))\n                return nearest_node\n\n        # Sampling:\n        def sample_uniform():\n            for _ in range(30):\n                p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start_pos[d]+goal_pos[d])*0.5 for d in range(dim))\n            dvec = [(goal_pos[d]-start_pos[d]) / c_min for d in range(dim)]\n            basis = [dvec]\n            for i in range(1, dim):\n                v = [0.0]*dim\n                v[i] = 1.0\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j] - proj*b[j] for j in range(dim)]\n                normv = math.sqrt(sum(x*x for x in v))\n                if normv > 1e-14:\n                    basis.append([x/normv for x in v])\n                else:\n                    basis.append([0.0]*dim)\n            r_long = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r_short = math.sqrt(max(0.0,val)) * 0.5 if dim > 1 else 0.0\n            radii = [r_long] + [r_short]*(dim-1)\n            for _ in range(40):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                unit_x = [x / norm_x for x in x_ball]\n                u = random.random()**(1/dim)\n                scaled = [radii[i]*unit_x[i]*u for i in range(dim)]\n                sample = [center[d] + sum(basis[i][d]*scaled[i] for i in range(dim)) for d in range(dim)]\n                sample = tuple(max(0.0, min(bounds[d], sample[d])) for d in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def adaptive_radius(n_nodes, c_best):\n            if n_nodes < 2:\n                return self.base_radius\n            val = self.base_radius * (math.log(n_nodes+1) / (n_nodes+1))**(1/dim)\n            radius = max(self.min_radius, min(val, self.base_radius))\n            if c_best == float('inf'):\n                return radius\n            shrink_factor = c_best / (math.dist(start_pos, goal_pos) * 2.6)\n            return max(self.min_radius, radius * max(0.35, shrink_factor))\n\n        def choose_parent(nodes, grid, pos, radius, c_best):\n            if in_obstacle(pos):\n                return None, []\n            neighbors = grid.query_radius(pos, radius)\n            candidates = []\n            for nb in neighbors:\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                candidates.append(nb)\n            if not candidates:\n                nearest = grid.nearest(pos)\n                if nearest is None or edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                candidates = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in candidates:\n                dist_nb_to_pos = math.dist(nb.position, pos)\n                c = nb.cost + dist_nb_to_pos\n                curv = curvature_penalty(nb.parent.position if nb.parent else None, nb.position, pos)\n                score = c + self.curvature_w * curv\n                if score < best_cost:\n                    best_cost = score\n                    best_parent = nb\n            if best_parent is None:\n                return None, []\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, candidates\n\n        def propagate_costs(root):\n            # Propagate improved cost downstream through BFS\n            queue = [root]\n            while queue:\n                curr = queue.pop(0)\n                for ch in curr.children[:]:\n                    dist = math.dist(curr.position, ch.position)\n                    new_cost = curr.cost + dist\n                    curv = curvature_penalty(curr.parent.position if curr.parent else None, curr.position, ch.position)\n                    new_score = new_cost + self.curvature_w * curv\n                    old_curv = 0.0\n                    if ch.parent:\n                        grandp = ch.parent.parent if ch.parent.parent else None\n                        old_curv = curvature_penalty(grandp.position if grandp else None, ch.parent.position if ch.parent else None, ch.position)\n                    old_score = ch.cost + self.curvature_w * old_curv\n                    if new_score + 1e-10 < old_score:\n                        if edge_in_obstacle(curr.position, ch.position):\n                            continue\n                        ch.cost = new_cost\n                        if ch.parent is not None:\n                            ch.parent.remove_child(ch)\n                        curr.add_child(ch)\n                        queue.append(ch)\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb == new_node.parent:\n                    continue\n                dist_new_nb = math.dist(new_node.position, nb.position)\n                new_cost = new_node.cost + dist_new_nb\n                if new_cost + 1e-12 >= nb.cost:\n                    continue\n                if edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, nb.position)\n                grandp_nb = nb.parent.parent if nb.parent and nb.parent.parent else None\n                curv_old = curvature_penalty(grandp_nb.position if grandp_nb else None,\n                                            nb.parent.position if nb.parent else None, nb.position)\n                if self.curvature_w * curv_new > self.curvature_w * curv_old + self.max_curvature_increase:\n                    continue\n                if nb.parent is not None:\n                    nb.parent.remove_child(nb)\n                new_node.add_child(nb)\n                nb.cost = new_cost\n                propagate_costs(nb)\n\n        def try_connect(tree_nodes, tree_grid, other_node):\n            if not tree_nodes:\n                return None\n            nearest = tree_grid.nearest(other_node.position)\n            if nearest is None:\n                return None\n            dist_n_o = math.dist(nearest.position, other_node.position)\n            if dist_n_o <= self.step_size:\n                if edge_in_obstacle(nearest.position, other_node.position) or in_obstacle(other_node.position):\n                    return None\n                new_node = Node(other_node.position, parent=nearest, cost=nearest.cost+dist_n_o)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                return new_node\n            current = nearest\n            max_steps = int(math.ceil(dist_n_o / self.step_size))\n            for _ in range(max_steps):\n                new_pos = steer(current.position, other_node.position)\n                if (not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos)):\n                    return None\n                dist_c_np = math.dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=current.cost+dist_c_np)\n                tree_nodes.append(new_node)\n                tree_grid.insert(new_node)\n                current = new_node\n                if math.dist(current.position, other_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, other_node.position) or in_obstacle(other_node.position):\n                        return None\n                    final_node = Node(other_node.position, parent=current, cost=current.cost + math.dist(current.position, other_node.position))\n                    tree_nodes.append(final_node)\n                    tree_grid.insert(final_node)\n                    return final_node\n            return None\n\n        def prune_tree(nodes, grid, cost_limit):\n            to_remove = []\n            for n in nodes:\n                if n.cost > cost_limit:\n                    to_remove.append(n)\n            for n in to_remove:\n                if n.parent:\n                    n.parent.remove_child(n)\n                grid.remove(n)\n                if n in nodes:\n                    nodes.remove(n)\n            return len(to_remove)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _ in range(self.shortcut_passes):\n                attempts = 0\n                changed = True\n                while changed and attempts < self.shortcut_attempts:\n                    changed = False\n                    attempts += 1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path)-3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1, p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        def smooth_path(path, passes=9, alpha=0.16):\n            if len(path) < 4:\n                return list(path)\n            smoothed = list(path)\n            for _ in range(passes):\n                for i in range(1, len(smoothed)-1):\n                    prev_p, curr_p, next_p = smoothed[i-1], smoothed[i], smoothed[i+1]\n                    new_pt = tuple(curr_p[d] + alpha*(prev_p[d] + next_p[d] - 2*curr_p[d]) for d in range(dim))\n                    new_pt = tuple(max(0.0, min(bounds[d], new_pt[d])) for d in range(dim))\n                    if (not in_obstacle(new_pt) and not edge_in_obstacle(smoothed[i-1], new_pt) and not edge_in_obstacle(new_pt, smoothed[i+1])):\n                        smoothed[i] = new_pt\n            return smoothed\n\n        def combine_paths(start_node, goal_node, reverse_start):\n            path_start = start_node.path_from_root()\n            path_goal = goal_node.path_from_root()\n            if reverse_start:\n                path_start.reverse()\n                full = path_goal + path_start[1:]\n            else:\n                path_goal.reverse()\n                full = path_start + path_goal[1:]\n            return full\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        start_grid = SpatialGrid(bounds, self.grid_cell_size)\n        goal_grid = SpatialGrid(bounds, self.grid_cell_size)\n        start_grid.insert(start_root)\n        goal_grid.insert(goal_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found_solution = False\n        no_improve_count = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            if it % 2 == 0:\n                tree_a, grid_a, tree_b, grid_b = start_tree, start_grid, goal_tree, goal_grid\n                reverse_start = False\n            else:\n                tree_a, grid_a, tree_b, grid_b = goal_tree, goal_grid, start_tree, start_grid\n                reverse_start = True\n\n            r = random.random()\n            if r < self.goal_sample_prob:\n                sample_pt = sample_goal()\n            elif found_solution and r < self.goal_sample_prob + (1 - self.goal_sample_prob - self.uniform_sample_prob):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid_a.nearest(sample_pt)\n            if nearest is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if (not in_bounds(new_pos)\n                or in_obstacle(new_pos)\n                or edge_in_obstacle(nearest.position, new_pos)):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            radius = adaptive_radius(len(tree_a), best_cost)\n            new_node, neighbors = choose_parent(tree_a, grid_a, new_pos, radius, best_cost)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid_a)\n\n            connect_node = try_connect(tree_b, grid_b, new_node)\n            if connect_node is not None:\n                candidate_path = combine_paths(new_node, connect_node, reverse_start)\n                total_dist = 0.0\n                for i in range(len(candidate_path)-1):\n                    total_dist += math.dist(candidate_path[i], candidate_path[i+1])\n                if total_dist + 1e-12 < best_cost:\n                    best_cost = total_dist\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                    # Aggressive pruning with tighter cost limit to keep tree focused\n                    prune_limit = best_cost * self.prune_cost_factor\n                    prune_tree(start_tree, start_grid, prune_limit)\n                    prune_tree(goal_tree, goal_grid, prune_limit)\n                    # Intermittent shortcut & smoothing to improve path progressively during planning\n                    if len(best_path) > 3 and it % 300 == 0:\n                        best_path = shortcut_path(best_path)\n                        best_path = smooth_path(best_path, passes=6, alpha=0.14)\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n        if found_solution and len(best_path) > 3:\n            for _ in range(3):\n                best_path = shortcut_path(best_path)\n                best_path = smooth_path(best_path, passes=12, alpha=0.15)\n\n        return PlannerResult(success=found_solution, path=best_path,\n                             nodes=start_tree + goal_tree,\n                             edges=[])",
        "objective": -4.10729,
        "time_improvement": -38.0,
        "length_improvement": 23.0,
        "smoothness_improvement": 319.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.053756332397460936,
                "num_nodes_avg": 188.1,
                "path_length_avg": 152.38513704254513,
                "smoothness_avg": 0.016298340276333628,
                "success_improvement": 0.0,
                "time_improvement": -121.35214337255364,
                "length_improvement": 16.475291689961022,
                "smoothness_improvement": 155.10441773700654,
                "objective_score": -25.74494590910444
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.04884722232818604,
                "num_nodes_avg": 359.3,
                "path_length_avg": 218.89731647139757,
                "smoothness_avg": 0.022614113916076473,
                "success_improvement": 0.0,
                "time_improvement": 69.74753497459669,
                "length_improvement": 26.925775151939664,
                "smoothness_improvement": 481.8774393485239,
                "objective_score": 39.489112780285424
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.07991161346435546,
                "num_nodes_avg": 499.3,
                "path_length_avg": 111.93431610469949,
                "smoothness_avg": 0.03291795103995011,
                "success_improvement": 0.0,
                "time_improvement": -61.37001998026046,
                "length_improvement": 25.658556982613113,
                "smoothness_improvement": 318.713907477765,
                "objective_score": -1.4223022671214454
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "e2",
        "algorithm_description": "An improved bidirectional RRT* planner that consolidates a stable fixed-radius neighborhood for efficient rewiring, cost-focused parent selection, balanced sampling combining ellipsoidal informed and uniform strategies, and early stopping on stagnation. The planner incrementally grows two trees alternately, rewires neighbors to improve global path optimality, and attempts connecting trees with incremental steering. It performs extensive multi-pass shortcutting smoothing for better path length and smoothness while carefully managing collision checks and pruning during planning for robustness and speed.",
        "planning_mechanism": "A bidirectional incremental RRT* planner with fixed-radius neighbors enabling effective rewiring combined with ellipsoidal plus uniform sampling. It chooses parents to minimize cost, rewires neighbors for global path improvement, incrementally attempts tree connections, and applies extensive shortcut smoothing after early stopping on stagnation for efficient search, shorter, and smoother paths.",
        "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=3500, step_size=5.0, neighbor_radius=18.0,\n                 no_improve_limit=50, shortcut_passes=5, shortcut_iter=250):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_iter = shortcut_iter\n\n    def plan(self, map):\n        import math\n        import random\n\n        start = tuple(map.start)\n        goal = tuple(map.goal)\n        bounds = tuple(map.size)\n        obstacles = map.obstacles\n        dim = len(bounds)\n        dist = lambda a, b: math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0, 0, 0))[:3]\n            for obs in obstacles:\n                if dim == 3:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh and oz <= pz <= oz + od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox + ow and oy <= py <= oy + oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, resolution=1.0):\n            length = dist(a, b)\n            if length < 1e-12:\n                return False\n            steps = max(2, int(length / resolution))\n            for i in range(steps + 1):\n                pt = tuple(a[d] + (b[d] - a[d]) * i / steps for d in range(dim))\n                if in_obstacle(pt):\n                    return True\n            return False\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + (to[i] - frm[i]) * ratio for i in range(dim))\n\n        def neighbors(tree, point, radius):\n            r_sq = radius * radius\n            res = []\n            for n in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = n.position[i] - point[i]\n                    d_sq += diff * diff\n                    if d_sq > r_sq:\n                        break\n                else:\n                    res.append(n)\n            return res\n\n        def choose_parent(tree, new_pos):\n            nbrs = neighbors(tree, new_pos, self.neighbor_radius)\n            valid_parents = []\n            for candidate in nbrs:\n                if not edge_in_obstacle(candidate.position, new_pos):\n                    valid_parents.append(candidate)\n            if not valid_parents:\n                # fallback nearest neighbor with edge check\n                nearest = None\n                nearest_dist = float('inf')\n                for n in tree:\n                    d = dist(n.position, new_pos)\n                    if d < nearest_dist and not edge_in_obstacle(n.position, new_pos):\n                        nearest = n\n                        nearest_dist = d\n                if nearest is None or in_obstacle(new_pos):\n                    return None, []\n                cost = nearest.cost + nearest_dist\n                new_node = Node(new_pos, parent=nearest, cost=cost)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node, []\n            # choose parent minimizing cost + dist (cost-to-come)\n            best_parent = min(valid_parents, key=lambda p: p.cost + dist(p.position, new_pos))\n            min_cost = best_parent.cost + dist(best_parent.position, new_pos)\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            return new_node, valid_parents\n\n        def rewire(pivot, nbrs):\n            for nb in nbrs:\n                if nb is pivot.parent:\n                    continue\n                dist_p_nb = dist(pivot.position, nb.position)\n                new_cost = pivot.cost + dist_p_nb\n                if new_cost + 1e-12 < nb.cost and not edge_in_obstacle(pivot.position, nb.position):\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    pivot.add_child(nb)\n                    nb.cost = new_cost\n\n        def attempt_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest = None\n            nearest_dist = float('inf')\n            for n in tree:\n                d = dist(n.position, target_node.position)\n                if d < nearest_dist:\n                    nearest = n\n                    nearest_dist = d\n            if nearest is None:\n                return None\n            if nearest_dist <= self.step_size:\n                if edge_in_obstacle(nearest.position, target_node.position) or in_obstacle(target_node.position):\n                    return None\n                new_node = Node(target_node.position, parent=nearest, cost=nearest.cost + nearest_dist)\n                nearest.add_child(new_node)\n                tree.append(new_node)\n                return new_node\n            # incremental steering with multiple steps\n            current = nearest\n            steps = int(math.ceil(nearest_dist / self.step_size))\n            for _ in range(steps):\n                new_pos = steer(current.position, target_node.position)\n                if (not in_bounds(new_pos)) or in_obstacle(new_pos) or edge_in_obstacle(current.position, new_pos):\n                    return None\n                new_node = Node(new_pos, parent=current, cost=current.cost + dist(current.position, new_pos))\n                current.add_child(new_node)\n                tree.append(new_node)\n                current = new_node\n                if dist(current.position, target_node.position) <= self.step_size:\n                    if edge_in_obstacle(current.position, target_node.position) or in_obstacle(target_node.position):\n                        return None\n                    final_node = Node(target_node.position, parent=current, cost=current.cost + dist(current.position, target_node.position))\n                    current.add_child(final_node)\n                    tree.append(final_node)\n                    return final_node\n            return None\n\n        def sample_uniform():\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def ellipsoid_sample(c_best, c_min):\n            if c_best == float('inf') or c_min < 1e-12:\n                return sample_uniform()\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            a1 = [goal[d] - start[d] for d in range(dim)]\n            norm_a1 = math.sqrt(sum(x * x for x in a1))\n            if norm_a1 < 1e-15:\n                return sample_uniform()\n            unit_a1 = [x / norm_a1 for x in a1]\n\n            # generate orthonormal basis\n            basis = [unit_a1]\n            for idx in range(dim - 1):\n                base = [0.0] * dim\n                base[(idx + 1) % dim] = 1.0\n                for b in basis:\n                    proj = sum(base[j] * b[j] for j in range(dim))\n                    base = [base[j] - proj * b[j] for j in range(dim)]\n                norm_base = math.sqrt(sum(x * x for x in base))\n                if norm_base > 1e-15:\n                    base = [x / norm_base for x in base]\n                else:\n                    base = [0.0] * dim\n                basis.append(base)\n\n            r1 = c_best * 0.5\n            val = c_best * c_best - c_min * c_min\n            r_orth = math.sqrt(val) * 0.5 if val > 0 else 0.0\n            radii = [r1] + [r_orth] * (dim - 1)\n\n            for _ in range(50):\n                x_ball = [random.gauss(0., 1.) for _ in range(dim)]\n                norm_ball = math.sqrt(sum(x * x for x in x_ball))\n                if norm_ball < 1e-15:\n                    continue\n                unit_ball = [xx / norm_ball for xx in x_ball]\n                u = random.random() ** (1.0 / dim)\n                point_ball = [coord * u for coord in unit_ball]\n                mapped = [0.0] * dim\n                for i_ in range(dim):\n                    for j_ in range(dim):\n                        mapped[j_] += point_ball[i_] * radii[i_] * basis[i_][j_]\n                sample = tuple(min(max(center[i] + mapped[i], 0.0), bounds[i]) for i in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _pass in range(self.shortcut_passes):\n                for _ in range(self.shortcut_iter):\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path) - 3)\n                    j = random.randint(i + 2, len(path) - 1)\n                    if not edge_in_obstacle(path[i], path[j]):\n                        path = path[:i + 1] + path[j:]\n            return path\n\n        start_node = Node(start, cost=0.0)\n        goal_node = Node(goal, cost=0.0)\n        start_tree = [start_node]\n        goal_tree = [goal_node]\n        nodes = [start_node, goal_node]\n        edges = []\n\n        best_path = []\n        best_cost = float('inf')\n        c_min = dist(start, goal)\n        found_solution = False\n        no_improve_count = 0\n\n        for iter_i in range(self.max_iter):\n            # Balanced sampling: mostly ellipsoidal after first path found, occasional uniform for exploration\n            if found_solution:\n                if random.random() < 0.7:\n                    sample = ellipsoid_sample(best_cost, c_min)\n                else:\n                    sample = sample_uniform()\n            else:\n                sample = sample_uniform()\n\n            if not in_bounds(sample) or in_obstacle(sample):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            # Alternate growth of trees each iteration\n            if iter_i % 2 == 0:\n                tree_a, tree_b = start_tree, goal_tree\n            else:\n                tree_a, tree_b = goal_tree, start_tree\n\n            nearest_node = min(tree_a, key=lambda n: dist(n.position, sample))\n            new_pos = steer(nearest_node.position, sample)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            new_node, nbrs = choose_parent(tree_a, new_pos)\n            if new_node is None:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, nbrs)\n            nodes.append(new_node)\n            if new_node.parent:\n                edges.append((new_node.parent, new_node))\n\n            connect_node = attempt_connect(tree_b, new_node)\n            if connect_node:\n                # Reconstruct candidate path from connected trees\n                if iter_i % 2 == 0:\n                    path_a = new_node.path_from_root()\n                    path_b = connect_node.path_from_root()\n                else:\n                    path_a = connect_node.path_from_root()\n                    path_b = new_node.path_from_root()\n\n                # Merge paths handling last node duplication\n                if path_a and path_b and path_a[-1] == path_b[-1]:\n                    candidate_path = path_a + path_b[-2::-1]\n                else:\n                    candidate_path = path_a + path_b[::-1]\n\n                total_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    total_cost += dist(candidate_path[i], candidate_path[i + 1])\n\n                if total_cost + 1e-9 < best_cost:\n                    best_cost = total_cost\n                    best_path = candidate_path\n                    found_solution = True\n                    no_improve_count = 0\n                else:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n            else:\n                if found_solution:\n                    no_improve_count += 1\n                    if no_improve_count >= self.no_improve_limit:\n                        break\n\n        if found_solution and len(best_path) >= 3:\n            best_path = shortcut_path(best_path)\n\n        return PlannerResult(success=found_solution, path=best_path, nodes=nodes, edges=edges)",
        "objective": 15.41941,
        "time_improvement": -114.0,
        "length_improvement": 20.0,
        "smoothness_improvement": 1377.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.0893782377243042,
                "num_nodes_avg": 95.8,
                "path_length_avg": 154.6273697275617,
                "smoothness_avg": 0.04224056137084624,
                "success_improvement": 0.0,
                "time_improvement": -268.0322598063037,
                "length_improvement": 15.246288424852844,
                "smoothness_improvement": 561.1565123008995,
                "objective_score": -68.45612232547491
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.10737013816833496,
                "num_nodes_avg": 259.3,
                "path_length_avg": 230.33873264271023,
                "smoothness_avg": 0.0936642703995312,
                "success_improvement": 0.0,
                "time_improvement": 33.502639558770205,
                "length_improvement": 23.10630111105081,
                "smoothness_improvement": 2310.049141027005,
                "objective_score": 35.46481823939657
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.10335655212402343,
                "num_nodes_avg": 219.9,
                "path_length_avg": 117.82108603857912,
                "smoothness_avg": 0.10688549782159049,
                "success_improvement": 0.0,
                "time_improvement": -108.71370453287112,
                "length_improvement": 21.74884469039136,
                "smoothness_improvement": 1259.5756428238533,
                "objective_score": -13.266926331507253
            }
        ],
        "success_rate": 1.0
    },
    {
        "operator": "path_expert",
        "algorithm_description": "A unidirectional RRT* planner enhanced with adaptive fixed-radius rewiring, a balanced sampling approach mixing uniform, goal bias, and modest informed ellipsoidal samples for focused exploration that improves path length; spatial grid indexing supports efficient neighbor queries; parent selection prioritizes minimal combined cost with a soft curvature penalty to avoid excessive path length degradation; multi-pass adaptive shortcutting and smoothing improve smoothness and length; pruning rejects nodes exceeding the best cost times a factor, controlling tree size and speeding processing; early stopping occurs upon stagnation to limit runtimes.",
        "planning_mechanism": "A unidirectional RRT* planner grows a tree from start towards goal, using an efficient spatial grid to query neighbors; sampling combines uniform, goal, and ellipsoidal informed strategies adaptively once a solution exists to improve path quality and planning speed; new nodes connect to the locally optimal parent minimizing path length plus a mild curvature penalty; rewiring adjusts nearby nodes if beneficial; path pruning and multi-pass shortcut/smooth operations iteratively refine final path length and smoothness; planning stops early if no improvements are found over several iterations.",
        "code": "class Node:\n    __slots__ = ('position', 'parent', 'cost', 'children')\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        if parent is not None:\n            parent.children.append(self)\n    def add_child(self, child):\n        if child not in self.children:\n            self.children.append(child)\n            child.parent = self\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n    def path_from_root(self):\n        p = []\n        n = self\n        while n:\n            p.append(n.position)\n            n = n.parent\n        return p[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter=3500,\n                 step_size=5.0,\n                 base_radius=25.0,\n                 min_radius=4.0,\n                 time_limit=9.0,\n                 no_improve_limit=35,\n                 shortcut_passes=5,\n                 shortcut_attempts=600,\n                 uniform_sample_prob=0.15,\n                 goal_sample_prob=0.07,\n                 grid_cell_size=14.0,\n                 curvature_w=0.035,\n                 prune_factor=1.4):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius\n        self.min_radius = min_radius\n        self.time_limit = time_limit\n        self.no_improve_limit = no_improve_limit\n        self.shortcut_passes = shortcut_passes\n        self.shortcut_attempts = shortcut_attempts\n        self.uniform_sample_prob = uniform_sample_prob\n        self.goal_sample_prob = goal_sample_prob\n        self.grid_cell_size = grid_cell_size\n        self.curvature_w = curvature_w\n        self.prune_factor = prune_factor\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import time\n\n        bounds = tuple(map.size)\n        dim = len(bounds)\n        start_pos = tuple(map.start)\n        goal_pos = tuple(map.goal)\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(p):\n            px, py, pz = (p + (0,) * (3 - len(p)))[:3]\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh and oz <= pz <= oz+od:\n                        return True\n                else:\n                    ox, oy, ow, oh = obs\n                    if ox <= px <= ox+ow and oy <= py <= oy+oh:\n                        return True\n            return False\n\n        def edge_in_obstacle(a, b, res=1.0):\n            dist_ab = math.dist(a,b)\n            if dist_ab < 1e-12:\n                return False\n            steps = max(3, int(dist_ab / res))\n            for i in range(steps+1):\n                interp = tuple(a[d] + (b[d]-a[d]) * i/steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(frm, to):\n            dist = math.dist(frm, to)\n            if dist <= self.step_size:\n                return to\n            r = self.step_size / dist\n            return tuple(frm[d] + (to[d]-frm[d])*r for d in range(dim))\n\n        def curvature_penalty(p_parent, p_curr, p_new):\n            if p_parent is None:\n                return 0.0\n            v1 = tuple(p_curr[d]-p_parent[d] for d in range(dim))\n            v2 = tuple(p_new[d]-p_curr[d] for d in range(dim))\n            len1 = math.sqrt(sum(x*x for x in v1))\n            len2 = math.sqrt(sum(x*x for x in v2))\n            if len1 < 1e-14 or len2 < 1e-14:\n                return 0.0\n            dot = sum(v1[d]*v2[d] for d in range(dim)) / (len1 * len2)\n            dot = max(-1.0, min(1.0, dot))\n            angle = math.acos(dot)\n            return angle\n\n        class SpatialGrid:\n            __slots__ = ('cell_size','dim','grid')\n            def __init__(self,bounds,cell_size):\n                self.cell_size = cell_size\n                self.dim = len(bounds)\n                self.grid = {}\n            def _hash(self,pos):\n                return tuple(int(pos[d]//self.cell_size) for d in range(self.dim))\n            def insert(self,node):\n                h = self._hash(node.position)\n                if h not in self.grid:\n                    self.grid[h] = []\n                self.grid[h].append(node)\n            def remove(self,node):\n                h = self._hash(node.position)\n                if h in self.grid:\n                    try:\n                        self.grid[h].remove(node)\n                        if not self.grid[h]:\n                            del self.grid[h]\n                    except ValueError:\n                        pass\n            def query_radius(self,pos,radius):\n                cr = int(math.ceil(radius/self.cell_size))\n                base = self._hash(pos)\n                candidates = []\n                rng = range(-cr,cr+1)\n                if self.dim == 2:\n                    for dx in rng:\n                        for dy in rng:\n                            cell = (base[0]+dx, base[1]+dy)\n                            if cell in self.grid:\n                                candidates.extend(self.grid[cell])\n                else:\n                    for dx in rng:\n                        for dy in rng:\n                            for dz in rng:\n                                cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                if cell in self.grid:\n                                    candidates.extend(self.grid[cell])\n                r2 = radius*radius\n                filtered = []\n                for n in candidates:\n                    dist_sq = 0.0\n                    for d in range(self.dim):\n                        diff = n.position[d] - pos[d]\n                        dist_sq += diff*diff\n                        if dist_sq > r2:\n                            break\n                    else:\n                        filtered.append(n)\n                return filtered\n            def nearest(self,pos):\n                base = self._hash(pos)\n                rng_lim = 7\n                search_r = 0\n                cand = []\n                while not cand and search_r <= rng_lim:\n                    rng = range(-search_r,search_r+1)\n                    if self.dim == 2:\n                        for dx in rng:\n                            for dy in rng:\n                                cell = (base[0]+dx, base[1]+dy)\n                                if cell in self.grid:\n                                    cand.extend(self.grid[cell])\n                    else:\n                        for dx in rng:\n                            for dy in rng:\n                                for dz in rng:\n                                    cell = (base[0]+dx, base[1]+dy, base[2]+dz)\n                                    if cell in self.grid:\n                                        cand.extend(self.grid[cell])\n                    search_r += 1\n                if not cand:\n                    return None\n                nearest_node = min(cand, key=lambda n: math.dist(n.position,pos))\n                return nearest_node\n\n        def sample_uniform():\n            for _ in range(15):\n                p = tuple(random.uniform(0.0,bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return tuple(random.uniform(0.0,bounds[d]) for d in range(dim))\n\n        def sample_goal():\n            if not in_obstacle(goal_pos):\n                return goal_pos\n            return sample_uniform()\n\n        def sample_informed(c_best):\n            if c_best == float('inf'):\n                return sample_uniform()\n            c_min = math.dist(start_pos, goal_pos)\n            if c_min < 1e-14:\n                return sample_uniform()\n            center = tuple((start_pos[d]+goal_pos[d])*0.5 for d in range(dim))\n            dvec = [(goal_pos[d]-start_pos[d]) / c_min for d in range(dim)]\n            basis = [dvec]\n            for i in range(1,dim):\n                v = [0.0]*dim\n                v[i] = 1.0\n                for b in basis:\n                    proj = sum(v[j]*b[j] for j in range(dim))\n                    v = [v[j]-proj*b[j] for j in range(dim)]\n                normv = math.sqrt(sum(x*x for x in v))\n                basis.append([x/normv if normv>1e-14 else 0.0 for x in v])\n            r_long = c_best*0.5\n            val = c_best*c_best - c_min*c_min\n            r_short = math.sqrt(max(0.0,val))*0.5 if dim>1 else 0.0\n            radii = [r_long] + [r_short]*(dim-1)\n            for _ in range(25):\n                x_ball = [random.gauss(0,1) for _ in range(dim)]\n                norm_x = math.sqrt(sum(x*x for x in x_ball))\n                if norm_x < 1e-14:\n                    continue\n                unit_x = [x / norm_x for x in x_ball]\n                u = random.random()**(1/dim)\n                scaled = [radii[i]*unit_x[i]*u for i in range(dim)]\n                sample = [center[d] + sum(basis[i][d]*scaled[i] for i in range(dim)) for d in range(dim)]\n                sample = tuple(max(0.0,min(bounds[d], sample[d])) for d in range(dim))\n                if not in_obstacle(sample):\n                    return sample\n            return sample_uniform()\n\n        def neighbor_radius(n_nodes, c_best):\n            if n_nodes < 2:\n                return self.base_radius\n            val = self.base_radius * (math.log(n_nodes+1)/(n_nodes+1))**(1/dim)\n            radius = max(self.min_radius, min(val, self.base_radius))\n            if c_best == float('inf'):\n                return radius\n            shrinkf = c_best / (math.dist(start_pos, goal_pos)*2.4)\n            return max(self.min_radius, radius * max(0.4, shrinkf))\n\n        def choose_parent(nodes, grid, pos, radius, c_best):\n            neighbors = grid.query_radius(pos, radius)\n            good_neighbors = []\n            if in_obstacle(pos):\n                return None, []\n            for nb in neighbors:\n                if edge_in_obstacle(nb.position, pos):\n                    continue\n                good_neighbors.append(nb)\n            if not good_neighbors:\n                nearest = grid.nearest(pos)\n                if nearest is None or edge_in_obstacle(nearest.position, pos):\n                    return None, []\n                good_neighbors = [nearest]\n            best_parent = None\n            best_cost = float('inf')\n            for nb in good_neighbors:\n                dist_ = math.dist(nb.position, pos)\n                c = nb.cost + dist_\n                curv = curvature_penalty(nb.parent.position if nb.parent else None, nb.position, pos)\n                score = c + self.curvature_w*curv\n                if score < best_cost:\n                    best_cost = score\n                    best_parent = nb\n            if best_parent is None:\n                return None, []\n            new_node = Node(pos, parent=best_parent, cost=best_cost)\n            nodes.append(new_node)\n            grid.insert(new_node)\n            return new_node, good_neighbors\n\n        def propagate_costs(node,grid):\n            stack = [node]\n            while stack:\n                curr = stack.pop()\n                for ch in curr.children[:]:\n                    dist_c = math.dist(curr.position, ch.position)\n                    new_cost = curr.cost + dist_c\n                    curv = curvature_penalty(curr.parent.position if curr.parent else None,\n                                             curr.position, ch.position)\n                    new_score = new_cost + self.curvature_w*curv\n                    old_score = ch.cost + (self.curvature_w*curvature_penalty(\n                        ch.parent.parent.position if ch.parent and ch.parent.parent else None,\n                        ch.parent.position if ch.parent else None,\n                        ch.position) if ch.parent else 0)\n                    if new_score + 1e-11 < old_score:\n                        if edge_in_obstacle(curr.position, ch.position):\n                            continue\n                        ch.cost = new_cost\n                        if ch.parent:\n                            ch.parent.remove_child(ch)\n                        curr.add_child(ch)\n                        stack.append(ch)\n\n        def rewire(new_node, neighbors, grid):\n            for nb in neighbors:\n                if nb is new_node.parent:\n                    continue\n                dist_ = math.dist(new_node.position, nb.position)\n                new_cost = new_node.cost + dist_\n                if new_cost + 1e-13 >= nb.cost:\n                    continue\n                if edge_in_obstacle(new_node.position, nb.position):\n                    continue\n                curv_new = curvature_penalty(new_node.parent.position if new_node.parent else None, new_node.position, nb.position)\n                curv_old = curvature_penalty(nb.parent.parent.position if nb.parent and nb.parent.parent else None,\n                                            nb.parent.position if nb.parent else None, nb.position)\n                # Use a softened curvature increase limit to allow slight curvature growth if cost improvement compensates\n                if self.curvature_w*curv_new > self.curvature_w*curv_old + 0.16:\n                    continue\n                if nb.parent is not None:\n                    nb.parent.remove_child(nb)\n                new_node.add_child(nb)\n                nb.cost = new_cost\n                propagate_costs(nb, grid)\n\n        def prune_tree(nodes, grid, cost_limit):\n            to_remove = [n for n in nodes if n.cost > cost_limit]\n            for n in to_remove:\n                if n.parent:\n                    n.parent.remove_child(n)\n                grid.remove(n)\n                if n in nodes:\n                    nodes.remove(n)\n            return len(to_remove)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return list(path)\n            path = list(path)\n            for _ in range(self.shortcut_passes):\n                changed = True\n                attempts = 0\n                while changed and attempts < self.shortcut_attempts:\n                    changed = False\n                    attempts += 1\n                    if len(path) < 3:\n                        break\n                    i = random.randint(0, len(path)-3)\n                    j = random.randint(i+2, len(path)-1)\n                    p1, p2 = path[i], path[j]\n                    if not edge_in_obstacle(p1,p2):\n                        del path[i+1:j]\n                        changed = True\n            return path\n\n        def smooth_path(path):\n            if len(path) < 4:\n                return list(path)\n            smoothed = list(path)\n            alpha = 0.23\n            for _ in range(16):\n                for i in range(1, len(smoothed)-1):\n                    prev_p, curr_p, next_p = smoothed[i-1], smoothed[i], smoothed[i+1]\n                    cand = tuple(curr_p[d] + alpha*(prev_p[d]+next_p[d]-2*curr_p[d]) for d in range(dim))\n                    cand_clamped = tuple(max(0.0,min(bounds[d], cand[d])) for d in range(dim))\n                    if (not in_obstacle(cand_clamped) and not edge_in_obstacle(smoothed[i-1], cand_clamped)\n                        and not edge_in_obstacle(cand_clamped, smoothed[i+1])):\n                        smoothed[i] = cand_clamped\n            return smoothed\n\n        start_root = Node(start_pos, cost=0.0)\n        nodes = [start_root]\n        grid = SpatialGrid(bounds, self.grid_cell_size)\n        grid.insert(start_root)\n\n        best_path = []\n        best_cost = float('inf')\n        found = False\n        no_improve = 0\n        start_time = time.time()\n\n        for it in range(self.max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > self.time_limit:\n                break\n\n            r = random.random()\n            if r < self.goal_sample_prob:\n                sample_pt = sample_goal()\n            elif found and r < self.goal_sample_prob + (1 - self.goal_sample_prob - self.uniform_sample_prob):\n                sample_pt = sample_informed(best_cost)\n            else:\n                sample_pt = sample_uniform()\n\n            if not in_bounds(sample_pt) or in_obstacle(sample_pt):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            nearest = grid.nearest(sample_pt)\n            if nearest is None:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            new_pos = steer(nearest.position, sample_pt)\n            if not in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest.position, new_pos):\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            radius = neighbor_radius(len(nodes), best_cost)\n            new_node, neighbors = choose_parent(nodes, grid, new_pos, radius, best_cost)\n            if new_node is None:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n                continue\n\n            rewire(new_node, neighbors, grid)\n\n            dist_to_goal = math.dist(new_node.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                if not in_obstacle(goal_pos) and not edge_in_obstacle(new_node.position, goal_pos):\n                    goal_node = Node(goal_pos, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    nodes.append(goal_node)\n                    grid.insert(goal_node)\n                    candidate = goal_node.path_from_root()\n                    cost_cand = 0.0\n                    for i in range(len(candidate)-1):\n                        cost_cand += math.dist(candidate[i], candidate[i+1])\n                    if cost_cand + 1e-11 < best_cost:\n                        best_cost = cost_cand\n                        best_path = candidate\n                        found = True\n                        no_improve = 0\n                        prune_tree(nodes, grid, best_cost*self.prune_factor)\n                    else:\n                        no_improve += 1\n                        if no_improve >= self.no_improve_limit:\n                            break\n            else:\n                if found:\n                    no_improve += 1\n                    if no_improve >= self.no_improve_limit:\n                        break\n\n            if found and no_improve >= self.no_improve_limit:\n                break\n\n        if found and len(best_path) > 3:\n            for _ in range(4):\n                best_path = shortcut_path(best_path)\n                best_path = smooth_path(best_path)\n\n        return PlannerResult(success=found, path=best_path,\n                             nodes=nodes,\n                             edges=[])",
        "objective": 44.90054,
        "time_improvement": -198.0,
        "length_improvement": 21.0,
        "smoothness_improvement": 398.0,
        "other_inf": [
            {
                "map_id": 0,
                "success_rate": 1.0,
                "time_avg": 0.09703254699707031,
                "num_nodes_avg": 380.5,
                "path_length_avg": 162.19367118194887,
                "smoothness_avg": 0.02085744552662189,
                "success_improvement": 0.0,
                "time_improvement": -299.5503654507881,
                "length_improvement": 11.099078701984212,
                "smoothness_improvement": 226.46431515952793,
                "objective_score": -82.07334083824826
            },
            {
                "map_id": 1,
                "success_rate": 1.0,
                "time_avg": 0.15577273368835448,
                "num_nodes_avg": 1018.7,
                "path_length_avg": 217.0141910262245,
                "smoothness_avg": 0.022985753750998976,
                "success_improvement": 0.0,
                "time_improvement": 3.525544479134561,
                "length_improvement": 27.554416628299023,
                "smoothness_improvement": 491.4399999824332,
                "objective_score": 20.04751332063195
            },
            {
                "map_id": 2,
                "success_rate": 1.0,
                "time_avg": 0.19692347049713135,
                "num_nodes_avg": 608.2,
                "path_length_avg": 114.8184375738015,
                "smoothness_avg": 0.04522006556651624,
                "success_improvement": 0.0,
                "time_improvement": -297.6586504898775,
                "length_improvement": 23.743060829941594,
                "smoothness_improvement": 475.19589620804805,
                "objective_score": -72.67577916795804
            }
        ],
        "success_rate": 1.0
    }
]