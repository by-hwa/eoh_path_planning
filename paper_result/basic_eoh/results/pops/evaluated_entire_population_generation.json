{
    "operator": "e1",
    "algorithm_description": "This algorithm is a Heuristic-guided Anytime Dynamic RRT* (HADRRT*), combining adaptive heuristic sampling, dynamic rewiring, and anytime path improvement within a time budget. It balances exploration and exploitation using a heuristic cost-to-go estimate to bias sampling towards promising areas, dynamically updates tree connections for shorter paths, and iteratively refines the best path found so far. The planner adheres to a strict maximum execution time, ensuring timely results even in complex environments.",
    "planning_mechanism": "The planner grows a single rapidly-exploring random tree biased towards the goal using heuristic sampling. It dynamically rewires nodes within a neighborhood radius when a lower-cost connection is found, and prunes suboptimal branches. The tree is continuously refined with a goal bias and adaptive sampling radius. The algorithm stops either when a valid path is found or when the 30-second time limit expires, returning the best path discovered by then.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time = 30.0  # seconds timeout\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        goal_node = None\n        best_cost = float('inf')\n        best_path: List[Tuple[float,...]] = []\n\n        # Parameters for adaptive neighborhood radius (RRT* style)\n        gamma_rrt_star = 30.0  # tuning param for rewiring radius\n        volume = 1\n        for b in bounds:\n            volume *= b\n        rewire_radius = min(self.step_size * 15, gamma_rrt_star * ((math.log(1 + self.max_iter) / (1 + len(nodes))) ** (1/dim)))\n\n        time_start = time.time()\n\n        def heuristic(pos):\n            # Euclidean distance to goal \n            return math.dist(pos, goal_pos)\n\n        def random_sample():\n            # Biased sampling with goal bias and informed ellipse sampling\n            goal_bias = 0.1\n            if random.random() < goal_bias:\n                return goal_pos\n            # Informed set ellipse sampling when path found\n            if best_path:\n                c_best = best_cost\n                c_min = heuristic(start_pos)\n                if c_best == float('inf') or c_best <= c_min:\n                    # uniform sample\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                x_center = [(s + g) / 2 for s,g in zip(start_pos, goal_pos)]\n                a1 = [g - s for s,g in zip(start_pos, goal_pos)]\n                norm_a1 = math.dist(start_pos, goal_pos)\n                if norm_a1 == 0:\n                    return goal_pos\n                a1 = [v / norm_a1 for v in a1]\n\n                import numpy as np\n                a1_np = np.array(a1).reshape((dim,1))\n                id_matrix = np.eye(dim)\n                M = a1_np @ id_matrix[0].reshape((1,dim))\n                U, _, Vt = np.linalg.svd(M)\n                det = np.linalg.det(U) * np.linalg.det(Vt)\n                C = U @ np.diag([1]*(dim-1) + [det]) @ Vt\n\n                r1 = c_best/2.0\n                r2 = math.sqrt(c_best**2 - c_min**2)/2.0\n                L = np.diag([r1] + [r2]*(dim-1))\n\n                while True:\n                    x_ball = np.random.normal(0,1,dim)\n                    x_ball /= np.linalg.norm(x_ball)\n                    scale = random.random()**(1/dim)\n                    x_ball *= scale\n                    x_rand = (C @ L @ x_ball) + np.array(x_center)\n                    x_rand_t = tuple(float(x_rand[d]) for d in range(dim))\n                    # Check bounds\n                    if all(0 <= x_rand_t[d] <= bounds[d] for d in range(dim)):\n                        # Check obstacle\n                        if not self._is_in_obstacle(x_rand_t, obstacles, is_3d):\n                            return x_rand_t\n            else:\n                # Uniform random sample\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest_node(pos):\n            return min(nodes, key=lambda n: math.dist(n.position, pos))\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i]) * ratio for i in range(dim))\n\n        def near_nodes(node_new, radius):\n            return [n for n in nodes if math.dist(n.position, node_new.position) <= radius]\n\n        def replace_parent(child: Node, new_parent: Node, cost_new_parent: float):\n            if child.parent:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = cost_new_parent\n            new_parent.add_child(child)\n\n        for iteration in range(self.max_iter):\n            elapsed = time.time() - time_start\n            if elapsed > self.max_time:\n                # Timeout reached, stop and return best path found so far\n                break\n\n            sample_pos = random_sample()\n            nearest = nearest_node(sample_pos)\n            new_pos = steer(nearest.position, sample_pos, self.step_size)\n\n            # Collision checks for position and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n            # Check boundary\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if new_cost >= best_cost:\n                # Prune expansions that can't improve best path\n                # But allow if no path yet\n                if best_cost < float('inf'):\n                    continue\n\n            node_new = Node(new_pos, nearest, new_cost)\n            nearest.add_child(node_new)\n            nodes.append(node_new)\n            edges.append((nearest, node_new))\n\n            # Rewiring near nodes if it reduces cost and collision free\n            radius = min(rewire_radius, self.step_size * (math.log(len(nodes)+1)/ (len(nodes)+1))**(1/dim) * gamma_rrt_star)\n            neighbors = near_nodes(node_new, radius)\n            for near in neighbors:\n                if near == node_new.parent:\n                    continue\n                cost_through_new = node_new.cost + math.dist(node_new.position, near.position)\n                if cost_through_new + heuristic(near.position) >= best_cost:\n                    continue\n                if cost_through_new < near.cost:\n                    # Check edge collision\n                    if self._is_edge_in_obstacle(node_new.position, near.position, obstacles, is_3d):\n                        continue\n                    replace_parent(near, node_new, cost_through_new)\n                    edges.append((node_new, near))\n\n            # Check if new node can connect directly to goal improving cost\n            dist_to_goal = math.dist(node_new.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                # Check goal connection collision\n                if not self._is_edge_in_obstacle(node_new.position, goal_pos, obstacles, is_3d) and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                    total_cost = node_new.cost + dist_to_goal\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        goal_node = Node(goal_pos, node_new, total_cost)\n                        node_new.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((node_new, goal_node))\n                        best_path = goal_node.path_from_root()\n                        success_state = True\n\n            # Periodically prune nodes far from optimal path or high cost\n            if iteration % 100 == 0 and best_path:\n                prune_threshold = best_cost * 1.5\n                removable = []\n                for n in nodes:\n                    if n.cost > prune_threshold:\n                        removable.append(n)\n                for rem in removable:\n                    if rem.parent:\n                        rem.parent.remove_child(rem)\n                    nodes.remove(rem)\n                    # Remove edges linked to rem\n                    edges[:] = [e for e in edges if e[0] != rem and e[1] != rem]\n\n        if not success_state and best_path:\n            success_state = True  # We have best partial path but no direct to goal\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 2957.67374,
    "time_improvement": -9874.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 110.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 4.773080253601075,
            "num_nodes_avg": 4194.2,
            "path_length_avg": 151.32298344403884,
            "smoothness_avg": 0.012395433252009369,
            "success_improvement": 0.0,
            "time_improvement": -18429.87363986065,
            "length_improvement": 17.057474908203144,
            "smoothness_improvement": 94.0154475080767,
            "objective_score": -5525.080519739015
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 4.165340614318848,
            "num_nodes_avg": 3953.8,
            "path_length_avg": 234.20073024735348,
            "smoothness_avg": 0.008270094687292985,
            "success_improvement": 0.0,
            "time_improvement": -2472.653516573876,
            "length_improvement": 21.81705514918336,
            "smoothness_improvement": 112.7954930124798,
            "objective_score": -736.8686664772637
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 4.331844305992126,
            "num_nodes_avg": 3925.2,
            "path_length_avg": 117.01277377829413,
            "smoothness_avg": 0.01761729188713734,
            "success_improvement": 0.0,
            "time_improvement": -8720.498730744528,
            "length_improvement": 22.285687205979027,
            "smoothness_improvement": 124.09065243116615,
            "objective_score": -2611.072028520007
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm is a Heuristic-guided Anytime Dynamic RRT* (HADRRT*), combining adaptive heuristic sampling, dynamic rewiring, and anytime path improvement within a time budget. It balances exploration and exploitation using a heuristic cost-to-go estimate to bias sampling towards promising areas, dynamically updates tree connections for shorter paths, and iteratively refines the best path found so far. The planner adheres to a strict maximum execution time, ensuring timely results even in complex environments.",
    "planning_mechanism": "The planner grows a single rapidly-exploring random tree biased towards the goal using heuristic sampling. It dynamically rewires nodes within a neighborhood radius when a lower-cost connection is found, and prunes suboptimal branches. The tree is continuously refined with a goal bias and adaptive sampling radius. The algorithm stops either when a valid path is found or when the 30-second time limit expires, returning the best path discovered by then.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time = 30.0  # seconds timeout\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        goal_node = None\n        best_cost = float('inf')\n        best_path: List[Tuple[float,...]] = []\n\n        # Parameters for adaptive neighborhood radius (RRT* style)\n        gamma_rrt_star = 30.0  # tuning param for rewiring radius\n        volume = 1\n        for b in bounds:\n            volume *= b\n        rewire_radius = min(self.step_size * 15, gamma_rrt_star * ((math.log(1 + self.max_iter) / (1 + len(nodes))) ** (1/dim)))\n\n        time_start = time.time()\n\n        def heuristic(pos):\n            # Euclidean distance to goal \n            return math.dist(pos, goal_pos)\n\n        def random_sample():\n            # Biased sampling with goal bias and informed ellipse sampling\n            goal_bias = 0.1\n            if random.random() < goal_bias:\n                return goal_pos\n            # Informed set ellipse sampling when path found\n            if best_path:\n                c_best = best_cost\n                c_min = heuristic(start_pos)\n                if c_best == float('inf') or c_best <= c_min:\n                    # uniform sample\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                x_center = [(s + g) / 2 for s,g in zip(start_pos, goal_pos)]\n                a1 = [g - s for s,g in zip(start_pos, goal_pos)]\n                norm_a1 = math.dist(start_pos, goal_pos)\n                if norm_a1 == 0:\n                    return goal_pos\n                a1 = [v / norm_a1 for v in a1]\n\n                import numpy as np\n                a1_np = np.array(a1).reshape((dim,1))\n                id_matrix = np.eye(dim)\n                M = a1_np @ id_matrix[0].reshape((1,dim))\n                U, _, Vt = np.linalg.svd(M)\n                det = np.linalg.det(U) * np.linalg.det(Vt)\n                C = U @ np.diag([1]*(dim-1) + [det]) @ Vt\n\n                r1 = c_best/2.0\n                r2 = math.sqrt(c_best**2 - c_min**2)/2.0\n                L = np.diag([r1] + [r2]*(dim-1))\n\n                while True:\n                    x_ball = np.random.normal(0,1,dim)\n                    x_ball /= np.linalg.norm(x_ball)\n                    scale = random.random()**(1/dim)\n                    x_ball *= scale\n                    x_rand = (C @ L @ x_ball) + np.array(x_center)\n                    x_rand_t = tuple(float(x_rand[d]) for d in range(dim))\n                    # Check bounds\n                    if all(0 <= x_rand_t[d] <= bounds[d] for d in range(dim)):\n                        # Check obstacle\n                        if not self._is_in_obstacle(x_rand_t, obstacles, is_3d):\n                            return x_rand_t\n            else:\n                # Uniform random sample\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest_node(pos):\n            return min(nodes, key=lambda n: math.dist(n.position, pos))\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i]) * ratio for i in range(dim))\n\n        def near_nodes(node_new, radius):\n            return [n for n in nodes if math.dist(n.position, node_new.position) <= radius]\n\n        def replace_parent(child: Node, new_parent: Node, cost_new_parent: float):\n            if child.parent:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = cost_new_parent\n            new_parent.add_child(child)\n\n        for iteration in range(self.max_iter):\n            elapsed = time.time() - time_start\n            if elapsed > self.max_time:\n                # Timeout reached, stop and return best path found so far\n                break\n\n            sample_pos = random_sample()\n            nearest = nearest_node(sample_pos)\n            new_pos = steer(nearest.position, sample_pos, self.step_size)\n\n            # Collision checks for position and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n            # Check boundary\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if new_cost >= best_cost:\n                # Prune expansions that can't improve best path\n                # But allow if no path yet\n                if best_cost < float('inf'):\n                    continue\n\n            node_new = Node(new_pos, nearest, new_cost)\n            nearest.add_child(node_new)\n            nodes.append(node_new)\n            edges.append((nearest, node_new))\n\n            # Rewiring near nodes if it reduces cost and collision free\n            radius = min(rewire_radius, self.step_size * (math.log(len(nodes)+1)/ (len(nodes)+1))**(1/dim) * gamma_rrt_star)\n            neighbors = near_nodes(node_new, radius)\n            for near in neighbors:\n                if near == node_new.parent:\n                    continue\n                cost_through_new = node_new.cost + math.dist(node_new.position, near.position)\n                if cost_through_new + heuristic(near.position) >= best_cost:\n                    continue\n                if cost_through_new < near.cost:\n                    # Check edge collision\n                    if self._is_edge_in_obstacle(node_new.position, near.position, obstacles, is_3d):\n                        continue\n                    replace_parent(near, node_new, cost_through_new)\n                    edges.append((node_new, near))\n\n            # Check if new node can connect directly to goal improving cost\n            dist_to_goal = math.dist(node_new.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                # Check goal connection collision\n                if not self._is_edge_in_obstacle(node_new.position, goal_pos, obstacles, is_3d) and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                    total_cost = node_new.cost + dist_to_goal\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        goal_node = Node(goal_pos, node_new, total_cost)\n                        node_new.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((node_new, goal_node))\n                        best_path = goal_node.path_from_root()\n                        success_state = True\n\n            # Periodically prune nodes far from optimal path or high cost\n            if iteration % 100 == 0 and best_path:\n                prune_threshold = best_cost * 1.5\n                removable = []\n                for n in nodes:\n                    if n.cost > prune_threshold:\n                        removable.append(n)\n                for rem in removable:\n                    if rem.parent:\n                        rem.parent.remove_child(rem)\n                    nodes.remove(rem)\n                    # Remove edges linked to rem\n                    edges[:] = [e for e in edges if e[0] != rem and e[1] != rem]\n\n        if not success_state and best_path:\n            success_state = True  # We have best partial path but no direct to goal\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 2913.2097,
    "time_improvement": -9726.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 99.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 4.806441903114319,
            "num_nodes_avg": 4105.3,
            "path_length_avg": 152.1899590345524,
            "smoothness_avg": 0.01149605604877608,
            "success_improvement": 0.0,
            "time_improvement": -18559.388987823077,
            "length_improvement": 16.582271848935285,
            "smoothness_improvement": 79.9382412486196,
            "objective_score": -5564.100550770893
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 4.194818472862243,
            "num_nodes_avg": 3931.1,
            "path_length_avg": 234.08475715231043,
            "smoothness_avg": 0.007817013493030198,
            "success_improvement": 0.0,
            "time_improvement": -2490.86002678868,
            "length_improvement": 21.85577030640918,
            "smoothness_improvement": 101.13738754290486,
            "objective_score": -742.3811670376077
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 4.040528774261475,
            "num_nodes_avg": 3930.6,
            "path_length_avg": 116.95670908388759,
            "smoothness_avg": 0.017055034739286733,
            "success_improvement": 0.0,
            "time_improvement": -8127.322222918059,
            "length_improvement": 22.322922706489994,
            "smoothness_improvement": 116.93878301201207,
            "objective_score": -2433.1473884190596
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm is a Heuristic-guided Anytime Dynamic RRT* (HADRRT*), combining adaptive heuristic sampling, dynamic rewiring, and anytime path improvement within a time budget. It balances exploration and exploitation using a heuristic cost-to-go estimate to bias sampling towards promising areas, dynamically updates tree connections for shorter paths, and iteratively refines the best path found so far. The planner adheres to a strict maximum execution time, ensuring timely results even in complex environments.",
    "planning_mechanism": "The planner grows a single rapidly-exploring random tree biased towards the goal using heuristic sampling. It dynamically rewires nodes within a neighborhood radius when a lower-cost connection is found, and prunes suboptimal branches. The tree is continuously refined with a goal bias and adaptive sampling radius. The algorithm stops either when a valid path is found or when the 30-second time limit expires, returning the best path discovered by then.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.max_time = 30.0  # seconds timeout\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_pos, None, 0.0)\n        nodes.append(root)\n\n        goal_node = None\n        best_cost = float('inf')\n        best_path: List[Tuple[float,...]] = []\n\n        # Parameters for adaptive neighborhood radius (RRT* style)\n        gamma_rrt_star = 30.0  # tuning param for rewiring radius\n        volume = 1\n        for b in bounds:\n            volume *= b\n        rewire_radius = min(self.step_size * 15, gamma_rrt_star * ((math.log(1 + self.max_iter) / (1 + len(nodes))) ** (1/dim)))\n\n        time_start = time.time()\n\n        def heuristic(pos):\n            # Euclidean distance to goal \n            return math.dist(pos, goal_pos)\n\n        def random_sample():\n            # Biased sampling with goal bias and informed ellipse sampling\n            goal_bias = 0.1\n            if random.random() < goal_bias:\n                return goal_pos\n            # Informed set ellipse sampling when path found\n            if best_path:\n                c_best = best_cost\n                c_min = heuristic(start_pos)\n                if c_best == float('inf') or c_best <= c_min:\n                    # uniform sample\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                x_center = [(s + g) / 2 for s,g in zip(start_pos, goal_pos)]\n                a1 = [g - s for s,g in zip(start_pos, goal_pos)]\n                norm_a1 = math.dist(start_pos, goal_pos)\n                if norm_a1 == 0:\n                    return goal_pos\n                a1 = [v / norm_a1 for v in a1]\n\n                import numpy as np\n                a1_np = np.array(a1).reshape((dim,1))\n                id_matrix = np.eye(dim)\n                M = a1_np @ id_matrix[0].reshape((1,dim))\n                U, _, Vt = np.linalg.svd(M)\n                det = np.linalg.det(U) * np.linalg.det(Vt)\n                C = U @ np.diag([1]*(dim-1) + [det]) @ Vt\n\n                r1 = c_best/2.0\n                r2 = math.sqrt(c_best**2 - c_min**2)/2.0\n                L = np.diag([r1] + [r2]*(dim-1))\n\n                while True:\n                    x_ball = np.random.normal(0,1,dim)\n                    x_ball /= np.linalg.norm(x_ball)\n                    scale = random.random()**(1/dim)\n                    x_ball *= scale\n                    x_rand = (C @ L @ x_ball) + np.array(x_center)\n                    x_rand_t = tuple(float(x_rand[d]) for d in range(dim))\n                    # Check bounds\n                    if all(0 <= x_rand_t[d] <= bounds[d] for d in range(dim)):\n                        # Check obstacle\n                        if not self._is_in_obstacle(x_rand_t, obstacles, is_3d):\n                            return x_rand_t\n            else:\n                # Uniform random sample\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest_node(pos):\n            return min(nodes, key=lambda n: math.dist(n.position, pos))\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[i] + (to_pos[i]-from_pos[i]) * ratio for i in range(dim))\n\n        def near_nodes(node_new, radius):\n            return [n for n in nodes if math.dist(n.position, node_new.position) <= radius]\n\n        def replace_parent(child: Node, new_parent: Node, cost_new_parent: float):\n            if child.parent:\n                child.parent.remove_child(child)\n            child.parent = new_parent\n            child.cost = cost_new_parent\n            new_parent.add_child(child)\n\n        for iteration in range(self.max_iter):\n            elapsed = time.time() - time_start\n            if elapsed > self.max_time:\n                # Timeout reached, stop and return best path found so far\n                break\n\n            sample_pos = random_sample()\n            nearest = nearest_node(sample_pos)\n            new_pos = steer(nearest.position, sample_pos, self.step_size)\n\n            # Collision checks for position and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n            # Check boundary\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if new_cost >= best_cost:\n                # Prune expansions that can't improve best path\n                # But allow if no path yet\n                if best_cost < float('inf'):\n                    continue\n\n            node_new = Node(new_pos, nearest, new_cost)\n            nearest.add_child(node_new)\n            nodes.append(node_new)\n            edges.append((nearest, node_new))\n\n            # Rewiring near nodes if it reduces cost and collision free\n            radius = min(rewire_radius, self.step_size * (math.log(len(nodes)+1)/ (len(nodes)+1))**(1/dim) * gamma_rrt_star)\n            neighbors = near_nodes(node_new, radius)\n            for near in neighbors:\n                if near == node_new.parent:\n                    continue\n                cost_through_new = node_new.cost + math.dist(node_new.position, near.position)\n                if cost_through_new + heuristic(near.position) >= best_cost:\n                    continue\n                if cost_through_new < near.cost:\n                    # Check edge collision\n                    if self._is_edge_in_obstacle(node_new.position, near.position, obstacles, is_3d):\n                        continue\n                    replace_parent(near, node_new, cost_through_new)\n                    edges.append((node_new, near))\n\n            # Check if new node can connect directly to goal improving cost\n            dist_to_goal = math.dist(node_new.position, goal_pos)\n            if dist_to_goal <= self.step_size:\n                # Check goal connection collision\n                if not self._is_edge_in_obstacle(node_new.position, goal_pos, obstacles, is_3d) and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                    total_cost = node_new.cost + dist_to_goal\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        goal_node = Node(goal_pos, node_new, total_cost)\n                        node_new.add_child(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((node_new, goal_node))\n                        best_path = goal_node.path_from_root()\n                        success_state = True\n\n            # Periodically prune nodes far from optimal path or high cost\n            if iteration % 100 == 0 and best_path:\n                prune_threshold = best_cost * 1.5\n                removable = []\n                for n in nodes:\n                    if n.cost > prune_threshold:\n                        removable.append(n)\n                for rem in removable:\n                    if rem.parent:\n                        rem.parent.remove_child(rem)\n                    nodes.remove(rem)\n                    # Remove edges linked to rem\n                    edges[:] = [e for e in edges if e[0] != rem and e[1] != rem]\n\n        if not success_state and best_path:\n            success_state = True  # We have best partial path but no direct to goal\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 2945.82115,
    "time_improvement": -9834.0,
    "length_improvement": 20.0,
    "smoothness_improvement": 101.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 4.692332339286804,
            "num_nodes_avg": 4132.4,
            "path_length_avg": 153.06733277608018,
            "smoothness_avg": 0.011664086833489781,
            "success_improvement": 0.0,
            "time_improvement": -18116.397107008124,
            "length_improvement": 16.101369398327293,
            "smoothness_improvement": 82.56828791407823,
            "objective_score": -5431.286016783201
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 4.398558306694031,
            "num_nodes_avg": 3964.1,
            "path_length_avg": 231.80156715756556,
            "smoothness_avg": 0.008458596810207619,
            "success_improvement": 0.0,
            "time_improvement": -2616.6965545798744,
            "length_improvement": 22.617964844635186,
            "smoothness_improvement": 117.64578840766448,
            "objective_score": -779.897144462997
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 4.35616888999939,
            "num_nodes_avg": 3935.3,
            "path_length_avg": 118.8655507179631,
            "smoothness_avg": 0.01599390799211847,
            "success_improvement": 0.0,
            "time_improvement": -8770.028433847008,
            "length_improvement": 21.05516098240793,
            "smoothness_improvement": 103.44132911226085,
            "objective_score": -2626.28029131206
        }
    ],
    "success_rate": 1.0
}
